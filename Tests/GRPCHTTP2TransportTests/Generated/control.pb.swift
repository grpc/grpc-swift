// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: control.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

//
// Copyright 2024, gRPC Authors All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum StatusCode: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case ok // = 0
  case cancelled // = 1
  case unknown // = 2
  case invalidArgument // = 3
  case deadlineExceeded // = 4
  case notFound // = 5
  case alreadyExists // = 6
  case permissionDenied // = 7
  case resourceExhausted // = 8
  case failedPrecondition // = 9
  case aborted // = 10
  case outOfRange // = 11
  case unimplemented // = 12
  case `internal` // = 13
  case unavailable // = 14
  case dataLoss // = 15
  case unauthenticated // = 16
  case UNRECOGNIZED(Int)

  init() {
    self = .ok
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .ok
    case 1: self = .cancelled
    case 2: self = .unknown
    case 3: self = .invalidArgument
    case 4: self = .deadlineExceeded
    case 5: self = .notFound
    case 6: self = .alreadyExists
    case 7: self = .permissionDenied
    case 8: self = .resourceExhausted
    case 9: self = .failedPrecondition
    case 10: self = .aborted
    case 11: self = .outOfRange
    case 12: self = .unimplemented
    case 13: self = .internal
    case 14: self = .unavailable
    case 15: self = .dataLoss
    case 16: self = .unauthenticated
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .ok: return 0
    case .cancelled: return 1
    case .unknown: return 2
    case .invalidArgument: return 3
    case .deadlineExceeded: return 4
    case .notFound: return 5
    case .alreadyExists: return 6
    case .permissionDenied: return 7
    case .resourceExhausted: return 8
    case .failedPrecondition: return 9
    case .aborted: return 10
    case .outOfRange: return 11
    case .unimplemented: return 12
    case .internal: return 13
    case .unavailable: return 14
    case .dataLoss: return 15
    case .unauthenticated: return 16
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [StatusCode] = [
    .ok,
    .cancelled,
    .unknown,
    .invalidArgument,
    .deadlineExceeded,
    .notFound,
    .alreadyExists,
    .permissionDenied,
    .resourceExhausted,
    .failedPrecondition,
    .aborted,
    .outOfRange,
    .unimplemented,
    .internal,
    .unavailable,
    .dataLoss,
    .unauthenticated,
  ]

}

struct ControlInput: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Whether metadata should be echo'd back in the initial metadata.
  ///
  /// Ignored if the initial metadata has already been sent back to the
  /// client.
  ///
  /// Each header field name in the request headers will be prefixed with
  /// "echo-". For example the header field name "foo" will be returned
  /// as "echo-foo. Note that semicolons aren't valid in HTTP header field
  /// names (apart from pseudo headers). As such all semicolons should be
  /// removed (":path" should become "echo-path").
  var echoMetadataInHeaders: Bool = false

  /// Parameters for response messages.
  var messageParams: PayloadParameters {
    get {return _messageParams ?? PayloadParameters()}
    set {_messageParams = newValue}
  }
  /// Returns true if `messageParams` has been explicitly set.
  var hasMessageParams: Bool {return self._messageParams != nil}
  /// Clears the value of `messageParams`. Subsequent reads from it will return its default value.
  mutating func clearMessageParams() {self._messageParams = nil}

  /// The number of response messages.
  var numberOfMessages: Int32 = 0

  /// The status code and message to use at the end of the RPC.
  ///
  /// If this is set then the RPC will be ended after `number_of_messages`
  /// messages have been sent back to the client.
  var status: RPCStatus {
    get {return _status ?? RPCStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  /// Whether the response should be trailers only.
  ///
  /// Ignored unless it's set on the first message on the stream. When set
  /// the RPC will be completed with a trailers-only response using the
  /// status code and message from 'status'. The request metadata will be
  /// included if 'echo_metadata_in_trailers' is set.
  ///
  /// If this is set then 'number_of_messages', 'message_params', and
  /// 'echo_metadata_in_headers' are ignored.
  var isTrailersOnly: Bool = false

  /// Whether metadata should be echo'd back in the trailing metadata.
  ///
  /// Ignored unless 'status' is set.
  ///
  /// Each header field name in the request headers will be prefixed with
  /// "echo-". For example the header field name "foo" will be returned
  /// as "echo-foo. Note that semicolons aren't valid in HTTP header field
  /// names (apart from pseudo headers). As such all semicolons should be
  /// removed (":path" should become "echo-path").
  var echoMetadataInTrailers: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _messageParams: PayloadParameters? = nil
  fileprivate var _status: RPCStatus? = nil
}

struct RPCStatus: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Status code indicating the outcome of the RPC.
  var code: StatusCode = .ok

  /// The message to include with the 'code' at the end of the RPC.
  var message: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PayloadParameters: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The number of bytes to put into the output payload.
  var size: Int32 = 0

  /// The content to use in the payload. The value is truncated to an octet.
  var content: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ControlOutput: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var payload: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension StatusCode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "CANCELLED"),
    2: .same(proto: "UNKNOWN"),
    3: .same(proto: "INVALID_ARGUMENT"),
    4: .same(proto: "DEADLINE_EXCEEDED"),
    5: .same(proto: "NOT_FOUND"),
    6: .same(proto: "ALREADY_EXISTS"),
    7: .same(proto: "PERMISSION_DENIED"),
    8: .same(proto: "RESOURCE_EXHAUSTED"),
    9: .same(proto: "FAILED_PRECONDITION"),
    10: .same(proto: "ABORTED"),
    11: .same(proto: "OUT_OF_RANGE"),
    12: .same(proto: "UNIMPLEMENTED"),
    13: .same(proto: "INTERNAL"),
    14: .same(proto: "UNAVAILABLE"),
    15: .same(proto: "DATA_LOSS"),
    16: .same(proto: "UNAUTHENTICATED"),
  ]
}

extension ControlInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ControlInput"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "echo_metadata_in_headers"),
    2: .standard(proto: "message_params"),
    3: .standard(proto: "number_of_messages"),
    5: .same(proto: "status"),
    6: .standard(proto: "is_trailers_only"),
    4: .standard(proto: "echo_metadata_in_trailers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.echoMetadataInHeaders) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._messageParams) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.numberOfMessages) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.echoMetadataInTrailers) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.isTrailersOnly) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.echoMetadataInHeaders != false {
      try visitor.visitSingularBoolField(value: self.echoMetadataInHeaders, fieldNumber: 1)
    }
    try { if let v = self._messageParams {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.numberOfMessages != 0 {
      try visitor.visitSingularInt32Field(value: self.numberOfMessages, fieldNumber: 3)
    }
    if self.echoMetadataInTrailers != false {
      try visitor.visitSingularBoolField(value: self.echoMetadataInTrailers, fieldNumber: 4)
    }
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if self.isTrailersOnly != false {
      try visitor.visitSingularBoolField(value: self.isTrailersOnly, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ControlInput, rhs: ControlInput) -> Bool {
    if lhs.echoMetadataInHeaders != rhs.echoMetadataInHeaders {return false}
    if lhs._messageParams != rhs._messageParams {return false}
    if lhs.numberOfMessages != rhs.numberOfMessages {return false}
    if lhs._status != rhs._status {return false}
    if lhs.isTrailersOnly != rhs.isTrailersOnly {return false}
    if lhs.echoMetadataInTrailers != rhs.echoMetadataInTrailers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RPCStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "RPCStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RPCStatus, rhs: RPCStatus) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PayloadParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PayloadParameters"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "size"),
    2: .same(proto: "content"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.size) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.content) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.size != 0 {
      try visitor.visitSingularInt32Field(value: self.size, fieldNumber: 1)
    }
    if self.content != 0 {
      try visitor.visitSingularUInt32Field(value: self.content, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PayloadParameters, rhs: PayloadParameters) -> Bool {
    if lhs.size != rhs.size {return false}
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ControlOutput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ControlOutput"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "payload"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.payload) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.payload.isEmpty {
      try visitor.visitSingularBytesField(value: self.payload, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ControlOutput, rhs: ControlOutput) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
