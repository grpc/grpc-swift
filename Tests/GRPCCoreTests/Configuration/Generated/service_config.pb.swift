// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: grpc/service_config/service_config.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2016 The gRPC Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// A ServiceConfig is supplied when a service is deployed. It mostly contains
// parameters for how clients that connect to the service should behave (for
// example, the load balancing policy to use to pick between service replicas).
//
// The configuration options provided here act as overrides to automatically
// chosen option values. Service owners should be conservative in specifying
// options as the system is likely to choose better values for these options in
// the vast majority of cases. In other words, please specify a configuration
// option only if you really have to, and avoid copy-paste inclusion of configs.
//
// Note that gRPC uses the service config in JSON form, not in protobuf
// form.  This proto definition is intended to help document the schema but
// will not actually be used directly by gRPC.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Configuration for a method.
struct Grpc_ServiceConfig_MethodConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: [Grpc_ServiceConfig_MethodConfig.Name] = []

  /// Whether RPCs sent to this method should wait until the connection is
  /// ready by default. If false, the RPC will abort immediately if there is
  /// a transient failure connecting to the server. Otherwise, gRPC will
  /// attempt to connect until the deadline is exceeded.
  ///
  /// The value specified via the gRPC client API will override the value
  /// set here. However, note that setting the value in the client API will
  /// also affect transient errors encountered during name resolution, which
  /// cannot be caught by the value here, since the service config is
  /// obtained by the gRPC client via name resolution.
  var waitForReady: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _waitForReady ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_waitForReady = newValue}
  }
  /// Returns true if `waitForReady` has been explicitly set.
  var hasWaitForReady: Bool {return self._waitForReady != nil}
  /// Clears the value of `waitForReady`. Subsequent reads from it will return its default value.
  mutating func clearWaitForReady() {self._waitForReady = nil}

  /// The default timeout in seconds for RPCs sent to this method. This can be
  /// overridden in code. If no reply is received in the specified amount of
  /// time, the request is aborted and a DEADLINE_EXCEEDED error status
  /// is returned to the caller.
  ///
  /// The actual deadline used will be the minimum of the value specified here
  /// and the value set by the application via the gRPC client API.  If either
  /// one is not set, then the other will be used.  If neither is set, then the
  /// request has no deadline.
  var timeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _timeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_timeout = newValue}
  }
  /// Returns true if `timeout` has been explicitly set.
  var hasTimeout: Bool {return self._timeout != nil}
  /// Clears the value of `timeout`. Subsequent reads from it will return its default value.
  mutating func clearTimeout() {self._timeout = nil}

  /// The maximum allowed payload size for an individual request or object in a
  /// stream (client->server) in bytes. The size which is measured is the
  /// serialized payload after per-message compression (but before stream
  /// compression) in bytes. This applies both to streaming and non-streaming
  /// requests.
  ///
  /// The actual value used is the minimum of the value specified here and the
  /// value set by the application via the gRPC client API.  If either one is
  /// not set, then the other will be used.  If neither is set, then the
  /// built-in default is used.
  ///
  /// If a client attempts to send an object larger than this value, it will not
  /// be sent and the client will see a ClientError.
  /// Note that 0 is a valid value, meaning that the request message
  /// must be empty.
  var maxRequestMessageBytes: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _maxRequestMessageBytes ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_maxRequestMessageBytes = newValue}
  }
  /// Returns true if `maxRequestMessageBytes` has been explicitly set.
  var hasMaxRequestMessageBytes: Bool {return self._maxRequestMessageBytes != nil}
  /// Clears the value of `maxRequestMessageBytes`. Subsequent reads from it will return its default value.
  mutating func clearMaxRequestMessageBytes() {self._maxRequestMessageBytes = nil}

  /// The maximum allowed payload size for an individual response or object in a
  /// stream (server->client) in bytes. The size which is measured is the
  /// serialized payload after per-message compression (but before stream
  /// compression) in bytes. This applies both to streaming and non-streaming
  /// requests.
  ///
  /// The actual value used is the minimum of the value specified here and the
  /// value set by the application via the gRPC client API.  If either one is
  /// not set, then the other will be used.  If neither is set, then the
  /// built-in default is used.
  ///
  /// If a server attempts to send an object larger than this value, it will not
  /// be sent, and a ServerError will be sent to the client instead.
  /// Note that 0 is a valid value, meaning that the response message
  /// must be empty.
  var maxResponseMessageBytes: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _maxResponseMessageBytes ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_maxResponseMessageBytes = newValue}
  }
  /// Returns true if `maxResponseMessageBytes` has been explicitly set.
  var hasMaxResponseMessageBytes: Bool {return self._maxResponseMessageBytes != nil}
  /// Clears the value of `maxResponseMessageBytes`. Subsequent reads from it will return its default value.
  mutating func clearMaxResponseMessageBytes() {self._maxResponseMessageBytes = nil}

  /// Only one of retry_policy or hedging_policy may be set. If neither is set,
  /// RPCs will not be retried or hedged.
  var retryOrHedgingPolicy: Grpc_ServiceConfig_MethodConfig.OneOf_RetryOrHedgingPolicy? = nil

  var retryPolicy: Grpc_ServiceConfig_MethodConfig.RetryPolicy {
    get {
      if case .retryPolicy(let v)? = retryOrHedgingPolicy {return v}
      return Grpc_ServiceConfig_MethodConfig.RetryPolicy()
    }
    set {retryOrHedgingPolicy = .retryPolicy(newValue)}
  }

  var hedgingPolicy: Grpc_ServiceConfig_MethodConfig.HedgingPolicy {
    get {
      if case .hedgingPolicy(let v)? = retryOrHedgingPolicy {return v}
      return Grpc_ServiceConfig_MethodConfig.HedgingPolicy()
    }
    set {retryOrHedgingPolicy = .hedgingPolicy(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Only one of retry_policy or hedging_policy may be set. If neither is set,
  /// RPCs will not be retried or hedged.
  enum OneOf_RetryOrHedgingPolicy: Equatable {
    case retryPolicy(Grpc_ServiceConfig_MethodConfig.RetryPolicy)
    case hedgingPolicy(Grpc_ServiceConfig_MethodConfig.HedgingPolicy)

  #if !swift(>=4.1)
    static func ==(lhs: Grpc_ServiceConfig_MethodConfig.OneOf_RetryOrHedgingPolicy, rhs: Grpc_ServiceConfig_MethodConfig.OneOf_RetryOrHedgingPolicy) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.retryPolicy, .retryPolicy): return {
        guard case .retryPolicy(let l) = lhs, case .retryPolicy(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.hedgingPolicy, .hedgingPolicy): return {
        guard case .hedgingPolicy(let l) = lhs, case .hedgingPolicy(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// The names of the methods to which this configuration applies.
  /// - MethodConfig without names (empty list) will be skipped.
  /// - Each name entry must be unique across the entire ServiceConfig.
  /// - If the 'method' field is empty, this MethodConfig specifies the defaults
  ///   for all methods for the specified service.
  /// - If the 'service' field is empty, the 'method' field must be empty, and
  ///   this MethodConfig specifies the default for all methods (it's the default
  ///   config).
  ///
  /// When determining which MethodConfig to use for a given RPC, the most
  /// specific match wins. For example, let's say that the service config
  /// contains the following MethodConfig entries:
  ///
  /// method_config { name { } ... }
  /// method_config { name { service: "MyService" } ... }
  /// method_config { name { service: "MyService" method: "Foo" } ... }
  ///
  /// MyService/Foo will use the third entry, because it exactly matches the
  /// service and method name. MyService/Bar will use the second entry, because
  /// it provides the default for all methods of MyService. AnotherService/Baz
  /// will use the first entry, because it doesn't match the other two.
  ///
  /// In JSON representation, value "", value `null`, and not present are the
  /// same. The following are the same Name:
  /// - { "service": "s" }
  /// - { "service": "s", "method": null }
  /// - { "service": "s", "method": "" }
  struct Name {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Required. Includes proto package name.
    var service: String = String()

    var method: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// The retry policy for outgoing RPCs.
  struct RetryPolicy {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The maximum number of RPC attempts, including the original attempt.
    ///
    /// This field is required and must be greater than 1.
    /// Any value greater than 5 will be treated as if it were 5.
    var maxAttempts: UInt32 = 0

    /// Exponential backoff parameters. The initial retry attempt will occur at
    /// random(0, initial_backoff). In general, the nth attempt will occur at
    /// random(0,
    ///   min(initial_backoff*backoff_multiplier**(n-1), max_backoff)).
    /// Required. Must be greater than zero.
    var initialBackoff: SwiftProtobuf.Google_Protobuf_Duration {
      get {return _initialBackoff ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_initialBackoff = newValue}
    }
    /// Returns true if `initialBackoff` has been explicitly set.
    var hasInitialBackoff: Bool {return self._initialBackoff != nil}
    /// Clears the value of `initialBackoff`. Subsequent reads from it will return its default value.
    mutating func clearInitialBackoff() {self._initialBackoff = nil}

    /// Required. Must be greater than zero.
    var maxBackoff: SwiftProtobuf.Google_Protobuf_Duration {
      get {return _maxBackoff ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_maxBackoff = newValue}
    }
    /// Returns true if `maxBackoff` has been explicitly set.
    var hasMaxBackoff: Bool {return self._maxBackoff != nil}
    /// Clears the value of `maxBackoff`. Subsequent reads from it will return its default value.
    mutating func clearMaxBackoff() {self._maxBackoff = nil}

    /// Required. Must be greater than zero.
    var backoffMultiplier: Float = 0

    /// The set of status codes which may be retried.
    ///
    /// This field is required and must be non-empty.
    var retryableStatusCodes: [Google_Rpc_Code] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _initialBackoff: SwiftProtobuf.Google_Protobuf_Duration? = nil
    fileprivate var _maxBackoff: SwiftProtobuf.Google_Protobuf_Duration? = nil
  }

  /// The hedging policy for outgoing RPCs. Hedged RPCs may execute more than
  /// once on the server, so only idempotent methods should specify a hedging
  /// policy.
  struct HedgingPolicy {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The hedging policy will send up to max_requests RPCs.
    /// This number represents the total number of all attempts, including
    /// the original attempt.
    ///
    /// This field is required and must be greater than 1.
    /// Any value greater than 5 will be treated as if it were 5.
    var maxAttempts: UInt32 = 0

    /// The first RPC will be sent immediately, but the max_requests-1 subsequent
    /// hedged RPCs will be sent at intervals of every hedging_delay. Set this
    /// to 0 to immediately send all max_requests RPCs.
    var hedgingDelay: SwiftProtobuf.Google_Protobuf_Duration {
      get {return _hedgingDelay ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_hedgingDelay = newValue}
    }
    /// Returns true if `hedgingDelay` has been explicitly set.
    var hasHedgingDelay: Bool {return self._hedgingDelay != nil}
    /// Clears the value of `hedgingDelay`. Subsequent reads from it will return its default value.
    mutating func clearHedgingDelay() {self._hedgingDelay = nil}

    /// The set of status codes which indicate other hedged RPCs may still
    /// succeed. If a non-fatal status code is returned by the server, hedged
    /// RPCs will continue. Otherwise, outstanding requests will be canceled and
    /// the error returned to the client application layer.
    ///
    /// This field is optional.
    var nonFatalStatusCodes: [Google_Rpc_Code] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _hedgingDelay: SwiftProtobuf.Google_Protobuf_Duration? = nil
  }

  init() {}

  fileprivate var _waitForReady: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
  fileprivate var _timeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _maxRequestMessageBytes: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
  fileprivate var _maxResponseMessageBytes: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
}

/// Configuration for pick_first LB policy.
struct Grpc_ServiceConfig_PickFirstConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If set to true, instructs the LB policy to randomly shuffle the list of
  /// addresses received from the name resolver before attempting to connect to
  /// them.
  var shuffleAddressList: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Configuration for round_robin LB policy.
struct Grpc_ServiceConfig_RoundRobinConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Configuration for weighted_round_robin LB policy.
struct Grpc_ServiceConfig_WeightedRoundRobinLbConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Whether to enable out-of-band utilization reporting collection from
  /// the endpoints.  By default, per-request utilization reporting is used.
  var enableOobLoadReport: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _enableOobLoadReport ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_enableOobLoadReport = newValue}
  }
  /// Returns true if `enableOobLoadReport` has been explicitly set.
  var hasEnableOobLoadReport: Bool {return self._enableOobLoadReport != nil}
  /// Clears the value of `enableOobLoadReport`. Subsequent reads from it will return its default value.
  mutating func clearEnableOobLoadReport() {self._enableOobLoadReport = nil}

  /// Load reporting interval to request from the server.  Note that the
  /// server may not provide reports as frequently as the client requests.
  /// Used only when enable_oob_load_report is true.  Default is 10 seconds.
  var oobReportingPeriod: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _oobReportingPeriod ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_oobReportingPeriod = newValue}
  }
  /// Returns true if `oobReportingPeriod` has been explicitly set.
  var hasOobReportingPeriod: Bool {return self._oobReportingPeriod != nil}
  /// Clears the value of `oobReportingPeriod`. Subsequent reads from it will return its default value.
  mutating func clearOobReportingPeriod() {self._oobReportingPeriod = nil}

  /// A given endpoint must report load metrics continuously for at least
  /// this long before the endpoint weight will be used.  This avoids
  /// churn when the set of endpoint addresses changes.  Takes effect
  /// both immediately after we establish a connection to an endpoint and
  /// after weight_expiration_period has caused us to stop using the most
  /// recent load metrics.  Default is 10 seconds.
  var blackoutPeriod: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _blackoutPeriod ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_blackoutPeriod = newValue}
  }
  /// Returns true if `blackoutPeriod` has been explicitly set.
  var hasBlackoutPeriod: Bool {return self._blackoutPeriod != nil}
  /// Clears the value of `blackoutPeriod`. Subsequent reads from it will return its default value.
  mutating func clearBlackoutPeriod() {self._blackoutPeriod = nil}

  /// If a given endpoint has not reported load metrics in this long,
  /// then we stop using the reported weight.  This ensures that we do
  /// not continue to use very stale weights.  Once we stop using a stale
  /// value, if we later start seeing fresh reports again, the
  /// blackout_period applies.  Defaults to 3 minutes.
  var weightExpirationPeriod: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _weightExpirationPeriod ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_weightExpirationPeriod = newValue}
  }
  /// Returns true if `weightExpirationPeriod` has been explicitly set.
  var hasWeightExpirationPeriod: Bool {return self._weightExpirationPeriod != nil}
  /// Clears the value of `weightExpirationPeriod`. Subsequent reads from it will return its default value.
  mutating func clearWeightExpirationPeriod() {self._weightExpirationPeriod = nil}

  /// How often endpoint weights are recalculated. Values less than 100ms are
  /// capped at 100ms. Default is 1 second.
  var weightUpdatePeriod: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _weightUpdatePeriod ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_weightUpdatePeriod = newValue}
  }
  /// Returns true if `weightUpdatePeriod` has been explicitly set.
  var hasWeightUpdatePeriod: Bool {return self._weightUpdatePeriod != nil}
  /// Clears the value of `weightUpdatePeriod`. Subsequent reads from it will return its default value.
  mutating func clearWeightUpdatePeriod() {self._weightUpdatePeriod = nil}

  /// The multiplier used to adjust endpoint weights with the error rate
  /// calculated as eps/qps. Configuration is rejected if this value is negative.
  /// Default is 1.0.
  var errorUtilizationPenalty: SwiftProtobuf.Google_Protobuf_FloatValue {
    get {return _errorUtilizationPenalty ?? SwiftProtobuf.Google_Protobuf_FloatValue()}
    set {_errorUtilizationPenalty = newValue}
  }
  /// Returns true if `errorUtilizationPenalty` has been explicitly set.
  var hasErrorUtilizationPenalty: Bool {return self._errorUtilizationPenalty != nil}
  /// Clears the value of `errorUtilizationPenalty`. Subsequent reads from it will return its default value.
  mutating func clearErrorUtilizationPenalty() {self._errorUtilizationPenalty = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _enableOobLoadReport: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
  fileprivate var _oobReportingPeriod: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _blackoutPeriod: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _weightExpirationPeriod: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _weightUpdatePeriod: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _errorUtilizationPenalty: SwiftProtobuf.Google_Protobuf_FloatValue? = nil
}

/// Configuration for outlier_detection LB policy
struct Grpc_ServiceConfig_OutlierDetectionLoadBalancingConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The time interval between ejection analysis sweeps. This can result in
  /// both new ejections as well as addresses being returned to service. Defaults
  /// to 10000ms or 10s.
  var interval: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _interval ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_interval = newValue}
  }
  /// Returns true if `interval` has been explicitly set.
  var hasInterval: Bool {return self._interval != nil}
  /// Clears the value of `interval`. Subsequent reads from it will return its default value.
  mutating func clearInterval() {self._interval = nil}

  /// The base time that as address is ejected for. The real time is equal to the
  /// base time multiplied by the number of times the address has been ejected.
  /// Defaults to 30000ms or 30s.
  var baseEjectionTime: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _baseEjectionTime ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_baseEjectionTime = newValue}
  }
  /// Returns true if `baseEjectionTime` has been explicitly set.
  var hasBaseEjectionTime: Bool {return self._baseEjectionTime != nil}
  /// Clears the value of `baseEjectionTime`. Subsequent reads from it will return its default value.
  mutating func clearBaseEjectionTime() {self._baseEjectionTime = nil}

  /// The maximum time that an address is ejected for. If not specified, the default value (300000ms or 300s) or
  /// the base_ejection_time value is applied, whatever is larger.
  var maxEjectionTime: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _maxEjectionTime ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_maxEjectionTime = newValue}
  }
  /// Returns true if `maxEjectionTime` has been explicitly set.
  var hasMaxEjectionTime: Bool {return self._maxEjectionTime != nil}
  /// Clears the value of `maxEjectionTime`. Subsequent reads from it will return its default value.
  mutating func clearMaxEjectionTime() {self._maxEjectionTime = nil}

  /// The maximum % of an address list that can be ejected due to outlier
  /// detection. Defaults to 10% but will eject at least one address regardless of the value.
  var maxEjectionPercent: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _maxEjectionPercent ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_maxEjectionPercent = newValue}
  }
  /// Returns true if `maxEjectionPercent` has been explicitly set.
  var hasMaxEjectionPercent: Bool {return self._maxEjectionPercent != nil}
  /// Clears the value of `maxEjectionPercent`. Subsequent reads from it will return its default value.
  mutating func clearMaxEjectionPercent() {self._maxEjectionPercent = nil}

  /// If set, success rate ejections will be performed
  var successRateEjection: Grpc_ServiceConfig_OutlierDetectionLoadBalancingConfig.SuccessRateEjection {
    get {return _successRateEjection ?? Grpc_ServiceConfig_OutlierDetectionLoadBalancingConfig.SuccessRateEjection()}
    set {_successRateEjection = newValue}
  }
  /// Returns true if `successRateEjection` has been explicitly set.
  var hasSuccessRateEjection: Bool {return self._successRateEjection != nil}
  /// Clears the value of `successRateEjection`. Subsequent reads from it will return its default value.
  mutating func clearSuccessRateEjection() {self._successRateEjection = nil}

  /// If set, failure rate ejections will be performed
  var failurePercentageEjection: Grpc_ServiceConfig_OutlierDetectionLoadBalancingConfig.FailurePercentageEjection {
    get {return _failurePercentageEjection ?? Grpc_ServiceConfig_OutlierDetectionLoadBalancingConfig.FailurePercentageEjection()}
    set {_failurePercentageEjection = newValue}
  }
  /// Returns true if `failurePercentageEjection` has been explicitly set.
  var hasFailurePercentageEjection: Bool {return self._failurePercentageEjection != nil}
  /// Clears the value of `failurePercentageEjection`. Subsequent reads from it will return its default value.
  mutating func clearFailurePercentageEjection() {self._failurePercentageEjection = nil}

  /// The config for the child policy
  var childPolicy: [Grpc_ServiceConfig_LoadBalancingConfig] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Parameters for the success rate ejection algorithm.
  /// This algorithm monitors the request success rate for all endpoints and
  /// ejects individual endpoints whose success rates are statistical outliers.
  struct SuccessRateEjection {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// This factor is used to determine the ejection threshold for success rate
    /// outlier ejection. The ejection threshold is the difference between the
    /// mean success rate, and the product of this factor and the standard
    /// deviation of the mean success rate: mean - (stdev *
    /// success_rate_stdev_factor). This factor is divided by a thousand to get a
    /// double. That is, if the desired factor is 1.9, the runtime value should
    /// be 1900. Defaults to 1900.
    var stdevFactor: SwiftProtobuf.Google_Protobuf_UInt32Value {
      get {return _stdevFactor ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
      set {_stdevFactor = newValue}
    }
    /// Returns true if `stdevFactor` has been explicitly set.
    var hasStdevFactor: Bool {return self._stdevFactor != nil}
    /// Clears the value of `stdevFactor`. Subsequent reads from it will return its default value.
    mutating func clearStdevFactor() {self._stdevFactor = nil}

    /// The % chance that an address will be actually ejected when an outlier status
    /// is detected through success rate statistics. This setting can be used to
    /// disable ejection or to ramp it up slowly. Defaults to 100.
    var enforcementPercentage: SwiftProtobuf.Google_Protobuf_UInt32Value {
      get {return _enforcementPercentage ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
      set {_enforcementPercentage = newValue}
    }
    /// Returns true if `enforcementPercentage` has been explicitly set.
    var hasEnforcementPercentage: Bool {return self._enforcementPercentage != nil}
    /// Clears the value of `enforcementPercentage`. Subsequent reads from it will return its default value.
    mutating func clearEnforcementPercentage() {self._enforcementPercentage = nil}

    /// The number of addresses that must have enough request volume to
    /// detect success rate outliers. If the number of addresses is less than this
    /// setting, outlier detection via success rate statistics is not performed
    /// for any addresses. Defaults to 5.
    var minimumHosts: SwiftProtobuf.Google_Protobuf_UInt32Value {
      get {return _minimumHosts ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
      set {_minimumHosts = newValue}
    }
    /// Returns true if `minimumHosts` has been explicitly set.
    var hasMinimumHosts: Bool {return self._minimumHosts != nil}
    /// Clears the value of `minimumHosts`. Subsequent reads from it will return its default value.
    mutating func clearMinimumHosts() {self._minimumHosts = nil}

    /// The minimum number of total requests that must be collected in one
    /// interval (as defined by the interval duration above) to include this address
    /// in success rate based outlier detection. If the volume is lower than this
    /// setting, outlier detection via success rate statistics is not performed
    /// for that address. Defaults to 100.
    var requestVolume: SwiftProtobuf.Google_Protobuf_UInt32Value {
      get {return _requestVolume ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
      set {_requestVolume = newValue}
    }
    /// Returns true if `requestVolume` has been explicitly set.
    var hasRequestVolume: Bool {return self._requestVolume != nil}
    /// Clears the value of `requestVolume`. Subsequent reads from it will return its default value.
    mutating func clearRequestVolume() {self._requestVolume = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _stdevFactor: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
    fileprivate var _enforcementPercentage: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
    fileprivate var _minimumHosts: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
    fileprivate var _requestVolume: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
  }

  /// Parameters for the failure percentage algorithm.
  /// This algorithm ejects individual endpoints whose failure rate is greater than
  /// some threshold, independently of any other endpoint.
  struct FailurePercentageEjection {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The failure percentage to use when determining failure percentage-based outlier detection. If
    /// the failure percentage of a given address is greater than or equal to this value, it will be
    /// ejected. Defaults to 85.
    var threshold: SwiftProtobuf.Google_Protobuf_UInt32Value {
      get {return _threshold ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
      set {_threshold = newValue}
    }
    /// Returns true if `threshold` has been explicitly set.
    var hasThreshold: Bool {return self._threshold != nil}
    /// Clears the value of `threshold`. Subsequent reads from it will return its default value.
    mutating func clearThreshold() {self._threshold = nil}

    /// The % chance that an address will be actually ejected when an outlier status is detected through
    /// failure percentage statistics. This setting can be used to disable ejection or to ramp it up
    /// slowly. Defaults to 100.
    var enforcementPercentage: SwiftProtobuf.Google_Protobuf_UInt32Value {
      get {return _enforcementPercentage ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
      set {_enforcementPercentage = newValue}
    }
    /// Returns true if `enforcementPercentage` has been explicitly set.
    var hasEnforcementPercentage: Bool {return self._enforcementPercentage != nil}
    /// Clears the value of `enforcementPercentage`. Subsequent reads from it will return its default value.
    mutating func clearEnforcementPercentage() {self._enforcementPercentage = nil}

    /// The minimum number of addresses in order to perform failure percentage-based ejection.
    /// If the total number of addresses is less than this value, failure percentage-based
    /// ejection will not be performed. Defaults to 5.
    var minimumHosts: SwiftProtobuf.Google_Protobuf_UInt32Value {
      get {return _minimumHosts ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
      set {_minimumHosts = newValue}
    }
    /// Returns true if `minimumHosts` has been explicitly set.
    var hasMinimumHosts: Bool {return self._minimumHosts != nil}
    /// Clears the value of `minimumHosts`. Subsequent reads from it will return its default value.
    mutating func clearMinimumHosts() {self._minimumHosts = nil}

    /// The minimum number of total requests that must be collected in one interval (as defined by the
    /// interval duration above) to perform failure percentage-based ejection for this address. If the
    /// volume is lower than this setting, failure percentage-based ejection will not be performed for
    /// this host. Defaults to 50.
    var requestVolume: SwiftProtobuf.Google_Protobuf_UInt32Value {
      get {return _requestVolume ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
      set {_requestVolume = newValue}
    }
    /// Returns true if `requestVolume` has been explicitly set.
    var hasRequestVolume: Bool {return self._requestVolume != nil}
    /// Clears the value of `requestVolume`. Subsequent reads from it will return its default value.
    mutating func clearRequestVolume() {self._requestVolume = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _threshold: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
    fileprivate var _enforcementPercentage: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
    fileprivate var _minimumHosts: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
    fileprivate var _requestVolume: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
  }

  init() {}

  fileprivate var _interval: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _baseEjectionTime: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _maxEjectionTime: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _maxEjectionPercent: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
  fileprivate var _successRateEjection: Grpc_ServiceConfig_OutlierDetectionLoadBalancingConfig.SuccessRateEjection? = nil
  fileprivate var _failurePercentageEjection: Grpc_ServiceConfig_OutlierDetectionLoadBalancingConfig.FailurePercentageEjection? = nil
}

/// Configuration for grpclb LB policy.
struct Grpc_ServiceConfig_GrpcLbConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional.  What LB policy to use for routing between the backend
  /// addresses.  If unset, defaults to round_robin.
  /// Currently, the only supported values are round_robin and pick_first.
  /// Note that this will be used both in balancer mode and in fallback mode.
  /// Multiple LB policies can be specified; clients will iterate through
  /// the list in order and stop at the first policy that they support.
  var childPolicy: [Grpc_ServiceConfig_LoadBalancingConfig] = []

  /// Optional.  If specified, overrides the name of the service to be sent to
  /// the balancer.
  var serviceName: String = String()

  /// Optional. The timeout in seconds for receiving the server list from the LB
  /// server. Defaults to 10s.
  var initialFallbackTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _initialFallbackTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_initialFallbackTimeout = newValue}
  }
  /// Returns true if `initialFallbackTimeout` has been explicitly set.
  var hasInitialFallbackTimeout: Bool {return self._initialFallbackTimeout != nil}
  /// Clears the value of `initialFallbackTimeout`. Subsequent reads from it will return its default value.
  mutating func clearInitialFallbackTimeout() {self._initialFallbackTimeout = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _initialFallbackTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

/// Configuration for priority LB policy.
struct Grpc_ServiceConfig_PriorityLoadBalancingPolicyConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var children: Dictionary<String,Grpc_ServiceConfig_PriorityLoadBalancingPolicyConfig.Child> = [:]

  /// A list of child names in decreasing priority order
  /// (i.e., first element is the highest priority).
  var priorities: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A map of name to child policy configuration.
  /// The names are used to allow the priority policy to update
  /// existing child policies instead of creating new ones every
  /// time it receives a config update.
  struct Child {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var config: [Grpc_ServiceConfig_LoadBalancingConfig] = []

    /// If true, will ignore reresolution requests from this child.
    var ignoreReresolutionRequests: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

/// Configuration for weighted_target LB policy.
struct Grpc_ServiceConfig_WeightedTargetLoadBalancingPolicyConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var targets: Dictionary<String,Grpc_ServiceConfig_WeightedTargetLoadBalancingPolicyConfig.Target> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Target {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var weight: UInt32 = 0

    var childPolicy: [Grpc_ServiceConfig_LoadBalancingConfig] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

/// Config for RLS LB policy.
struct Grpc_ServiceConfig_RlsLoadBalancingPolicyConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var routeLookupConfig: Grpc_Lookup_V1_RouteLookupConfig {
    get {return _storage._routeLookupConfig ?? Grpc_Lookup_V1_RouteLookupConfig()}
    set {_uniqueStorage()._routeLookupConfig = newValue}
  }
  /// Returns true if `routeLookupConfig` has been explicitly set.
  var hasRouteLookupConfig: Bool {return _storage._routeLookupConfig != nil}
  /// Clears the value of `routeLookupConfig`. Subsequent reads from it will return its default value.
  mutating func clearRouteLookupConfig() {_uniqueStorage()._routeLookupConfig = nil}

  /// Service config to use for the RLS channel.
  var routeLookupChannelServiceConfig: Grpc_ServiceConfig_ServiceConfig {
    get {return _storage._routeLookupChannelServiceConfig ?? Grpc_ServiceConfig_ServiceConfig()}
    set {_uniqueStorage()._routeLookupChannelServiceConfig = newValue}
  }
  /// Returns true if `routeLookupChannelServiceConfig` has been explicitly set.
  var hasRouteLookupChannelServiceConfig: Bool {return _storage._routeLookupChannelServiceConfig != nil}
  /// Clears the value of `routeLookupChannelServiceConfig`. Subsequent reads from it will return its default value.
  mutating func clearRouteLookupChannelServiceConfig() {_uniqueStorage()._routeLookupChannelServiceConfig = nil}

  var childPolicy: [Grpc_ServiceConfig_LoadBalancingConfig] {
    get {return _storage._childPolicy}
    set {_uniqueStorage()._childPolicy = newValue}
  }

  /// Field name to add to child policy config to contain the target name.
  var childPolicyConfigTargetFieldName: String {
    get {return _storage._childPolicyConfigTargetFieldName}
    set {_uniqueStorage()._childPolicyConfigTargetFieldName = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Configuration for xds_cluster_manager_experimental LB policy.
struct Grpc_ServiceConfig_XdsClusterManagerLoadBalancingPolicyConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var children: Dictionary<String,Grpc_ServiceConfig_XdsClusterManagerLoadBalancingPolicyConfig.Child> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Child {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var childPolicy: [Grpc_ServiceConfig_LoadBalancingConfig] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

/// Configuration for the cds LB policy.
struct Grpc_ServiceConfig_CdsConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required.
  var cluster: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Represents an xDS server.
struct Grpc_ServiceConfig_XdsServer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required.
  var serverUri: String = String()

  /// A list of channel creds to use.  The first supported type will be used.
  var channelCreds: [Grpc_ServiceConfig_XdsServer.ChannelCredentials] = []

  /// A repeated list of server features.
  var serverFeatures: [SwiftProtobuf.Google_Protobuf_Value] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct ChannelCredentials {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Required.
    var type: String = String()

    /// Optional JSON config.
    var config: SwiftProtobuf.Google_Protobuf_Struct {
      get {return _config ?? SwiftProtobuf.Google_Protobuf_Struct()}
      set {_config = newValue}
    }
    /// Returns true if `config` has been explicitly set.
    var hasConfig: Bool {return self._config != nil}
    /// Clears the value of `config`. Subsequent reads from it will return its default value.
    mutating func clearConfig() {self._config = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _config: SwiftProtobuf.Google_Protobuf_Struct? = nil
  }

  init() {}
}

/// Configuration for xds_cluster_resolver LB policy.
struct Grpc_ServiceConfig_XdsClusterResolverLoadBalancingPolicyConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Ordered list of discovery mechanisms.
  /// Must have at least one element.
  /// Results from each discovery mechanism are concatenated together in
  /// successive priorities.
  var discoveryMechanisms: [Grpc_ServiceConfig_XdsClusterResolverLoadBalancingPolicyConfig.DiscoveryMechanism] = []

  /// xDS LB policy. Will be used as the child config of the xds_cluster_impl LB policy.
  var xdsLbPolicy: [Grpc_ServiceConfig_LoadBalancingConfig] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Describes a discovery mechanism instance.
  /// For EDS or LOGICAL_DNS clusters, there will be exactly one
  /// DiscoveryMechanism, which will describe the cluster of the parent
  /// CDS policy.
  /// For aggregate clusters, there will be one DiscoveryMechanism for each
  /// underlying cluster.
  struct DiscoveryMechanism {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Cluster name.
    var cluster: String {
      get {return _storage._cluster}
      set {_uniqueStorage()._cluster = newValue}
    }

    /// LRS server to send load reports to.
    /// If not present, load reporting will be disabled.
    /// If set to the empty string, load reporting will be sent to the same
    /// server that we obtained CDS data from.
    /// DEPRECATED: Use new lrs_load_reporting_server field instead.
    var lrsLoadReportingServerName: SwiftProtobuf.Google_Protobuf_StringValue {
      get {return _storage._lrsLoadReportingServerName ?? SwiftProtobuf.Google_Protobuf_StringValue()}
      set {_uniqueStorage()._lrsLoadReportingServerName = newValue}
    }
    /// Returns true if `lrsLoadReportingServerName` has been explicitly set.
    var hasLrsLoadReportingServerName: Bool {return _storage._lrsLoadReportingServerName != nil}
    /// Clears the value of `lrsLoadReportingServerName`. Subsequent reads from it will return its default value.
    mutating func clearLrsLoadReportingServerName() {_uniqueStorage()._lrsLoadReportingServerName = nil}

    /// LRS server to send load reports to.
    /// If not present, load reporting will be disabled.
    /// Supercedes lrs_load_reporting_server_name field.
    var lrsLoadReportingServer: Grpc_ServiceConfig_XdsServer {
      get {return _storage._lrsLoadReportingServer ?? Grpc_ServiceConfig_XdsServer()}
      set {_uniqueStorage()._lrsLoadReportingServer = newValue}
    }
    /// Returns true if `lrsLoadReportingServer` has been explicitly set.
    var hasLrsLoadReportingServer: Bool {return _storage._lrsLoadReportingServer != nil}
    /// Clears the value of `lrsLoadReportingServer`. Subsequent reads from it will return its default value.
    mutating func clearLrsLoadReportingServer() {_uniqueStorage()._lrsLoadReportingServer = nil}

    /// Maximum number of outstanding requests can be made to the upstream
    /// cluster.  Default is 1024.
    var maxConcurrentRequests: SwiftProtobuf.Google_Protobuf_UInt32Value {
      get {return _storage._maxConcurrentRequests ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
      set {_uniqueStorage()._maxConcurrentRequests = newValue}
    }
    /// Returns true if `maxConcurrentRequests` has been explicitly set.
    var hasMaxConcurrentRequests: Bool {return _storage._maxConcurrentRequests != nil}
    /// Clears the value of `maxConcurrentRequests`. Subsequent reads from it will return its default value.
    mutating func clearMaxConcurrentRequests() {_uniqueStorage()._maxConcurrentRequests = nil}

    var type: Grpc_ServiceConfig_XdsClusterResolverLoadBalancingPolicyConfig.DiscoveryMechanism.TypeEnum {
      get {return _storage._type}
      set {_uniqueStorage()._type = newValue}
    }

    /// For type EDS only.
    /// EDS service name, as returned in CDS.
    /// May be unset if not specified in CDS.
    var edsServiceName: String {
      get {return _storage._edsServiceName}
      set {_uniqueStorage()._edsServiceName = newValue}
    }

    /// For type LOGICAL_DNS only.
    /// DNS name to resolve in "host:port" form.
    var dnsHostname: String {
      get {return _storage._dnsHostname}
      set {_uniqueStorage()._dnsHostname = newValue}
    }

    /// The configuration for outlier_detection child policies
    /// Within this message, the child_policy field will be ignored
    var outlierDetection: Grpc_ServiceConfig_OutlierDetectionLoadBalancingConfig {
      get {return _storage._outlierDetection ?? Grpc_ServiceConfig_OutlierDetectionLoadBalancingConfig()}
      set {_uniqueStorage()._outlierDetection = newValue}
    }
    /// Returns true if `outlierDetection` has been explicitly set.
    var hasOutlierDetection: Bool {return _storage._outlierDetection != nil}
    /// Clears the value of `outlierDetection`. Subsequent reads from it will return its default value.
    mutating func clearOutlierDetection() {_uniqueStorage()._outlierDetection = nil}

    /// The configuration for xds_override_host child policy
    var overrideHostStatus: [Grpc_ServiceConfig_OverrideHostLoadBalancingPolicyConfig.HealthStatus] {
      get {return _storage._overrideHostStatus}
      set {_uniqueStorage()._overrideHostStatus = newValue}
    }

    /// Telemetry labels associated with this cluster
    var telemetryLabels: Dictionary<String,String> {
      get {return _storage._telemetryLabels}
      set {_uniqueStorage()._telemetryLabels = newValue}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum TypeEnum: SwiftProtobuf.Enum {
      typealias RawValue = Int
      case unknown // = 0
      case eds // = 1
      case logicalDns // = 2
      case UNRECOGNIZED(Int)

      init() {
        self = .unknown
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .eds
        case 2: self = .logicalDns
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .eds: return 1
        case .logicalDns: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  init() {}
}

#if swift(>=4.2)

extension Grpc_ServiceConfig_XdsClusterResolverLoadBalancingPolicyConfig.DiscoveryMechanism.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Grpc_ServiceConfig_XdsClusterResolverLoadBalancingPolicyConfig.DiscoveryMechanism.TypeEnum] = [
    .unknown,
    .eds,
    .logicalDns,
  ]
}

#endif  // swift(>=4.2)

/// Configuration for xds_cluster_impl LB policy.
struct Grpc_ServiceConfig_XdsClusterImplLoadBalancingPolicyConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Cluster name.  Required.
  var cluster: String = String()

  /// EDS service name.
  /// Not set if cluster is not an EDS cluster or if it does not
  /// specify an EDS service name.
  var edsServiceName: String = String()

  /// Server to send load reports to.
  /// If unset, no load reporting is done.
  /// If set to empty string, load reporting will be sent to the same
  /// server as we are getting xds data from.
  /// DEPRECATED: Use new lrs_load_reporting_server field instead.
  var lrsLoadReportingServerName: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _lrsLoadReportingServerName ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_lrsLoadReportingServerName = newValue}
  }
  /// Returns true if `lrsLoadReportingServerName` has been explicitly set.
  var hasLrsLoadReportingServerName: Bool {return self._lrsLoadReportingServerName != nil}
  /// Clears the value of `lrsLoadReportingServerName`. Subsequent reads from it will return its default value.
  mutating func clearLrsLoadReportingServerName() {self._lrsLoadReportingServerName = nil}

  /// LRS server to send load reports to.
  /// If not present, load reporting will be disabled.
  /// Supercedes lrs_load_reporting_server_name field.
  var lrsLoadReportingServer: Grpc_ServiceConfig_XdsServer {
    get {return _lrsLoadReportingServer ?? Grpc_ServiceConfig_XdsServer()}
    set {_lrsLoadReportingServer = newValue}
  }
  /// Returns true if `lrsLoadReportingServer` has been explicitly set.
  var hasLrsLoadReportingServer: Bool {return self._lrsLoadReportingServer != nil}
  /// Clears the value of `lrsLoadReportingServer`. Subsequent reads from it will return its default value.
  mutating func clearLrsLoadReportingServer() {self._lrsLoadReportingServer = nil}

  /// Maximum number of outstanding requests can be made to the upstream cluster.
  /// Default is 1024.
  var maxConcurrentRequests: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _maxConcurrentRequests ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_maxConcurrentRequests = newValue}
  }
  /// Returns true if `maxConcurrentRequests` has been explicitly set.
  var hasMaxConcurrentRequests: Bool {return self._maxConcurrentRequests != nil}
  /// Clears the value of `maxConcurrentRequests`. Subsequent reads from it will return its default value.
  mutating func clearMaxConcurrentRequests() {self._maxConcurrentRequests = nil}

  var dropCategories: [Grpc_ServiceConfig_XdsClusterImplLoadBalancingPolicyConfig.DropCategory] = []

  /// Child policy.
  var childPolicy: [Grpc_ServiceConfig_LoadBalancingConfig] = []

  /// Telemetry labels associated with this cluster
  var telemetryLabels: Dictionary<String,String> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Drop configuration.
  struct DropCategory {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var category: String = String()

    var requestsPerMillion: UInt32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _lrsLoadReportingServerName: SwiftProtobuf.Google_Protobuf_StringValue? = nil
  fileprivate var _lrsLoadReportingServer: Grpc_ServiceConfig_XdsServer? = nil
  fileprivate var _maxConcurrentRequests: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
}

/// Configuration for eds LB policy.
struct Grpc_ServiceConfig_EdsLoadBalancingPolicyConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Cluster name.  Required.
  var cluster: String = String()

  /// EDS service name, as returned in CDS.
  /// May be unset if not specified in CDS.
  var edsServiceName: String = String()

  /// Server to send load reports to.
  /// If unset, no load reporting is done.
  /// If set to empty string, load reporting will be sent to the same
  /// server as we are getting xds data from.
  var lrsLoadReportingServerName: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _lrsLoadReportingServerName ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_lrsLoadReportingServerName = newValue}
  }
  /// Returns true if `lrsLoadReportingServerName` has been explicitly set.
  var hasLrsLoadReportingServerName: Bool {return self._lrsLoadReportingServerName != nil}
  /// Clears the value of `lrsLoadReportingServerName`. Subsequent reads from it will return its default value.
  mutating func clearLrsLoadReportingServerName() {self._lrsLoadReportingServerName = nil}

  /// Locality-picking policy.
  /// This policy's config is expected to be in the format used
  /// by the weighted_target policy.  Note that the config should include
  /// an empty value for the "targets" field; that empty value will be
  /// replaced by one that is dynamically generated based on the EDS data.
  /// Optional; defaults to "weighted_target".
  var localityPickingPolicy: [Grpc_ServiceConfig_LoadBalancingConfig] = []

  /// Endpoint-picking policy.
  /// This will be configured as the policy for each child in the
  /// locality-policy's config.
  /// Optional; defaults to "round_robin".
  var endpointPickingPolicy: [Grpc_ServiceConfig_LoadBalancingConfig] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _lrsLoadReportingServerName: SwiftProtobuf.Google_Protobuf_StringValue? = nil
}

/// Configuration for ring_hash LB policy.
struct Grpc_ServiceConfig_RingHashLoadBalancingConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A client-side option will cap these values to 4096.  If either of these
  /// values are greater than the client-side cap, they will be treated
  /// as the client-side cap value.
  var minRingSize: UInt64 = 0

  /// Optional, defaults to 4096, max 8M.
  var maxRingSize: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Configuration for lrs LB policy.
struct Grpc_ServiceConfig_LrsLoadBalancingPolicyConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Cluster name.  Required.
  var clusterName: String = String()

  /// EDS service name, as returned in CDS.
  /// May be unset if not specified in CDS.
  var edsServiceName: String = String()

  /// Server to send load reports to.  Required.
  /// If set to empty string, load reporting will be sent to the same
  /// server as we are getting xds data from.
  var lrsLoadReportingServerName: String = String()

  var locality: Grpc_ServiceConfig_LrsLoadBalancingPolicyConfig.Locality {
    get {return _locality ?? Grpc_ServiceConfig_LrsLoadBalancingPolicyConfig.Locality()}
    set {_locality = newValue}
  }
  /// Returns true if `locality` has been explicitly set.
  var hasLocality: Bool {return self._locality != nil}
  /// Clears the value of `locality`. Subsequent reads from it will return its default value.
  mutating func clearLocality() {self._locality = nil}

  /// Endpoint-picking policy.
  var childPolicy: [Grpc_ServiceConfig_LoadBalancingConfig] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The locality for which this policy will report load.  Required.
  struct Locality {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var region: String = String()

    var zone: String = String()

    var subzone: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _locality: Grpc_ServiceConfig_LrsLoadBalancingPolicyConfig.Locality? = nil
}

/// Configuration for the xds_wrr_locality load balancing policy.
struct Grpc_ServiceConfig_XdsWrrLocalityLoadBalancingPolicyConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var childPolicy: [Grpc_ServiceConfig_LoadBalancingConfig] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Configuration for the least_request LB policy.
struct Grpc_ServiceConfig_LeastRequestLocalityLoadBalancingPolicyConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var choiceCount: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Configuration for the override_host LB policy.
struct Grpc_ServiceConfig_OverrideHostLoadBalancingPolicyConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// valid health status for hosts that are considered when using
  /// xds_override_host_experimental policy.
  /// Default is [UNKNOWN, HEALTHY]
  var overrideHostStatus: [Grpc_ServiceConfig_OverrideHostLoadBalancingPolicyConfig.HealthStatus] = []

  var childPolicy: [Grpc_ServiceConfig_LoadBalancingConfig] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum HealthStatus: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unknown // = 0
    case healthy // = 1
    case draining // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .healthy
      case 3: self = .draining
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .healthy: return 1
      case .draining: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Grpc_ServiceConfig_OverrideHostLoadBalancingPolicyConfig.HealthStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Grpc_ServiceConfig_OverrideHostLoadBalancingPolicyConfig.HealthStatus] = [
    .unknown,
    .healthy,
    .draining,
  ]
}

#endif  // swift(>=4.2)

/// Configuration for xds LB policy.
struct Grpc_ServiceConfig_XdsConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name of balancer to connect to.
  var balancerName: String = String()

  /// Optional.  What LB policy to use for intra-locality routing.
  /// If unset, will use whatever algorithm is specified by the balancer.
  /// Multiple LB policies can be specified; clients will iterate through
  /// the list in order and stop at the first policy that they support.
  var childPolicy: [Grpc_ServiceConfig_LoadBalancingConfig] = []

  /// Optional.  What LB policy to use in fallback mode.  If not
  /// specified, defaults to round_robin.
  /// Multiple LB policies can be specified; clients will iterate through
  /// the list in order and stop at the first policy that they support.
  var fallbackPolicy: [Grpc_ServiceConfig_LoadBalancingConfig] = []

  /// Optional.  Name to use in EDS query.  If not present, defaults to
  /// the server name from the target URI.
  var edsServiceName: String = String()

  /// LRS server to send load reports to.
  /// If not present, load reporting will be disabled.
  /// If set to the empty string, load reporting will be sent to the same
  /// server that we obtained CDS data from.
  var lrsLoadReportingServerName: SwiftProtobuf.Google_Protobuf_StringValue {
    get {return _lrsLoadReportingServerName ?? SwiftProtobuf.Google_Protobuf_StringValue()}
    set {_lrsLoadReportingServerName = newValue}
  }
  /// Returns true if `lrsLoadReportingServerName` has been explicitly set.
  var hasLrsLoadReportingServerName: Bool {return self._lrsLoadReportingServerName != nil}
  /// Clears the value of `lrsLoadReportingServerName`. Subsequent reads from it will return its default value.
  mutating func clearLrsLoadReportingServerName() {self._lrsLoadReportingServerName = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _lrsLoadReportingServerName: SwiftProtobuf.Google_Protobuf_StringValue? = nil
}

/// Selects LB policy and provides corresponding configuration.
///
/// In general, all instances of this field should be repeated. Clients will
/// iterate through the list in order and stop at the first policy that they
/// support.  This allows the service config to specify custom policies that may
/// not be known to all clients.
///
/// - If the config for the first supported policy is invalid, the whole service
///   config is invalid.
/// - If the list doesn't contain any supported policy, the whole service config
///   is invalid.
struct Grpc_ServiceConfig_LoadBalancingConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Exactly one LB policy may be configured.
  var policy: Grpc_ServiceConfig_LoadBalancingConfig.OneOf_Policy? = nil

  var pickFirst: Grpc_ServiceConfig_PickFirstConfig {
    get {
      if case .pickFirst(let v)? = policy {return v}
      return Grpc_ServiceConfig_PickFirstConfig()
    }
    set {policy = .pickFirst(newValue)}
  }

  var roundRobin: Grpc_ServiceConfig_RoundRobinConfig {
    get {
      if case .roundRobin(let v)? = policy {return v}
      return Grpc_ServiceConfig_RoundRobinConfig()
    }
    set {policy = .roundRobin(newValue)}
  }

  var weightedRoundRobin: Grpc_ServiceConfig_WeightedRoundRobinLbConfig {
    get {
      if case .weightedRoundRobin(let v)? = policy {return v}
      return Grpc_ServiceConfig_WeightedRoundRobinLbConfig()
    }
    set {policy = .weightedRoundRobin(newValue)}
  }

  /// gRPC lookaside load balancing.
  /// This will eventually be deprecated by the new xDS-based local
  /// balancing policy.
  var grpclb: Grpc_ServiceConfig_GrpcLbConfig {
    get {
      if case .grpclb(let v)? = policy {return v}
      return Grpc_ServiceConfig_GrpcLbConfig()
    }
    set {policy = .grpclb(newValue)}
  }

  var priorityExperimental: Grpc_ServiceConfig_PriorityLoadBalancingPolicyConfig {
    get {
      if case .priorityExperimental(let v)? = policy {return v}
      return Grpc_ServiceConfig_PriorityLoadBalancingPolicyConfig()
    }
    set {policy = .priorityExperimental(newValue)}
  }

  var weightedTargetExperimental: Grpc_ServiceConfig_WeightedTargetLoadBalancingPolicyConfig {
    get {
      if case .weightedTargetExperimental(let v)? = policy {return v}
      return Grpc_ServiceConfig_WeightedTargetLoadBalancingPolicyConfig()
    }
    set {policy = .weightedTargetExperimental(newValue)}
  }

  var outlierDetection: Grpc_ServiceConfig_OutlierDetectionLoadBalancingConfig {
    get {
      if case .outlierDetection(let v)? = policy {return v}
      return Grpc_ServiceConfig_OutlierDetectionLoadBalancingConfig()
    }
    set {policy = .outlierDetection(newValue)}
  }

  var rls: Grpc_ServiceConfig_RlsLoadBalancingPolicyConfig {
    get {
      if case .rls(let v)? = policy {return v}
      return Grpc_ServiceConfig_RlsLoadBalancingPolicyConfig()
    }
    set {policy = .rls(newValue)}
  }

  /// xDS-based load balancing.
  var xdsClusterManagerExperimental: Grpc_ServiceConfig_XdsClusterManagerLoadBalancingPolicyConfig {
    get {
      if case .xdsClusterManagerExperimental(let v)? = policy {return v}
      return Grpc_ServiceConfig_XdsClusterManagerLoadBalancingPolicyConfig()
    }
    set {policy = .xdsClusterManagerExperimental(newValue)}
  }

  var cdsExperimental: Grpc_ServiceConfig_CdsConfig {
    get {
      if case .cdsExperimental(let v)? = policy {return v}
      return Grpc_ServiceConfig_CdsConfig()
    }
    set {policy = .cdsExperimental(newValue)}
  }

  var xdsClusterResolverExperimental: Grpc_ServiceConfig_XdsClusterResolverLoadBalancingPolicyConfig {
    get {
      if case .xdsClusterResolverExperimental(let v)? = policy {return v}
      return Grpc_ServiceConfig_XdsClusterResolverLoadBalancingPolicyConfig()
    }
    set {policy = .xdsClusterResolverExperimental(newValue)}
  }

  var xdsClusterImplExperimental: Grpc_ServiceConfig_XdsClusterImplLoadBalancingPolicyConfig {
    get {
      if case .xdsClusterImplExperimental(let v)? = policy {return v}
      return Grpc_ServiceConfig_XdsClusterImplLoadBalancingPolicyConfig()
    }
    set {policy = .xdsClusterImplExperimental(newValue)}
  }

  var overrideHostExperimental: Grpc_ServiceConfig_OverrideHostLoadBalancingPolicyConfig {
    get {
      if case .overrideHostExperimental(let v)? = policy {return v}
      return Grpc_ServiceConfig_OverrideHostLoadBalancingPolicyConfig()
    }
    set {policy = .overrideHostExperimental(newValue)}
  }

  var xdsWrrLocalityExperimental: Grpc_ServiceConfig_XdsWrrLocalityLoadBalancingPolicyConfig {
    get {
      if case .xdsWrrLocalityExperimental(let v)? = policy {return v}
      return Grpc_ServiceConfig_XdsWrrLocalityLoadBalancingPolicyConfig()
    }
    set {policy = .xdsWrrLocalityExperimental(newValue)}
  }

  var ringHashExperimental: Grpc_ServiceConfig_RingHashLoadBalancingConfig {
    get {
      if case .ringHashExperimental(let v)? = policy {return v}
      return Grpc_ServiceConfig_RingHashLoadBalancingConfig()
    }
    set {policy = .ringHashExperimental(newValue)}
  }

  var leastRequestExperimental: Grpc_ServiceConfig_LeastRequestLocalityLoadBalancingPolicyConfig {
    get {
      if case .leastRequestExperimental(let v)? = policy {return v}
      return Grpc_ServiceConfig_LeastRequestLocalityLoadBalancingPolicyConfig()
    }
    set {policy = .leastRequestExperimental(newValue)}
  }

  /// Deprecated xDS-related policies.
  var lrsExperimental: Grpc_ServiceConfig_LrsLoadBalancingPolicyConfig {
    get {
      if case .lrsExperimental(let v)? = policy {return v}
      return Grpc_ServiceConfig_LrsLoadBalancingPolicyConfig()
    }
    set {policy = .lrsExperimental(newValue)}
  }

  var edsExperimental: Grpc_ServiceConfig_EdsLoadBalancingPolicyConfig {
    get {
      if case .edsExperimental(let v)? = policy {return v}
      return Grpc_ServiceConfig_EdsLoadBalancingPolicyConfig()
    }
    set {policy = .edsExperimental(newValue)}
  }

  var xds: Grpc_ServiceConfig_XdsConfig {
    get {
      if case .xds(let v)? = policy {return v}
      return Grpc_ServiceConfig_XdsConfig()
    }
    set {policy = .xds(newValue)}
  }

  var xdsExperimental: Grpc_ServiceConfig_XdsConfig {
    get {
      if case .xdsExperimental(let v)? = policy {return v}
      return Grpc_ServiceConfig_XdsConfig()
    }
    set {policy = .xdsExperimental(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Exactly one LB policy may be configured.
  enum OneOf_Policy: Equatable {
    case pickFirst(Grpc_ServiceConfig_PickFirstConfig)
    case roundRobin(Grpc_ServiceConfig_RoundRobinConfig)
    case weightedRoundRobin(Grpc_ServiceConfig_WeightedRoundRobinLbConfig)
    /// gRPC lookaside load balancing.
    /// This will eventually be deprecated by the new xDS-based local
    /// balancing policy.
    case grpclb(Grpc_ServiceConfig_GrpcLbConfig)
    case priorityExperimental(Grpc_ServiceConfig_PriorityLoadBalancingPolicyConfig)
    case weightedTargetExperimental(Grpc_ServiceConfig_WeightedTargetLoadBalancingPolicyConfig)
    case outlierDetection(Grpc_ServiceConfig_OutlierDetectionLoadBalancingConfig)
    case rls(Grpc_ServiceConfig_RlsLoadBalancingPolicyConfig)
    /// xDS-based load balancing.
    case xdsClusterManagerExperimental(Grpc_ServiceConfig_XdsClusterManagerLoadBalancingPolicyConfig)
    case cdsExperimental(Grpc_ServiceConfig_CdsConfig)
    case xdsClusterResolverExperimental(Grpc_ServiceConfig_XdsClusterResolverLoadBalancingPolicyConfig)
    case xdsClusterImplExperimental(Grpc_ServiceConfig_XdsClusterImplLoadBalancingPolicyConfig)
    case overrideHostExperimental(Grpc_ServiceConfig_OverrideHostLoadBalancingPolicyConfig)
    case xdsWrrLocalityExperimental(Grpc_ServiceConfig_XdsWrrLocalityLoadBalancingPolicyConfig)
    case ringHashExperimental(Grpc_ServiceConfig_RingHashLoadBalancingConfig)
    case leastRequestExperimental(Grpc_ServiceConfig_LeastRequestLocalityLoadBalancingPolicyConfig)
    /// Deprecated xDS-related policies.
    case lrsExperimental(Grpc_ServiceConfig_LrsLoadBalancingPolicyConfig)
    case edsExperimental(Grpc_ServiceConfig_EdsLoadBalancingPolicyConfig)
    case xds(Grpc_ServiceConfig_XdsConfig)
    case xdsExperimental(Grpc_ServiceConfig_XdsConfig)

  #if !swift(>=4.1)
    static func ==(lhs: Grpc_ServiceConfig_LoadBalancingConfig.OneOf_Policy, rhs: Grpc_ServiceConfig_LoadBalancingConfig.OneOf_Policy) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.pickFirst, .pickFirst): return {
        guard case .pickFirst(let l) = lhs, case .pickFirst(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.roundRobin, .roundRobin): return {
        guard case .roundRobin(let l) = lhs, case .roundRobin(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.weightedRoundRobin, .weightedRoundRobin): return {
        guard case .weightedRoundRobin(let l) = lhs, case .weightedRoundRobin(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.grpclb, .grpclb): return {
        guard case .grpclb(let l) = lhs, case .grpclb(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.priorityExperimental, .priorityExperimental): return {
        guard case .priorityExperimental(let l) = lhs, case .priorityExperimental(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.weightedTargetExperimental, .weightedTargetExperimental): return {
        guard case .weightedTargetExperimental(let l) = lhs, case .weightedTargetExperimental(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.outlierDetection, .outlierDetection): return {
        guard case .outlierDetection(let l) = lhs, case .outlierDetection(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.rls, .rls): return {
        guard case .rls(let l) = lhs, case .rls(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.xdsClusterManagerExperimental, .xdsClusterManagerExperimental): return {
        guard case .xdsClusterManagerExperimental(let l) = lhs, case .xdsClusterManagerExperimental(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.cdsExperimental, .cdsExperimental): return {
        guard case .cdsExperimental(let l) = lhs, case .cdsExperimental(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.xdsClusterResolverExperimental, .xdsClusterResolverExperimental): return {
        guard case .xdsClusterResolverExperimental(let l) = lhs, case .xdsClusterResolverExperimental(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.xdsClusterImplExperimental, .xdsClusterImplExperimental): return {
        guard case .xdsClusterImplExperimental(let l) = lhs, case .xdsClusterImplExperimental(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.overrideHostExperimental, .overrideHostExperimental): return {
        guard case .overrideHostExperimental(let l) = lhs, case .overrideHostExperimental(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.xdsWrrLocalityExperimental, .xdsWrrLocalityExperimental): return {
        guard case .xdsWrrLocalityExperimental(let l) = lhs, case .xdsWrrLocalityExperimental(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ringHashExperimental, .ringHashExperimental): return {
        guard case .ringHashExperimental(let l) = lhs, case .ringHashExperimental(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.leastRequestExperimental, .leastRequestExperimental): return {
        guard case .leastRequestExperimental(let l) = lhs, case .leastRequestExperimental(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.lrsExperimental, .lrsExperimental): return {
        guard case .lrsExperimental(let l) = lhs, case .lrsExperimental(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.edsExperimental, .edsExperimental): return {
        guard case .edsExperimental(let l) = lhs, case .edsExperimental(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.xds, .xds): return {
        guard case .xds(let l) = lhs, case .xds(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.xdsExperimental, .xdsExperimental): return {
        guard case .xdsExperimental(let l) = lhs, case .xdsExperimental(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

/// A ServiceConfig represents information about a service but is not specific to
/// any name resolver.
struct Grpc_ServiceConfig_ServiceConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var loadBalancingPolicy: Grpc_ServiceConfig_ServiceConfig.LoadBalancingPolicy = .unspecified

  /// Multiple LB policies can be specified; clients will iterate through
  /// the list in order and stop at the first policy that they support. If none
  /// are supported, the service config is considered invalid.
  var loadBalancingConfig: [Grpc_ServiceConfig_LoadBalancingConfig] = []

  /// Per-method configuration.
  var methodConfig: [Grpc_ServiceConfig_MethodConfig] = []

  var retryThrottling: Grpc_ServiceConfig_ServiceConfig.RetryThrottlingPolicy {
    get {return _retryThrottling ?? Grpc_ServiceConfig_ServiceConfig.RetryThrottlingPolicy()}
    set {_retryThrottling = newValue}
  }
  /// Returns true if `retryThrottling` has been explicitly set.
  var hasRetryThrottling: Bool {return self._retryThrottling != nil}
  /// Clears the value of `retryThrottling`. Subsequent reads from it will return its default value.
  mutating func clearRetryThrottling() {self._retryThrottling = nil}

  var healthCheckConfig: Grpc_ServiceConfig_ServiceConfig.HealthCheckConfig {
    get {return _healthCheckConfig ?? Grpc_ServiceConfig_ServiceConfig.HealthCheckConfig()}
    set {_healthCheckConfig = newValue}
  }
  /// Returns true if `healthCheckConfig` has been explicitly set.
  var hasHealthCheckConfig: Bool {return self._healthCheckConfig != nil}
  /// Clears the value of `healthCheckConfig`. Subsequent reads from it will return its default value.
  mutating func clearHealthCheckConfig() {self._healthCheckConfig = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Load balancing policy.
  ///
  /// Note that load_balancing_policy is deprecated in favor of
  /// load_balancing_config; the former will be used only if the latter
  /// is unset.
  ///
  /// If no LB policy is configured here, then the default is pick_first.
  /// If the policy name is set via the client API, that value overrides
  /// the value specified here.
  ///
  /// If the deprecated load_balancing_policy field is used, note that if the
  /// resolver returns at least one balancer address (as opposed to backend
  /// addresses), gRPC will use grpclb (see
  /// https://github.com/grpc/grpc/blob/master/doc/load-balancing.md),
  /// regardless of what policy is configured here.  However, if the resolver
  /// returns at least one backend address in addition to the balancer
  /// address(es), the client may fall back to the requested policy if it
  /// is unable to reach any of the grpclb load balancers.
  enum LoadBalancingPolicy: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unspecified // = 0
    case roundRobin // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .roundRobin
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .roundRobin: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// If a RetryThrottlingPolicy is provided, gRPC will automatically throttle
  /// retry attempts and hedged RPCs when the client's ratio of failures to
  /// successes exceeds a threshold.
  ///
  /// For each server name, the gRPC client will maintain a token_count which is
  /// initially set to max_tokens. Every outgoing RPC (regardless of service or
  /// method invoked) will change token_count as follows:
  ///
  ///   - Every failed RPC will decrement the token_count by 1.
  ///   - Every successful RPC will increment the token_count by token_ratio.
  ///
  /// If token_count is less than or equal to max_tokens / 2, then RPCs will not
  /// be retried and hedged RPCs will not be sent.
  struct RetryThrottlingPolicy {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The number of tokens starts at max_tokens. The token_count will always be
    /// between 0 and max_tokens.
    ///
    /// This field is required and must be greater than zero.
    var maxTokens: UInt32 = 0

    /// The amount of tokens to add on each successful RPC. Typically this will
    /// be some number between 0 and 1, e.g., 0.1.
    ///
    /// This field is required and must be greater than zero. Up to 3 decimal
    /// places are supported.
    var tokenRatio: Float = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct HealthCheckConfig {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Service name to use in the health-checking request.
    var serviceName: SwiftProtobuf.Google_Protobuf_StringValue {
      get {return _serviceName ?? SwiftProtobuf.Google_Protobuf_StringValue()}
      set {_serviceName = newValue}
    }
    /// Returns true if `serviceName` has been explicitly set.
    var hasServiceName: Bool {return self._serviceName != nil}
    /// Clears the value of `serviceName`. Subsequent reads from it will return its default value.
    mutating func clearServiceName() {self._serviceName = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _serviceName: SwiftProtobuf.Google_Protobuf_StringValue? = nil
  }

  init() {}

  fileprivate var _retryThrottling: Grpc_ServiceConfig_ServiceConfig.RetryThrottlingPolicy? = nil
  fileprivate var _healthCheckConfig: Grpc_ServiceConfig_ServiceConfig.HealthCheckConfig? = nil
}

#if swift(>=4.2)

extension Grpc_ServiceConfig_ServiceConfig.LoadBalancingPolicy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Grpc_ServiceConfig_ServiceConfig.LoadBalancingPolicy] = [
    .unspecified,
    .roundRobin,
  ]
}

#endif  // swift(>=4.2)

#if swift(>=5.5) && canImport(_Concurrency)
extension Grpc_ServiceConfig_MethodConfig: @unchecked Sendable {}
extension Grpc_ServiceConfig_MethodConfig.OneOf_RetryOrHedgingPolicy: @unchecked Sendable {}
extension Grpc_ServiceConfig_MethodConfig.Name: @unchecked Sendable {}
extension Grpc_ServiceConfig_MethodConfig.RetryPolicy: @unchecked Sendable {}
extension Grpc_ServiceConfig_MethodConfig.HedgingPolicy: @unchecked Sendable {}
extension Grpc_ServiceConfig_PickFirstConfig: @unchecked Sendable {}
extension Grpc_ServiceConfig_RoundRobinConfig: @unchecked Sendable {}
extension Grpc_ServiceConfig_WeightedRoundRobinLbConfig: @unchecked Sendable {}
extension Grpc_ServiceConfig_OutlierDetectionLoadBalancingConfig: @unchecked Sendable {}
extension Grpc_ServiceConfig_OutlierDetectionLoadBalancingConfig.SuccessRateEjection: @unchecked Sendable {}
extension Grpc_ServiceConfig_OutlierDetectionLoadBalancingConfig.FailurePercentageEjection: @unchecked Sendable {}
extension Grpc_ServiceConfig_GrpcLbConfig: @unchecked Sendable {}
extension Grpc_ServiceConfig_PriorityLoadBalancingPolicyConfig: @unchecked Sendable {}
extension Grpc_ServiceConfig_PriorityLoadBalancingPolicyConfig.Child: @unchecked Sendable {}
extension Grpc_ServiceConfig_WeightedTargetLoadBalancingPolicyConfig: @unchecked Sendable {}
extension Grpc_ServiceConfig_WeightedTargetLoadBalancingPolicyConfig.Target: @unchecked Sendable {}
extension Grpc_ServiceConfig_RlsLoadBalancingPolicyConfig: @unchecked Sendable {}
extension Grpc_ServiceConfig_XdsClusterManagerLoadBalancingPolicyConfig: @unchecked Sendable {}
extension Grpc_ServiceConfig_XdsClusterManagerLoadBalancingPolicyConfig.Child: @unchecked Sendable {}
extension Grpc_ServiceConfig_CdsConfig: @unchecked Sendable {}
extension Grpc_ServiceConfig_XdsServer: @unchecked Sendable {}
extension Grpc_ServiceConfig_XdsServer.ChannelCredentials: @unchecked Sendable {}
extension Grpc_ServiceConfig_XdsClusterResolverLoadBalancingPolicyConfig: @unchecked Sendable {}
extension Grpc_ServiceConfig_XdsClusterResolverLoadBalancingPolicyConfig.DiscoveryMechanism: @unchecked Sendable {}
extension Grpc_ServiceConfig_XdsClusterResolverLoadBalancingPolicyConfig.DiscoveryMechanism.TypeEnum: @unchecked Sendable {}
extension Grpc_ServiceConfig_XdsClusterImplLoadBalancingPolicyConfig: @unchecked Sendable {}
extension Grpc_ServiceConfig_XdsClusterImplLoadBalancingPolicyConfig.DropCategory: @unchecked Sendable {}
extension Grpc_ServiceConfig_EdsLoadBalancingPolicyConfig: @unchecked Sendable {}
extension Grpc_ServiceConfig_RingHashLoadBalancingConfig: @unchecked Sendable {}
extension Grpc_ServiceConfig_LrsLoadBalancingPolicyConfig: @unchecked Sendable {}
extension Grpc_ServiceConfig_LrsLoadBalancingPolicyConfig.Locality: @unchecked Sendable {}
extension Grpc_ServiceConfig_XdsWrrLocalityLoadBalancingPolicyConfig: @unchecked Sendable {}
extension Grpc_ServiceConfig_LeastRequestLocalityLoadBalancingPolicyConfig: @unchecked Sendable {}
extension Grpc_ServiceConfig_OverrideHostLoadBalancingPolicyConfig: @unchecked Sendable {}
extension Grpc_ServiceConfig_OverrideHostLoadBalancingPolicyConfig.HealthStatus: @unchecked Sendable {}
extension Grpc_ServiceConfig_XdsConfig: @unchecked Sendable {}
extension Grpc_ServiceConfig_LoadBalancingConfig: @unchecked Sendable {}
extension Grpc_ServiceConfig_LoadBalancingConfig.OneOf_Policy: @unchecked Sendable {}
extension Grpc_ServiceConfig_ServiceConfig: @unchecked Sendable {}
extension Grpc_ServiceConfig_ServiceConfig.LoadBalancingPolicy: @unchecked Sendable {}
extension Grpc_ServiceConfig_ServiceConfig.RetryThrottlingPolicy: @unchecked Sendable {}
extension Grpc_ServiceConfig_ServiceConfig.HealthCheckConfig: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "grpc.service_config"

extension Grpc_ServiceConfig_MethodConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MethodConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "wait_for_ready"),
    3: .same(proto: "timeout"),
    4: .standard(proto: "max_request_message_bytes"),
    5: .standard(proto: "max_response_message_bytes"),
    6: .standard(proto: "retry_policy"),
    7: .standard(proto: "hedging_policy"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._waitForReady) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._timeout) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._maxRequestMessageBytes) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._maxResponseMessageBytes) }()
      case 6: try {
        var v: Grpc_ServiceConfig_MethodConfig.RetryPolicy?
        var hadOneofValue = false
        if let current = self.retryOrHedgingPolicy {
          hadOneofValue = true
          if case .retryPolicy(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.retryOrHedgingPolicy = .retryPolicy(v)
        }
      }()
      case 7: try {
        var v: Grpc_ServiceConfig_MethodConfig.HedgingPolicy?
        var hadOneofValue = false
        if let current = self.retryOrHedgingPolicy {
          hadOneofValue = true
          if case .hedgingPolicy(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.retryOrHedgingPolicy = .hedgingPolicy(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.name, fieldNumber: 1)
    }
    try { if let v = self._waitForReady {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._timeout {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._maxRequestMessageBytes {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._maxResponseMessageBytes {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    switch self.retryOrHedgingPolicy {
    case .retryPolicy?: try {
      guard case .retryPolicy(let v)? = self.retryOrHedgingPolicy else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .hedgingPolicy?: try {
      guard case .hedgingPolicy(let v)? = self.retryOrHedgingPolicy else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_ServiceConfig_MethodConfig, rhs: Grpc_ServiceConfig_MethodConfig) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._waitForReady != rhs._waitForReady {return false}
    if lhs._timeout != rhs._timeout {return false}
    if lhs._maxRequestMessageBytes != rhs._maxRequestMessageBytes {return false}
    if lhs._maxResponseMessageBytes != rhs._maxResponseMessageBytes {return false}
    if lhs.retryOrHedgingPolicy != rhs.retryOrHedgingPolicy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_ServiceConfig_MethodConfig.Name: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Grpc_ServiceConfig_MethodConfig.protoMessageName + ".Name"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "service"),
    2: .same(proto: "method"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.service) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.method) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.service.isEmpty {
      try visitor.visitSingularStringField(value: self.service, fieldNumber: 1)
    }
    if !self.method.isEmpty {
      try visitor.visitSingularStringField(value: self.method, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_ServiceConfig_MethodConfig.Name, rhs: Grpc_ServiceConfig_MethodConfig.Name) -> Bool {
    if lhs.service != rhs.service {return false}
    if lhs.method != rhs.method {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_ServiceConfig_MethodConfig.RetryPolicy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Grpc_ServiceConfig_MethodConfig.protoMessageName + ".RetryPolicy"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "max_attempts"),
    2: .standard(proto: "initial_backoff"),
    3: .standard(proto: "max_backoff"),
    4: .standard(proto: "backoff_multiplier"),
    5: .standard(proto: "retryable_status_codes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.maxAttempts) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._initialBackoff) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._maxBackoff) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.backoffMultiplier) }()
      case 5: try { try decoder.decodeRepeatedEnumField(value: &self.retryableStatusCodes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.maxAttempts != 0 {
      try visitor.visitSingularUInt32Field(value: self.maxAttempts, fieldNumber: 1)
    }
    try { if let v = self._initialBackoff {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._maxBackoff {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.backoffMultiplier != 0 {
      try visitor.visitSingularFloatField(value: self.backoffMultiplier, fieldNumber: 4)
    }
    if !self.retryableStatusCodes.isEmpty {
      try visitor.visitPackedEnumField(value: self.retryableStatusCodes, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_ServiceConfig_MethodConfig.RetryPolicy, rhs: Grpc_ServiceConfig_MethodConfig.RetryPolicy) -> Bool {
    if lhs.maxAttempts != rhs.maxAttempts {return false}
    if lhs._initialBackoff != rhs._initialBackoff {return false}
    if lhs._maxBackoff != rhs._maxBackoff {return false}
    if lhs.backoffMultiplier != rhs.backoffMultiplier {return false}
    if lhs.retryableStatusCodes != rhs.retryableStatusCodes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_ServiceConfig_MethodConfig.HedgingPolicy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Grpc_ServiceConfig_MethodConfig.protoMessageName + ".HedgingPolicy"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "max_attempts"),
    2: .standard(proto: "hedging_delay"),
    3: .standard(proto: "non_fatal_status_codes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.maxAttempts) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._hedgingDelay) }()
      case 3: try { try decoder.decodeRepeatedEnumField(value: &self.nonFatalStatusCodes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.maxAttempts != 0 {
      try visitor.visitSingularUInt32Field(value: self.maxAttempts, fieldNumber: 1)
    }
    try { if let v = self._hedgingDelay {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.nonFatalStatusCodes.isEmpty {
      try visitor.visitPackedEnumField(value: self.nonFatalStatusCodes, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_ServiceConfig_MethodConfig.HedgingPolicy, rhs: Grpc_ServiceConfig_MethodConfig.HedgingPolicy) -> Bool {
    if lhs.maxAttempts != rhs.maxAttempts {return false}
    if lhs._hedgingDelay != rhs._hedgingDelay {return false}
    if lhs.nonFatalStatusCodes != rhs.nonFatalStatusCodes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_ServiceConfig_PickFirstConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PickFirstConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "shuffle_address_list"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.shuffleAddressList) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.shuffleAddressList != false {
      try visitor.visitSingularBoolField(value: self.shuffleAddressList, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_ServiceConfig_PickFirstConfig, rhs: Grpc_ServiceConfig_PickFirstConfig) -> Bool {
    if lhs.shuffleAddressList != rhs.shuffleAddressList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_ServiceConfig_RoundRobinConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RoundRobinConfig"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_ServiceConfig_RoundRobinConfig, rhs: Grpc_ServiceConfig_RoundRobinConfig) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_ServiceConfig_WeightedRoundRobinLbConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WeightedRoundRobinLbConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "enable_oob_load_report"),
    2: .standard(proto: "oob_reporting_period"),
    3: .standard(proto: "blackout_period"),
    4: .standard(proto: "weight_expiration_period"),
    5: .standard(proto: "weight_update_period"),
    6: .standard(proto: "error_utilization_penalty"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._enableOobLoadReport) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._oobReportingPeriod) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._blackoutPeriod) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._weightExpirationPeriod) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._weightUpdatePeriod) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._errorUtilizationPenalty) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._enableOobLoadReport {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._oobReportingPeriod {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._blackoutPeriod {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._weightExpirationPeriod {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._weightUpdatePeriod {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._errorUtilizationPenalty {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_ServiceConfig_WeightedRoundRobinLbConfig, rhs: Grpc_ServiceConfig_WeightedRoundRobinLbConfig) -> Bool {
    if lhs._enableOobLoadReport != rhs._enableOobLoadReport {return false}
    if lhs._oobReportingPeriod != rhs._oobReportingPeriod {return false}
    if lhs._blackoutPeriod != rhs._blackoutPeriod {return false}
    if lhs._weightExpirationPeriod != rhs._weightExpirationPeriod {return false}
    if lhs._weightUpdatePeriod != rhs._weightUpdatePeriod {return false}
    if lhs._errorUtilizationPenalty != rhs._errorUtilizationPenalty {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_ServiceConfig_OutlierDetectionLoadBalancingConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OutlierDetectionLoadBalancingConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "interval"),
    2: .standard(proto: "base_ejection_time"),
    3: .standard(proto: "max_ejection_time"),
    4: .standard(proto: "max_ejection_percent"),
    5: .standard(proto: "success_rate_ejection"),
    6: .standard(proto: "failure_percentage_ejection"),
    13: .standard(proto: "child_policy"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._interval) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._baseEjectionTime) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._maxEjectionTime) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._maxEjectionPercent) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._successRateEjection) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._failurePercentageEjection) }()
      case 13: try { try decoder.decodeRepeatedMessageField(value: &self.childPolicy) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._interval {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._baseEjectionTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._maxEjectionTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._maxEjectionPercent {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._successRateEjection {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._failurePercentageEjection {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if !self.childPolicy.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.childPolicy, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_ServiceConfig_OutlierDetectionLoadBalancingConfig, rhs: Grpc_ServiceConfig_OutlierDetectionLoadBalancingConfig) -> Bool {
    if lhs._interval != rhs._interval {return false}
    if lhs._baseEjectionTime != rhs._baseEjectionTime {return false}
    if lhs._maxEjectionTime != rhs._maxEjectionTime {return false}
    if lhs._maxEjectionPercent != rhs._maxEjectionPercent {return false}
    if lhs._successRateEjection != rhs._successRateEjection {return false}
    if lhs._failurePercentageEjection != rhs._failurePercentageEjection {return false}
    if lhs.childPolicy != rhs.childPolicy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_ServiceConfig_OutlierDetectionLoadBalancingConfig.SuccessRateEjection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Grpc_ServiceConfig_OutlierDetectionLoadBalancingConfig.protoMessageName + ".SuccessRateEjection"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "stdev_factor"),
    2: .standard(proto: "enforcement_percentage"),
    3: .standard(proto: "minimum_hosts"),
    4: .standard(proto: "request_volume"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._stdevFactor) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._enforcementPercentage) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._minimumHosts) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._requestVolume) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._stdevFactor {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._enforcementPercentage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._minimumHosts {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._requestVolume {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_ServiceConfig_OutlierDetectionLoadBalancingConfig.SuccessRateEjection, rhs: Grpc_ServiceConfig_OutlierDetectionLoadBalancingConfig.SuccessRateEjection) -> Bool {
    if lhs._stdevFactor != rhs._stdevFactor {return false}
    if lhs._enforcementPercentage != rhs._enforcementPercentage {return false}
    if lhs._minimumHosts != rhs._minimumHosts {return false}
    if lhs._requestVolume != rhs._requestVolume {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_ServiceConfig_OutlierDetectionLoadBalancingConfig.FailurePercentageEjection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Grpc_ServiceConfig_OutlierDetectionLoadBalancingConfig.protoMessageName + ".FailurePercentageEjection"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "threshold"),
    2: .standard(proto: "enforcement_percentage"),
    3: .standard(proto: "minimum_hosts"),
    4: .standard(proto: "request_volume"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._threshold) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._enforcementPercentage) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._minimumHosts) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._requestVolume) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._threshold {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._enforcementPercentage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._minimumHosts {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._requestVolume {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_ServiceConfig_OutlierDetectionLoadBalancingConfig.FailurePercentageEjection, rhs: Grpc_ServiceConfig_OutlierDetectionLoadBalancingConfig.FailurePercentageEjection) -> Bool {
    if lhs._threshold != rhs._threshold {return false}
    if lhs._enforcementPercentage != rhs._enforcementPercentage {return false}
    if lhs._minimumHosts != rhs._minimumHosts {return false}
    if lhs._requestVolume != rhs._requestVolume {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_ServiceConfig_GrpcLbConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GrpcLbConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "child_policy"),
    2: .standard(proto: "service_name"),
    3: .standard(proto: "initial_fallback_timeout"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.childPolicy) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.serviceName) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._initialFallbackTimeout) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.childPolicy.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.childPolicy, fieldNumber: 1)
    }
    if !self.serviceName.isEmpty {
      try visitor.visitSingularStringField(value: self.serviceName, fieldNumber: 2)
    }
    try { if let v = self._initialFallbackTimeout {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_ServiceConfig_GrpcLbConfig, rhs: Grpc_ServiceConfig_GrpcLbConfig) -> Bool {
    if lhs.childPolicy != rhs.childPolicy {return false}
    if lhs.serviceName != rhs.serviceName {return false}
    if lhs._initialFallbackTimeout != rhs._initialFallbackTimeout {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_ServiceConfig_PriorityLoadBalancingPolicyConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PriorityLoadBalancingPolicyConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "children"),
    2: .same(proto: "priorities"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Grpc_ServiceConfig_PriorityLoadBalancingPolicyConfig.Child>.self, value: &self.children) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.priorities) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.children.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Grpc_ServiceConfig_PriorityLoadBalancingPolicyConfig.Child>.self, value: self.children, fieldNumber: 1)
    }
    if !self.priorities.isEmpty {
      try visitor.visitRepeatedStringField(value: self.priorities, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_ServiceConfig_PriorityLoadBalancingPolicyConfig, rhs: Grpc_ServiceConfig_PriorityLoadBalancingPolicyConfig) -> Bool {
    if lhs.children != rhs.children {return false}
    if lhs.priorities != rhs.priorities {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_ServiceConfig_PriorityLoadBalancingPolicyConfig.Child: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Grpc_ServiceConfig_PriorityLoadBalancingPolicyConfig.protoMessageName + ".Child"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "config"),
    2: .standard(proto: "ignore_reresolution_requests"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.config) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.ignoreReresolutionRequests) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.config.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.config, fieldNumber: 1)
    }
    if self.ignoreReresolutionRequests != false {
      try visitor.visitSingularBoolField(value: self.ignoreReresolutionRequests, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_ServiceConfig_PriorityLoadBalancingPolicyConfig.Child, rhs: Grpc_ServiceConfig_PriorityLoadBalancingPolicyConfig.Child) -> Bool {
    if lhs.config != rhs.config {return false}
    if lhs.ignoreReresolutionRequests != rhs.ignoreReresolutionRequests {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_ServiceConfig_WeightedTargetLoadBalancingPolicyConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WeightedTargetLoadBalancingPolicyConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "targets"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Grpc_ServiceConfig_WeightedTargetLoadBalancingPolicyConfig.Target>.self, value: &self.targets) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.targets.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Grpc_ServiceConfig_WeightedTargetLoadBalancingPolicyConfig.Target>.self, value: self.targets, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_ServiceConfig_WeightedTargetLoadBalancingPolicyConfig, rhs: Grpc_ServiceConfig_WeightedTargetLoadBalancingPolicyConfig) -> Bool {
    if lhs.targets != rhs.targets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_ServiceConfig_WeightedTargetLoadBalancingPolicyConfig.Target: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Grpc_ServiceConfig_WeightedTargetLoadBalancingPolicyConfig.protoMessageName + ".Target"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "weight"),
    2: .standard(proto: "child_policy"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.weight) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.childPolicy) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.weight != 0 {
      try visitor.visitSingularUInt32Field(value: self.weight, fieldNumber: 1)
    }
    if !self.childPolicy.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.childPolicy, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_ServiceConfig_WeightedTargetLoadBalancingPolicyConfig.Target, rhs: Grpc_ServiceConfig_WeightedTargetLoadBalancingPolicyConfig.Target) -> Bool {
    if lhs.weight != rhs.weight {return false}
    if lhs.childPolicy != rhs.childPolicy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_ServiceConfig_RlsLoadBalancingPolicyConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RlsLoadBalancingPolicyConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "route_lookup_config"),
    2: .standard(proto: "route_lookup_channel_service_config"),
    3: .standard(proto: "child_policy"),
    4: .standard(proto: "child_policy_config_target_field_name"),
  ]

  fileprivate class _StorageClass {
    var _routeLookupConfig: Grpc_Lookup_V1_RouteLookupConfig? = nil
    var _routeLookupChannelServiceConfig: Grpc_ServiceConfig_ServiceConfig? = nil
    var _childPolicy: [Grpc_ServiceConfig_LoadBalancingConfig] = []
    var _childPolicyConfigTargetFieldName: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _routeLookupConfig = source._routeLookupConfig
      _routeLookupChannelServiceConfig = source._routeLookupChannelServiceConfig
      _childPolicy = source._childPolicy
      _childPolicyConfigTargetFieldName = source._childPolicyConfigTargetFieldName
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._routeLookupConfig) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._routeLookupChannelServiceConfig) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._childPolicy) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._childPolicyConfigTargetFieldName) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._routeLookupConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._routeLookupChannelServiceConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._childPolicy.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._childPolicy, fieldNumber: 3)
      }
      if !_storage._childPolicyConfigTargetFieldName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._childPolicyConfigTargetFieldName, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_ServiceConfig_RlsLoadBalancingPolicyConfig, rhs: Grpc_ServiceConfig_RlsLoadBalancingPolicyConfig) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._routeLookupConfig != rhs_storage._routeLookupConfig {return false}
        if _storage._routeLookupChannelServiceConfig != rhs_storage._routeLookupChannelServiceConfig {return false}
        if _storage._childPolicy != rhs_storage._childPolicy {return false}
        if _storage._childPolicyConfigTargetFieldName != rhs_storage._childPolicyConfigTargetFieldName {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_ServiceConfig_XdsClusterManagerLoadBalancingPolicyConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".XdsClusterManagerLoadBalancingPolicyConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "children"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Grpc_ServiceConfig_XdsClusterManagerLoadBalancingPolicyConfig.Child>.self, value: &self.children) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.children.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Grpc_ServiceConfig_XdsClusterManagerLoadBalancingPolicyConfig.Child>.self, value: self.children, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_ServiceConfig_XdsClusterManagerLoadBalancingPolicyConfig, rhs: Grpc_ServiceConfig_XdsClusterManagerLoadBalancingPolicyConfig) -> Bool {
    if lhs.children != rhs.children {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_ServiceConfig_XdsClusterManagerLoadBalancingPolicyConfig.Child: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Grpc_ServiceConfig_XdsClusterManagerLoadBalancingPolicyConfig.protoMessageName + ".Child"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "child_policy"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.childPolicy) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.childPolicy.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.childPolicy, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_ServiceConfig_XdsClusterManagerLoadBalancingPolicyConfig.Child, rhs: Grpc_ServiceConfig_XdsClusterManagerLoadBalancingPolicyConfig.Child) -> Bool {
    if lhs.childPolicy != rhs.childPolicy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_ServiceConfig_CdsConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CdsConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cluster"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.cluster) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cluster.isEmpty {
      try visitor.visitSingularStringField(value: self.cluster, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_ServiceConfig_CdsConfig, rhs: Grpc_ServiceConfig_CdsConfig) -> Bool {
    if lhs.cluster != rhs.cluster {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_ServiceConfig_XdsServer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".XdsServer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "server_uri"),
    2: .same(proto: "channel_creds"),
    3: .same(proto: "server_features"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.serverUri) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.channelCreds) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.serverFeatures) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.serverUri.isEmpty {
      try visitor.visitSingularStringField(value: self.serverUri, fieldNumber: 1)
    }
    if !self.channelCreds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.channelCreds, fieldNumber: 2)
    }
    if !self.serverFeatures.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.serverFeatures, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_ServiceConfig_XdsServer, rhs: Grpc_ServiceConfig_XdsServer) -> Bool {
    if lhs.serverUri != rhs.serverUri {return false}
    if lhs.channelCreds != rhs.channelCreds {return false}
    if lhs.serverFeatures != rhs.serverFeatures {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_ServiceConfig_XdsServer.ChannelCredentials: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Grpc_ServiceConfig_XdsServer.protoMessageName + ".ChannelCredentials"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "config"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._config) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    try { if let v = self._config {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_ServiceConfig_XdsServer.ChannelCredentials, rhs: Grpc_ServiceConfig_XdsServer.ChannelCredentials) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs._config != rhs._config {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_ServiceConfig_XdsClusterResolverLoadBalancingPolicyConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".XdsClusterResolverLoadBalancingPolicyConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "discovery_mechanisms"),
    2: .standard(proto: "xds_lb_policy"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.discoveryMechanisms) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.xdsLbPolicy) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.discoveryMechanisms.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.discoveryMechanisms, fieldNumber: 1)
    }
    if !self.xdsLbPolicy.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.xdsLbPolicy, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_ServiceConfig_XdsClusterResolverLoadBalancingPolicyConfig, rhs: Grpc_ServiceConfig_XdsClusterResolverLoadBalancingPolicyConfig) -> Bool {
    if lhs.discoveryMechanisms != rhs.discoveryMechanisms {return false}
    if lhs.xdsLbPolicy != rhs.xdsLbPolicy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_ServiceConfig_XdsClusterResolverLoadBalancingPolicyConfig.DiscoveryMechanism: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Grpc_ServiceConfig_XdsClusterResolverLoadBalancingPolicyConfig.protoMessageName + ".DiscoveryMechanism"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cluster"),
    2: .standard(proto: "lrs_load_reporting_server_name"),
    7: .standard(proto: "lrs_load_reporting_server"),
    3: .standard(proto: "max_concurrent_requests"),
    4: .same(proto: "type"),
    5: .standard(proto: "eds_service_name"),
    6: .standard(proto: "dns_hostname"),
    8: .standard(proto: "outlier_detection"),
    9: .standard(proto: "override_host_status"),
    10: .standard(proto: "telemetry_labels"),
  ]

  fileprivate class _StorageClass {
    var _cluster: String = String()
    var _lrsLoadReportingServerName: SwiftProtobuf.Google_Protobuf_StringValue? = nil
    var _lrsLoadReportingServer: Grpc_ServiceConfig_XdsServer? = nil
    var _maxConcurrentRequests: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
    var _type: Grpc_ServiceConfig_XdsClusterResolverLoadBalancingPolicyConfig.DiscoveryMechanism.TypeEnum = .unknown
    var _edsServiceName: String = String()
    var _dnsHostname: String = String()
    var _outlierDetection: Grpc_ServiceConfig_OutlierDetectionLoadBalancingConfig? = nil
    var _overrideHostStatus: [Grpc_ServiceConfig_OverrideHostLoadBalancingPolicyConfig.HealthStatus] = []
    var _telemetryLabels: Dictionary<String,String> = [:]

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _cluster = source._cluster
      _lrsLoadReportingServerName = source._lrsLoadReportingServerName
      _lrsLoadReportingServer = source._lrsLoadReportingServer
      _maxConcurrentRequests = source._maxConcurrentRequests
      _type = source._type
      _edsServiceName = source._edsServiceName
      _dnsHostname = source._dnsHostname
      _outlierDetection = source._outlierDetection
      _overrideHostStatus = source._overrideHostStatus
      _telemetryLabels = source._telemetryLabels
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._cluster) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._lrsLoadReportingServerName) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._maxConcurrentRequests) }()
        case 4: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._edsServiceName) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._dnsHostname) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._lrsLoadReportingServer) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._outlierDetection) }()
        case 9: try { try decoder.decodeRepeatedEnumField(value: &_storage._overrideHostStatus) }()
        case 10: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._telemetryLabels) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._cluster.isEmpty {
        try visitor.visitSingularStringField(value: _storage._cluster, fieldNumber: 1)
      }
      try { if let v = _storage._lrsLoadReportingServerName {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._maxConcurrentRequests {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if _storage._type != .unknown {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 4)
      }
      if !_storage._edsServiceName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._edsServiceName, fieldNumber: 5)
      }
      if !_storage._dnsHostname.isEmpty {
        try visitor.visitSingularStringField(value: _storage._dnsHostname, fieldNumber: 6)
      }
      try { if let v = _storage._lrsLoadReportingServer {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._outlierDetection {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if !_storage._overrideHostStatus.isEmpty {
        try visitor.visitPackedEnumField(value: _storage._overrideHostStatus, fieldNumber: 9)
      }
      if !_storage._telemetryLabels.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._telemetryLabels, fieldNumber: 10)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_ServiceConfig_XdsClusterResolverLoadBalancingPolicyConfig.DiscoveryMechanism, rhs: Grpc_ServiceConfig_XdsClusterResolverLoadBalancingPolicyConfig.DiscoveryMechanism) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._cluster != rhs_storage._cluster {return false}
        if _storage._lrsLoadReportingServerName != rhs_storage._lrsLoadReportingServerName {return false}
        if _storage._lrsLoadReportingServer != rhs_storage._lrsLoadReportingServer {return false}
        if _storage._maxConcurrentRequests != rhs_storage._maxConcurrentRequests {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._edsServiceName != rhs_storage._edsServiceName {return false}
        if _storage._dnsHostname != rhs_storage._dnsHostname {return false}
        if _storage._outlierDetection != rhs_storage._outlierDetection {return false}
        if _storage._overrideHostStatus != rhs_storage._overrideHostStatus {return false}
        if _storage._telemetryLabels != rhs_storage._telemetryLabels {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_ServiceConfig_XdsClusterResolverLoadBalancingPolicyConfig.DiscoveryMechanism.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "EDS"),
    2: .same(proto: "LOGICAL_DNS"),
  ]
}

extension Grpc_ServiceConfig_XdsClusterImplLoadBalancingPolicyConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".XdsClusterImplLoadBalancingPolicyConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cluster"),
    2: .standard(proto: "eds_service_name"),
    3: .standard(proto: "lrs_load_reporting_server_name"),
    7: .standard(proto: "lrs_load_reporting_server"),
    4: .standard(proto: "max_concurrent_requests"),
    5: .standard(proto: "drop_categories"),
    6: .standard(proto: "child_policy"),
    8: .standard(proto: "telemetry_labels"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.cluster) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.edsServiceName) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._lrsLoadReportingServerName) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._maxConcurrentRequests) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.dropCategories) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.childPolicy) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._lrsLoadReportingServer) }()
      case 8: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.telemetryLabels) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.cluster.isEmpty {
      try visitor.visitSingularStringField(value: self.cluster, fieldNumber: 1)
    }
    if !self.edsServiceName.isEmpty {
      try visitor.visitSingularStringField(value: self.edsServiceName, fieldNumber: 2)
    }
    try { if let v = self._lrsLoadReportingServerName {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._maxConcurrentRequests {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.dropCategories.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.dropCategories, fieldNumber: 5)
    }
    if !self.childPolicy.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.childPolicy, fieldNumber: 6)
    }
    try { if let v = self._lrsLoadReportingServer {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    if !self.telemetryLabels.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.telemetryLabels, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_ServiceConfig_XdsClusterImplLoadBalancingPolicyConfig, rhs: Grpc_ServiceConfig_XdsClusterImplLoadBalancingPolicyConfig) -> Bool {
    if lhs.cluster != rhs.cluster {return false}
    if lhs.edsServiceName != rhs.edsServiceName {return false}
    if lhs._lrsLoadReportingServerName != rhs._lrsLoadReportingServerName {return false}
    if lhs._lrsLoadReportingServer != rhs._lrsLoadReportingServer {return false}
    if lhs._maxConcurrentRequests != rhs._maxConcurrentRequests {return false}
    if lhs.dropCategories != rhs.dropCategories {return false}
    if lhs.childPolicy != rhs.childPolicy {return false}
    if lhs.telemetryLabels != rhs.telemetryLabels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_ServiceConfig_XdsClusterImplLoadBalancingPolicyConfig.DropCategory: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Grpc_ServiceConfig_XdsClusterImplLoadBalancingPolicyConfig.protoMessageName + ".DropCategory"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "category"),
    2: .standard(proto: "requests_per_million"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.category) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.requestsPerMillion) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.category.isEmpty {
      try visitor.visitSingularStringField(value: self.category, fieldNumber: 1)
    }
    if self.requestsPerMillion != 0 {
      try visitor.visitSingularUInt32Field(value: self.requestsPerMillion, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_ServiceConfig_XdsClusterImplLoadBalancingPolicyConfig.DropCategory, rhs: Grpc_ServiceConfig_XdsClusterImplLoadBalancingPolicyConfig.DropCategory) -> Bool {
    if lhs.category != rhs.category {return false}
    if lhs.requestsPerMillion != rhs.requestsPerMillion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_ServiceConfig_EdsLoadBalancingPolicyConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EdsLoadBalancingPolicyConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cluster"),
    2: .standard(proto: "eds_service_name"),
    3: .standard(proto: "lrs_load_reporting_server_name"),
    4: .standard(proto: "locality_picking_policy"),
    5: .standard(proto: "endpoint_picking_policy"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.cluster) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.edsServiceName) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._lrsLoadReportingServerName) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.localityPickingPolicy) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.endpointPickingPolicy) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.cluster.isEmpty {
      try visitor.visitSingularStringField(value: self.cluster, fieldNumber: 1)
    }
    if !self.edsServiceName.isEmpty {
      try visitor.visitSingularStringField(value: self.edsServiceName, fieldNumber: 2)
    }
    try { if let v = self._lrsLoadReportingServerName {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.localityPickingPolicy.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.localityPickingPolicy, fieldNumber: 4)
    }
    if !self.endpointPickingPolicy.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.endpointPickingPolicy, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_ServiceConfig_EdsLoadBalancingPolicyConfig, rhs: Grpc_ServiceConfig_EdsLoadBalancingPolicyConfig) -> Bool {
    if lhs.cluster != rhs.cluster {return false}
    if lhs.edsServiceName != rhs.edsServiceName {return false}
    if lhs._lrsLoadReportingServerName != rhs._lrsLoadReportingServerName {return false}
    if lhs.localityPickingPolicy != rhs.localityPickingPolicy {return false}
    if lhs.endpointPickingPolicy != rhs.endpointPickingPolicy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_ServiceConfig_RingHashLoadBalancingConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RingHashLoadBalancingConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "min_ring_size"),
    2: .standard(proto: "max_ring_size"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.minRingSize) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.maxRingSize) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.minRingSize != 0 {
      try visitor.visitSingularUInt64Field(value: self.minRingSize, fieldNumber: 1)
    }
    if self.maxRingSize != 0 {
      try visitor.visitSingularUInt64Field(value: self.maxRingSize, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_ServiceConfig_RingHashLoadBalancingConfig, rhs: Grpc_ServiceConfig_RingHashLoadBalancingConfig) -> Bool {
    if lhs.minRingSize != rhs.minRingSize {return false}
    if lhs.maxRingSize != rhs.maxRingSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_ServiceConfig_LrsLoadBalancingPolicyConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LrsLoadBalancingPolicyConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cluster_name"),
    2: .standard(proto: "eds_service_name"),
    3: .standard(proto: "lrs_load_reporting_server_name"),
    4: .same(proto: "locality"),
    5: .standard(proto: "child_policy"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.clusterName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.edsServiceName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.lrsLoadReportingServerName) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._locality) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.childPolicy) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.clusterName.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterName, fieldNumber: 1)
    }
    if !self.edsServiceName.isEmpty {
      try visitor.visitSingularStringField(value: self.edsServiceName, fieldNumber: 2)
    }
    if !self.lrsLoadReportingServerName.isEmpty {
      try visitor.visitSingularStringField(value: self.lrsLoadReportingServerName, fieldNumber: 3)
    }
    try { if let v = self._locality {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.childPolicy.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.childPolicy, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_ServiceConfig_LrsLoadBalancingPolicyConfig, rhs: Grpc_ServiceConfig_LrsLoadBalancingPolicyConfig) -> Bool {
    if lhs.clusterName != rhs.clusterName {return false}
    if lhs.edsServiceName != rhs.edsServiceName {return false}
    if lhs.lrsLoadReportingServerName != rhs.lrsLoadReportingServerName {return false}
    if lhs._locality != rhs._locality {return false}
    if lhs.childPolicy != rhs.childPolicy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_ServiceConfig_LrsLoadBalancingPolicyConfig.Locality: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Grpc_ServiceConfig_LrsLoadBalancingPolicyConfig.protoMessageName + ".Locality"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "region"),
    2: .same(proto: "zone"),
    3: .same(proto: "subzone"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.region) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.zone) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.subzone) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.region.isEmpty {
      try visitor.visitSingularStringField(value: self.region, fieldNumber: 1)
    }
    if !self.zone.isEmpty {
      try visitor.visitSingularStringField(value: self.zone, fieldNumber: 2)
    }
    if !self.subzone.isEmpty {
      try visitor.visitSingularStringField(value: self.subzone, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_ServiceConfig_LrsLoadBalancingPolicyConfig.Locality, rhs: Grpc_ServiceConfig_LrsLoadBalancingPolicyConfig.Locality) -> Bool {
    if lhs.region != rhs.region {return false}
    if lhs.zone != rhs.zone {return false}
    if lhs.subzone != rhs.subzone {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_ServiceConfig_XdsWrrLocalityLoadBalancingPolicyConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".XdsWrrLocalityLoadBalancingPolicyConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "child_policy"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.childPolicy) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.childPolicy.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.childPolicy, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_ServiceConfig_XdsWrrLocalityLoadBalancingPolicyConfig, rhs: Grpc_ServiceConfig_XdsWrrLocalityLoadBalancingPolicyConfig) -> Bool {
    if lhs.childPolicy != rhs.childPolicy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_ServiceConfig_LeastRequestLocalityLoadBalancingPolicyConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LeastRequestLocalityLoadBalancingPolicyConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "choice_count"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.choiceCount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.choiceCount != 0 {
      try visitor.visitSingularUInt64Field(value: self.choiceCount, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_ServiceConfig_LeastRequestLocalityLoadBalancingPolicyConfig, rhs: Grpc_ServiceConfig_LeastRequestLocalityLoadBalancingPolicyConfig) -> Bool {
    if lhs.choiceCount != rhs.choiceCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_ServiceConfig_OverrideHostLoadBalancingPolicyConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OverrideHostLoadBalancingPolicyConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "override_host_status"),
    2: .standard(proto: "child_policy"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedEnumField(value: &self.overrideHostStatus) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.childPolicy) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.overrideHostStatus.isEmpty {
      try visitor.visitPackedEnumField(value: self.overrideHostStatus, fieldNumber: 1)
    }
    if !self.childPolicy.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.childPolicy, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_ServiceConfig_OverrideHostLoadBalancingPolicyConfig, rhs: Grpc_ServiceConfig_OverrideHostLoadBalancingPolicyConfig) -> Bool {
    if lhs.overrideHostStatus != rhs.overrideHostStatus {return false}
    if lhs.childPolicy != rhs.childPolicy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_ServiceConfig_OverrideHostLoadBalancingPolicyConfig.HealthStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "HEALTHY"),
    3: .same(proto: "DRAINING"),
  ]
}

extension Grpc_ServiceConfig_XdsConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".XdsConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "balancer_name"),
    2: .standard(proto: "child_policy"),
    3: .standard(proto: "fallback_policy"),
    4: .standard(proto: "eds_service_name"),
    5: .standard(proto: "lrs_load_reporting_server_name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.balancerName) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.childPolicy) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.fallbackPolicy) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.edsServiceName) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._lrsLoadReportingServerName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.balancerName.isEmpty {
      try visitor.visitSingularStringField(value: self.balancerName, fieldNumber: 1)
    }
    if !self.childPolicy.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.childPolicy, fieldNumber: 2)
    }
    if !self.fallbackPolicy.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fallbackPolicy, fieldNumber: 3)
    }
    if !self.edsServiceName.isEmpty {
      try visitor.visitSingularStringField(value: self.edsServiceName, fieldNumber: 4)
    }
    try { if let v = self._lrsLoadReportingServerName {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_ServiceConfig_XdsConfig, rhs: Grpc_ServiceConfig_XdsConfig) -> Bool {
    if lhs.balancerName != rhs.balancerName {return false}
    if lhs.childPolicy != rhs.childPolicy {return false}
    if lhs.fallbackPolicy != rhs.fallbackPolicy {return false}
    if lhs.edsServiceName != rhs.edsServiceName {return false}
    if lhs._lrsLoadReportingServerName != rhs._lrsLoadReportingServerName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_ServiceConfig_LoadBalancingConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LoadBalancingConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    4: .same(proto: "pick_first"),
    1: .same(proto: "round_robin"),
    20: .same(proto: "weighted_round_robin"),
    3: .same(proto: "grpclb"),
    9: .same(proto: "priority_experimental"),
    10: .same(proto: "weighted_target_experimental"),
    15: .unique(proto: "outlier_detection", json: "outlier_detection_experimental"),
    19: .unique(proto: "rls", json: "rls_experimental"),
    14: .same(proto: "xds_cluster_manager_experimental"),
    6: .same(proto: "cds_experimental"),
    11: .same(proto: "xds_cluster_resolver_experimental"),
    12: .same(proto: "xds_cluster_impl_experimental"),
    18: .same(proto: "override_host_experimental"),
    16: .same(proto: "xds_wrr_locality_experimental"),
    13: .same(proto: "ring_hash_experimental"),
    17: .same(proto: "least_request_experimental"),
    8: .same(proto: "lrs_experimental"),
    7: .same(proto: "eds_experimental"),
    2: .same(proto: "xds"),
    5: .same(proto: "xds_experimental"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Grpc_ServiceConfig_RoundRobinConfig?
        var hadOneofValue = false
        if let current = self.policy {
          hadOneofValue = true
          if case .roundRobin(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.policy = .roundRobin(v)
        }
      }()
      case 2: try {
        var v: Grpc_ServiceConfig_XdsConfig?
        var hadOneofValue = false
        if let current = self.policy {
          hadOneofValue = true
          if case .xds(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.policy = .xds(v)
        }
      }()
      case 3: try {
        var v: Grpc_ServiceConfig_GrpcLbConfig?
        var hadOneofValue = false
        if let current = self.policy {
          hadOneofValue = true
          if case .grpclb(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.policy = .grpclb(v)
        }
      }()
      case 4: try {
        var v: Grpc_ServiceConfig_PickFirstConfig?
        var hadOneofValue = false
        if let current = self.policy {
          hadOneofValue = true
          if case .pickFirst(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.policy = .pickFirst(v)
        }
      }()
      case 5: try {
        var v: Grpc_ServiceConfig_XdsConfig?
        var hadOneofValue = false
        if let current = self.policy {
          hadOneofValue = true
          if case .xdsExperimental(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.policy = .xdsExperimental(v)
        }
      }()
      case 6: try {
        var v: Grpc_ServiceConfig_CdsConfig?
        var hadOneofValue = false
        if let current = self.policy {
          hadOneofValue = true
          if case .cdsExperimental(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.policy = .cdsExperimental(v)
        }
      }()
      case 7: try {
        var v: Grpc_ServiceConfig_EdsLoadBalancingPolicyConfig?
        var hadOneofValue = false
        if let current = self.policy {
          hadOneofValue = true
          if case .edsExperimental(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.policy = .edsExperimental(v)
        }
      }()
      case 8: try {
        var v: Grpc_ServiceConfig_LrsLoadBalancingPolicyConfig?
        var hadOneofValue = false
        if let current = self.policy {
          hadOneofValue = true
          if case .lrsExperimental(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.policy = .lrsExperimental(v)
        }
      }()
      case 9: try {
        var v: Grpc_ServiceConfig_PriorityLoadBalancingPolicyConfig?
        var hadOneofValue = false
        if let current = self.policy {
          hadOneofValue = true
          if case .priorityExperimental(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.policy = .priorityExperimental(v)
        }
      }()
      case 10: try {
        var v: Grpc_ServiceConfig_WeightedTargetLoadBalancingPolicyConfig?
        var hadOneofValue = false
        if let current = self.policy {
          hadOneofValue = true
          if case .weightedTargetExperimental(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.policy = .weightedTargetExperimental(v)
        }
      }()
      case 11: try {
        var v: Grpc_ServiceConfig_XdsClusterResolverLoadBalancingPolicyConfig?
        var hadOneofValue = false
        if let current = self.policy {
          hadOneofValue = true
          if case .xdsClusterResolverExperimental(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.policy = .xdsClusterResolverExperimental(v)
        }
      }()
      case 12: try {
        var v: Grpc_ServiceConfig_XdsClusterImplLoadBalancingPolicyConfig?
        var hadOneofValue = false
        if let current = self.policy {
          hadOneofValue = true
          if case .xdsClusterImplExperimental(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.policy = .xdsClusterImplExperimental(v)
        }
      }()
      case 13: try {
        var v: Grpc_ServiceConfig_RingHashLoadBalancingConfig?
        var hadOneofValue = false
        if let current = self.policy {
          hadOneofValue = true
          if case .ringHashExperimental(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.policy = .ringHashExperimental(v)
        }
      }()
      case 14: try {
        var v: Grpc_ServiceConfig_XdsClusterManagerLoadBalancingPolicyConfig?
        var hadOneofValue = false
        if let current = self.policy {
          hadOneofValue = true
          if case .xdsClusterManagerExperimental(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.policy = .xdsClusterManagerExperimental(v)
        }
      }()
      case 15: try {
        var v: Grpc_ServiceConfig_OutlierDetectionLoadBalancingConfig?
        var hadOneofValue = false
        if let current = self.policy {
          hadOneofValue = true
          if case .outlierDetection(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.policy = .outlierDetection(v)
        }
      }()
      case 16: try {
        var v: Grpc_ServiceConfig_XdsWrrLocalityLoadBalancingPolicyConfig?
        var hadOneofValue = false
        if let current = self.policy {
          hadOneofValue = true
          if case .xdsWrrLocalityExperimental(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.policy = .xdsWrrLocalityExperimental(v)
        }
      }()
      case 17: try {
        var v: Grpc_ServiceConfig_LeastRequestLocalityLoadBalancingPolicyConfig?
        var hadOneofValue = false
        if let current = self.policy {
          hadOneofValue = true
          if case .leastRequestExperimental(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.policy = .leastRequestExperimental(v)
        }
      }()
      case 18: try {
        var v: Grpc_ServiceConfig_OverrideHostLoadBalancingPolicyConfig?
        var hadOneofValue = false
        if let current = self.policy {
          hadOneofValue = true
          if case .overrideHostExperimental(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.policy = .overrideHostExperimental(v)
        }
      }()
      case 19: try {
        var v: Grpc_ServiceConfig_RlsLoadBalancingPolicyConfig?
        var hadOneofValue = false
        if let current = self.policy {
          hadOneofValue = true
          if case .rls(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.policy = .rls(v)
        }
      }()
      case 20: try {
        var v: Grpc_ServiceConfig_WeightedRoundRobinLbConfig?
        var hadOneofValue = false
        if let current = self.policy {
          hadOneofValue = true
          if case .weightedRoundRobin(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.policy = .weightedRoundRobin(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.policy {
    case .roundRobin?: try {
      guard case .roundRobin(let v)? = self.policy else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .xds?: try {
      guard case .xds(let v)? = self.policy else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .grpclb?: try {
      guard case .grpclb(let v)? = self.policy else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .pickFirst?: try {
      guard case .pickFirst(let v)? = self.policy else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .xdsExperimental?: try {
      guard case .xdsExperimental(let v)? = self.policy else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .cdsExperimental?: try {
      guard case .cdsExperimental(let v)? = self.policy else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .edsExperimental?: try {
      guard case .edsExperimental(let v)? = self.policy else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .lrsExperimental?: try {
      guard case .lrsExperimental(let v)? = self.policy else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .priorityExperimental?: try {
      guard case .priorityExperimental(let v)? = self.policy else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .weightedTargetExperimental?: try {
      guard case .weightedTargetExperimental(let v)? = self.policy else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .xdsClusterResolverExperimental?: try {
      guard case .xdsClusterResolverExperimental(let v)? = self.policy else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .xdsClusterImplExperimental?: try {
      guard case .xdsClusterImplExperimental(let v)? = self.policy else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .ringHashExperimental?: try {
      guard case .ringHashExperimental(let v)? = self.policy else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .xdsClusterManagerExperimental?: try {
      guard case .xdsClusterManagerExperimental(let v)? = self.policy else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .outlierDetection?: try {
      guard case .outlierDetection(let v)? = self.policy else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .xdsWrrLocalityExperimental?: try {
      guard case .xdsWrrLocalityExperimental(let v)? = self.policy else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .leastRequestExperimental?: try {
      guard case .leastRequestExperimental(let v)? = self.policy else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .overrideHostExperimental?: try {
      guard case .overrideHostExperimental(let v)? = self.policy else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case .rls?: try {
      guard case .rls(let v)? = self.policy else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
    }()
    case .weightedRoundRobin?: try {
      guard case .weightedRoundRobin(let v)? = self.policy else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_ServiceConfig_LoadBalancingConfig, rhs: Grpc_ServiceConfig_LoadBalancingConfig) -> Bool {
    if lhs.policy != rhs.policy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_ServiceConfig_ServiceConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ServiceConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "load_balancing_policy"),
    4: .standard(proto: "load_balancing_config"),
    2: .standard(proto: "method_config"),
    3: .standard(proto: "retry_throttling"),
    5: .standard(proto: "health_check_config"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.loadBalancingPolicy) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.methodConfig) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._retryThrottling) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.loadBalancingConfig) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._healthCheckConfig) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.loadBalancingPolicy != .unspecified {
      try visitor.visitSingularEnumField(value: self.loadBalancingPolicy, fieldNumber: 1)
    }
    if !self.methodConfig.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.methodConfig, fieldNumber: 2)
    }
    try { if let v = self._retryThrottling {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.loadBalancingConfig.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.loadBalancingConfig, fieldNumber: 4)
    }
    try { if let v = self._healthCheckConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_ServiceConfig_ServiceConfig, rhs: Grpc_ServiceConfig_ServiceConfig) -> Bool {
    if lhs.loadBalancingPolicy != rhs.loadBalancingPolicy {return false}
    if lhs.loadBalancingConfig != rhs.loadBalancingConfig {return false}
    if lhs.methodConfig != rhs.methodConfig {return false}
    if lhs._retryThrottling != rhs._retryThrottling {return false}
    if lhs._healthCheckConfig != rhs._healthCheckConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_ServiceConfig_ServiceConfig.LoadBalancingPolicy: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSPECIFIED"),
    1: .same(proto: "ROUND_ROBIN"),
  ]
}

extension Grpc_ServiceConfig_ServiceConfig.RetryThrottlingPolicy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Grpc_ServiceConfig_ServiceConfig.protoMessageName + ".RetryThrottlingPolicy"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "max_tokens"),
    2: .standard(proto: "token_ratio"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.maxTokens) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.tokenRatio) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.maxTokens != 0 {
      try visitor.visitSingularUInt32Field(value: self.maxTokens, fieldNumber: 1)
    }
    if self.tokenRatio != 0 {
      try visitor.visitSingularFloatField(value: self.tokenRatio, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_ServiceConfig_ServiceConfig.RetryThrottlingPolicy, rhs: Grpc_ServiceConfig_ServiceConfig.RetryThrottlingPolicy) -> Bool {
    if lhs.maxTokens != rhs.maxTokens {return false}
    if lhs.tokenRatio != rhs.tokenRatio {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_ServiceConfig_ServiceConfig.HealthCheckConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Grpc_ServiceConfig_ServiceConfig.protoMessageName + ".HealthCheckConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "service_name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._serviceName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._serviceName {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_ServiceConfig_ServiceConfig.HealthCheckConfig, rhs: Grpc_ServiceConfig_ServiceConfig.HealthCheckConfig) -> Bool {
    if lhs._serviceName != rhs._serviceName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
