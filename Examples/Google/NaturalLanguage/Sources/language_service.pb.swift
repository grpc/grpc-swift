// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/language/v1/language_service.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2019 Google LLC.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Represents the text encoding that the caller uses to process the output.
/// Providing an `EncodingType` is recommended because the API provides the
/// beginning offsets for various outputs, such as tokens and mentions, and
/// languages that natively use different text encodings may access offsets
/// differently.
enum Google_Cloud_Language_V1_EncodingType: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// If `EncodingType` is not specified, encoding-dependent information (such as
  /// `begin_offset`) will be set at `-1`.
  case none // = 0

  /// Encoding-dependent information (such as `begin_offset`) is calculated based
  /// on the UTF-8 encoding of the input. C++ and Go are examples of languages
  /// that use this encoding natively.
  case utf8 // = 1

  /// Encoding-dependent information (such as `begin_offset`) is calculated based
  /// on the UTF-16 encoding of the input. Java and JavaScript are examples of
  /// languages that use this encoding natively.
  case utf16 // = 2

  /// Encoding-dependent information (such as `begin_offset`) is calculated based
  /// on the UTF-32 encoding of the input. Python is an example of a language
  /// that uses this encoding natively.
  case utf32 // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .none
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .none
    case 1: self = .utf8
    case 2: self = .utf16
    case 3: self = .utf32
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .none: return 0
    case .utf8: return 1
    case .utf16: return 2
    case .utf32: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Google_Cloud_Language_V1_EncodingType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Google_Cloud_Language_V1_EncodingType] = [
    .none,
    .utf8,
    .utf16,
    .utf32,
  ]
}

#endif  // swift(>=4.2)

/// ################################################################ #
///
/// Represents the input to API methods.
struct Google_Cloud_Language_V1_Document {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. If the type is not set or is `TYPE_UNSPECIFIED`,
  /// returns an `INVALID_ARGUMENT` error.
  var type: Google_Cloud_Language_V1_Document.TypeEnum = .unspecified

  /// The source of the document: a string containing the content or a
  /// Google Cloud Storage URI.
  var source: Google_Cloud_Language_V1_Document.OneOf_Source? = nil

  /// The content of the input in string format.
  /// Cloud audit logging exempt since it is based on user data.
  var content: String {
    get {
      if case .content(let v)? = source {return v}
      return String()
    }
    set {source = .content(newValue)}
  }

  /// The Google Cloud Storage URI where the file content is located.
  /// This URI must be of the form: gs://bucket_name/object_name. For more
  /// details, see https://cloud.google.com/storage/docs/reference-uris.
  /// NOTE: Cloud Storage object versioning is not supported.
  var gcsContentUri: String {
    get {
      if case .gcsContentUri(let v)? = source {return v}
      return String()
    }
    set {source = .gcsContentUri(newValue)}
  }

  /// The language of the document (if not specified, the language is
  /// automatically detected). Both ISO and BCP-47 language codes are
  /// accepted.<br>
  /// [Language
  /// Support](https://cloud.google.com/natural-language/docs/languages) lists
  /// currently supported languages for each API method. If the language (either
  /// specified by the caller or automatically detected) is not supported by the
  /// called API method, an `INVALID_ARGUMENT` error is returned.
  var language: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The source of the document: a string containing the content or a
  /// Google Cloud Storage URI.
  enum OneOf_Source: Equatable {
    /// The content of the input in string format.
    /// Cloud audit logging exempt since it is based on user data.
    case content(String)
    /// The Google Cloud Storage URI where the file content is located.
    /// This URI must be of the form: gs://bucket_name/object_name. For more
    /// details, see https://cloud.google.com/storage/docs/reference-uris.
    /// NOTE: Cloud Storage object versioning is not supported.
    case gcsContentUri(String)

  #if !swift(>=4.1)
    static func ==(lhs: Google_Cloud_Language_V1_Document.OneOf_Source, rhs: Google_Cloud_Language_V1_Document.OneOf_Source) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.content, .content): return {
        guard case .content(let l) = lhs, case .content(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.gcsContentUri, .gcsContentUri): return {
        guard case .gcsContentUri(let l) = lhs, case .gcsContentUri(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// The document types enum.
  enum TypeEnum: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// The content type is not specified.
    case unspecified // = 0

    /// Plain text
    case plainText // = 1

    /// HTML
    case html // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .plainText
      case 2: self = .html
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .plainText: return 1
      case .html: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Google_Cloud_Language_V1_Document.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Google_Cloud_Language_V1_Document.TypeEnum] = [
    .unspecified,
    .plainText,
    .html,
  ]
}

#endif  // swift(>=4.2)

/// Represents a sentence in the input document.
struct Google_Cloud_Language_V1_Sentence {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The sentence text.
  var text: Google_Cloud_Language_V1_TextSpan {
    get {return _text ?? Google_Cloud_Language_V1_TextSpan()}
    set {_text = newValue}
  }
  /// Returns true if `text` has been explicitly set.
  var hasText: Bool {return self._text != nil}
  /// Clears the value of `text`. Subsequent reads from it will return its default value.
  mutating func clearText() {self._text = nil}

  /// For calls to [AnalyzeSentiment][] or if
  /// [AnnotateTextRequest.Features.extract_document_sentiment][google.cloud.language.v1.AnnotateTextRequest.Features.extract_document_sentiment]
  /// is set to true, this field will contain the sentiment for the sentence.
  var sentiment: Google_Cloud_Language_V1_Sentiment {
    get {return _sentiment ?? Google_Cloud_Language_V1_Sentiment()}
    set {_sentiment = newValue}
  }
  /// Returns true if `sentiment` has been explicitly set.
  var hasSentiment: Bool {return self._sentiment != nil}
  /// Clears the value of `sentiment`. Subsequent reads from it will return its default value.
  mutating func clearSentiment() {self._sentiment = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _text: Google_Cloud_Language_V1_TextSpan? = nil
  fileprivate var _sentiment: Google_Cloud_Language_V1_Sentiment? = nil
}

/// Represents a phrase in the text that is a known entity, such as
/// a person, an organization, or location. The API associates information, such
/// as salience and mentions, with entities.
struct Google_Cloud_Language_V1_Entity {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The representative name for the entity.
  var name: String = String()

  /// The entity type.
  var type: Google_Cloud_Language_V1_Entity.TypeEnum = .unknown

  /// Metadata associated with the entity.
  ///
  /// For most entity types, the metadata is a Wikipedia URL (`wikipedia_url`)
  /// and Knowledge Graph MID (`mid`), if they are available. For the metadata
  /// associated with other entity types, see the Type table below.
  var metadata: Dictionary<String,String> = [:]

  /// The salience score associated with the entity in the [0, 1.0] range.
  ///
  /// The salience score for an entity provides information about the
  /// importance or centrality of that entity to the entire document text.
  /// Scores closer to 0 are less salient, while scores closer to 1.0 are highly
  /// salient.
  var salience: Float = 0

  /// The mentions of this entity in the input document. The API currently
  /// supports proper noun mentions.
  var mentions: [Google_Cloud_Language_V1_EntityMention] = []

  /// For calls to [AnalyzeEntitySentiment][] or if
  /// [AnnotateTextRequest.Features.extract_entity_sentiment][google.cloud.language.v1.AnnotateTextRequest.Features.extract_entity_sentiment]
  /// is set to true, this field will contain the aggregate sentiment expressed
  /// for this entity in the provided document.
  var sentiment: Google_Cloud_Language_V1_Sentiment {
    get {return _sentiment ?? Google_Cloud_Language_V1_Sentiment()}
    set {_sentiment = newValue}
  }
  /// Returns true if `sentiment` has been explicitly set.
  var hasSentiment: Bool {return self._sentiment != nil}
  /// Clears the value of `sentiment`. Subsequent reads from it will return its default value.
  mutating func clearSentiment() {self._sentiment = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The type of the entity. For most entity types, the associated metadata is a
  /// Wikipedia URL (`wikipedia_url`) and Knowledge Graph MID (`mid`). The table
  /// below lists the associated fields for entities that have different
  /// metadata.
  enum TypeEnum: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Unknown
    case unknown // = 0

    /// Person
    case person // = 1

    /// Location
    case location // = 2

    /// Organization
    case organization // = 3

    /// Event
    case event // = 4

    /// Artwork
    case workOfArt // = 5

    /// Consumer product
    case consumerGood // = 6

    /// Other types of entities
    case other // = 7

    /// Phone number
    ///
    /// The metadata lists the phone number, formatted according to local
    /// convention, plus whichever additional elements appear in the text:
    ///
    /// * `number` - the actual number, broken down into sections as per local
    /// convention
    /// * `national_prefix` - country code, if detected
    /// * `area_code` - region or area code, if detected
    /// * `extension` - phone extension (to be dialed after connection), if
    /// detected
    case phoneNumber // = 9

    /// Address
    ///
    /// The metadata identifies the street number and locality plus whichever
    /// additional elements appear in the text:
    ///
    /// * `street_number` - street number
    /// * `locality` - city or town
    /// * `street_name` - street/route name, if detected
    /// * `postal_code` - postal code, if detected
    /// * `country` - country, if detected<
    /// * `broad_region` - administrative area, such as the state, if detected
    /// * `narrow_region` - smaller administrative area, such as county, if
    /// detected
    /// * `sublocality` - used in Asian addresses to demark a district within a
    /// city, if detected
    case address // = 10

    /// Date
    ///
    /// The metadata identifies the components of the date:
    ///
    /// * `year` - four digit year, if detected
    /// * `month` - two digit month number, if detected
    /// * `day` - two digit day number, if detected
    case date // = 11

    /// Number
    ///
    /// The metadata is the number itself.
    case number // = 12

    /// Price
    ///
    /// The metadata identifies the `value` and `currency`.
    case price // = 13
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .person
      case 2: self = .location
      case 3: self = .organization
      case 4: self = .event
      case 5: self = .workOfArt
      case 6: self = .consumerGood
      case 7: self = .other
      case 9: self = .phoneNumber
      case 10: self = .address
      case 11: self = .date
      case 12: self = .number
      case 13: self = .price
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .person: return 1
      case .location: return 2
      case .organization: return 3
      case .event: return 4
      case .workOfArt: return 5
      case .consumerGood: return 6
      case .other: return 7
      case .phoneNumber: return 9
      case .address: return 10
      case .date: return 11
      case .number: return 12
      case .price: return 13
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _sentiment: Google_Cloud_Language_V1_Sentiment? = nil
}

#if swift(>=4.2)

extension Google_Cloud_Language_V1_Entity.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Google_Cloud_Language_V1_Entity.TypeEnum] = [
    .unknown,
    .person,
    .location,
    .organization,
    .event,
    .workOfArt,
    .consumerGood,
    .other,
    .phoneNumber,
    .address,
    .date,
    .number,
    .price,
  ]
}

#endif  // swift(>=4.2)

/// Represents the smallest syntactic building block of the text.
struct Google_Cloud_Language_V1_Token {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The token text.
  var text: Google_Cloud_Language_V1_TextSpan {
    get {return _storage._text ?? Google_Cloud_Language_V1_TextSpan()}
    set {_uniqueStorage()._text = newValue}
  }
  /// Returns true if `text` has been explicitly set.
  var hasText: Bool {return _storage._text != nil}
  /// Clears the value of `text`. Subsequent reads from it will return its default value.
  mutating func clearText() {_uniqueStorage()._text = nil}

  /// Parts of speech tag for this token.
  var partOfSpeech: Google_Cloud_Language_V1_PartOfSpeech {
    get {return _storage._partOfSpeech ?? Google_Cloud_Language_V1_PartOfSpeech()}
    set {_uniqueStorage()._partOfSpeech = newValue}
  }
  /// Returns true if `partOfSpeech` has been explicitly set.
  var hasPartOfSpeech: Bool {return _storage._partOfSpeech != nil}
  /// Clears the value of `partOfSpeech`. Subsequent reads from it will return its default value.
  mutating func clearPartOfSpeech() {_uniqueStorage()._partOfSpeech = nil}

  /// Dependency tree parse for this token.
  var dependencyEdge: Google_Cloud_Language_V1_DependencyEdge {
    get {return _storage._dependencyEdge ?? Google_Cloud_Language_V1_DependencyEdge()}
    set {_uniqueStorage()._dependencyEdge = newValue}
  }
  /// Returns true if `dependencyEdge` has been explicitly set.
  var hasDependencyEdge: Bool {return _storage._dependencyEdge != nil}
  /// Clears the value of `dependencyEdge`. Subsequent reads from it will return its default value.
  mutating func clearDependencyEdge() {_uniqueStorage()._dependencyEdge = nil}

  /// [Lemma](https://en.wikipedia.org/wiki/Lemma_%28morphology%29) of the token.
  var lemma: String {
    get {return _storage._lemma}
    set {_uniqueStorage()._lemma = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Represents the feeling associated with the entire text or entities in
/// the text.
struct Google_Cloud_Language_V1_Sentiment {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A non-negative number in the [0, +inf) range, which represents
  /// the absolute magnitude of sentiment regardless of score (positive or
  /// negative).
  var magnitude: Float = 0

  /// Sentiment score between -1.0 (negative sentiment) and 1.0
  /// (positive sentiment).
  var score: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Represents part of speech information for a token. Parts of speech
/// are as defined in
/// http://www.lrec-conf.org/proceedings/lrec2012/pdf/274_Paper.pdf
struct Google_Cloud_Language_V1_PartOfSpeech {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The part of speech tag.
  var tag: Google_Cloud_Language_V1_PartOfSpeech.Tag = .unknown

  /// The grammatical aspect.
  var aspect: Google_Cloud_Language_V1_PartOfSpeech.Aspect = .unknown

  /// The grammatical case.
  var `case`: Google_Cloud_Language_V1_PartOfSpeech.Case = .unknown

  /// The grammatical form.
  var form: Google_Cloud_Language_V1_PartOfSpeech.Form = .unknown

  /// The grammatical gender.
  var gender: Google_Cloud_Language_V1_PartOfSpeech.Gender = .unknown

  /// The grammatical mood.
  var mood: Google_Cloud_Language_V1_PartOfSpeech.Mood = .unknown

  /// The grammatical number.
  var number: Google_Cloud_Language_V1_PartOfSpeech.Number = .unknown

  /// The grammatical person.
  var person: Google_Cloud_Language_V1_PartOfSpeech.Person = .unknown

  /// The grammatical properness.
  var proper: Google_Cloud_Language_V1_PartOfSpeech.Proper = .unknown

  /// The grammatical reciprocity.
  var reciprocity: Google_Cloud_Language_V1_PartOfSpeech.Reciprocity = .unknown

  /// The grammatical tense.
  var tense: Google_Cloud_Language_V1_PartOfSpeech.Tense = .unknown

  /// The grammatical voice.
  var voice: Google_Cloud_Language_V1_PartOfSpeech.Voice = .unknown

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The part of speech tags enum.
  enum Tag: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Unknown
    case unknown // = 0

    /// Adjective
    case adj // = 1

    /// Adposition (preposition and postposition)
    case adp // = 2

    /// Adverb
    case adv // = 3

    /// Conjunction
    case conj // = 4

    /// Determiner
    case det // = 5

    /// Noun (common and proper)
    case noun // = 6

    /// Cardinal number
    case num // = 7

    /// Pronoun
    case pron // = 8

    /// Particle or other function word
    case prt // = 9

    /// Punctuation
    case punct // = 10

    /// Verb (all tenses and modes)
    case verb // = 11

    /// Other: foreign words, typos, abbreviations
    case x // = 12

    /// Affix
    case affix // = 13
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .adj
      case 2: self = .adp
      case 3: self = .adv
      case 4: self = .conj
      case 5: self = .det
      case 6: self = .noun
      case 7: self = .num
      case 8: self = .pron
      case 9: self = .prt
      case 10: self = .punct
      case 11: self = .verb
      case 12: self = .x
      case 13: self = .affix
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .adj: return 1
      case .adp: return 2
      case .adv: return 3
      case .conj: return 4
      case .det: return 5
      case .noun: return 6
      case .num: return 7
      case .pron: return 8
      case .prt: return 9
      case .punct: return 10
      case .verb: return 11
      case .x: return 12
      case .affix: return 13
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// The characteristic of a verb that expresses time flow during an event.
  enum Aspect: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Aspect is not applicable in the analyzed language or is not predicted.
    case unknown // = 0

    /// Perfective
    case perfective // = 1

    /// Imperfective
    case imperfective // = 2

    /// Progressive
    case progressive // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .perfective
      case 2: self = .imperfective
      case 3: self = .progressive
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .perfective: return 1
      case .imperfective: return 2
      case .progressive: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// The grammatical function performed by a noun or pronoun in a phrase,
  /// clause, or sentence. In some languages, other parts of speech, such as
  /// adjective and determiner, take case inflection in agreement with the noun.
  enum Case: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Case is not applicable in the analyzed language or is not predicted.
    case unknown // = 0

    /// Accusative
    case accusative // = 1

    /// Adverbial
    case adverbial // = 2

    /// Complementive
    case complementive // = 3

    /// Dative
    case dative // = 4

    /// Genitive
    case genitive // = 5

    /// Instrumental
    case instrumental // = 6

    /// Locative
    case locative // = 7

    /// Nominative
    case nominative // = 8

    /// Oblique
    case oblique // = 9

    /// Partitive
    case partitive // = 10

    /// Prepositional
    case prepositional // = 11

    /// Reflexive
    case reflexiveCase // = 12

    /// Relative
    case relativeCase // = 13

    /// Vocative
    case vocative // = 14
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .accusative
      case 2: self = .adverbial
      case 3: self = .complementive
      case 4: self = .dative
      case 5: self = .genitive
      case 6: self = .instrumental
      case 7: self = .locative
      case 8: self = .nominative
      case 9: self = .oblique
      case 10: self = .partitive
      case 11: self = .prepositional
      case 12: self = .reflexiveCase
      case 13: self = .relativeCase
      case 14: self = .vocative
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .accusative: return 1
      case .adverbial: return 2
      case .complementive: return 3
      case .dative: return 4
      case .genitive: return 5
      case .instrumental: return 6
      case .locative: return 7
      case .nominative: return 8
      case .oblique: return 9
      case .partitive: return 10
      case .prepositional: return 11
      case .reflexiveCase: return 12
      case .relativeCase: return 13
      case .vocative: return 14
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Depending on the language, Form can be categorizing different forms of
  /// verbs, adjectives, adverbs, etc. For example, categorizing inflected
  /// endings of verbs and adjectives or distinguishing between short and long
  /// forms of adjectives and participles
  enum Form: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Form is not applicable in the analyzed language or is not predicted.
    case unknown // = 0

    /// Adnomial
    case adnomial // = 1

    /// Auxiliary
    case auxiliary // = 2

    /// Complementizer
    case complementizer // = 3

    /// Final ending
    case finalEnding // = 4

    /// Gerund
    case gerund // = 5

    /// Realis
    case realis // = 6

    /// Irrealis
    case irrealis // = 7

    /// Short form
    case short // = 8

    /// Long form
    case long // = 9

    /// Order form
    case order // = 10

    /// Specific form
    case specific // = 11
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .adnomial
      case 2: self = .auxiliary
      case 3: self = .complementizer
      case 4: self = .finalEnding
      case 5: self = .gerund
      case 6: self = .realis
      case 7: self = .irrealis
      case 8: self = .short
      case 9: self = .long
      case 10: self = .order
      case 11: self = .specific
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .adnomial: return 1
      case .auxiliary: return 2
      case .complementizer: return 3
      case .finalEnding: return 4
      case .gerund: return 5
      case .realis: return 6
      case .irrealis: return 7
      case .short: return 8
      case .long: return 9
      case .order: return 10
      case .specific: return 11
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Gender classes of nouns reflected in the behaviour of associated words.
  enum Gender: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Gender is not applicable in the analyzed language or is not predicted.
    case unknown // = 0

    /// Feminine
    case feminine // = 1

    /// Masculine
    case masculine // = 2

    /// Neuter
    case neuter // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .feminine
      case 2: self = .masculine
      case 3: self = .neuter
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .feminine: return 1
      case .masculine: return 2
      case .neuter: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// The grammatical feature of verbs, used for showing modality and attitude.
  enum Mood: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Mood is not applicable in the analyzed language or is not predicted.
    case unknown // = 0

    /// Conditional
    case conditionalMood // = 1

    /// Imperative
    case imperative // = 2

    /// Indicative
    case indicative // = 3

    /// Interrogative
    case interrogative // = 4

    /// Jussive
    case jussive // = 5

    /// Subjunctive
    case subjunctive // = 6
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .conditionalMood
      case 2: self = .imperative
      case 3: self = .indicative
      case 4: self = .interrogative
      case 5: self = .jussive
      case 6: self = .subjunctive
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .conditionalMood: return 1
      case .imperative: return 2
      case .indicative: return 3
      case .interrogative: return 4
      case .jussive: return 5
      case .subjunctive: return 6
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Count distinctions.
  enum Number: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Number is not applicable in the analyzed language or is not predicted.
    case unknown // = 0

    /// Singular
    case singular // = 1

    /// Plural
    case plural // = 2

    /// Dual
    case dual // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .singular
      case 2: self = .plural
      case 3: self = .dual
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .singular: return 1
      case .plural: return 2
      case .dual: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// The distinction between the speaker, second person, third person, etc.
  enum Person: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Person is not applicable in the analyzed language or is not predicted.
    case unknown // = 0

    /// First
    case first // = 1

    /// Second
    case second // = 2

    /// Third
    case third // = 3

    /// Reflexive
    case reflexivePerson // = 4
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .first
      case 2: self = .second
      case 3: self = .third
      case 4: self = .reflexivePerson
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .first: return 1
      case .second: return 2
      case .third: return 3
      case .reflexivePerson: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// This category shows if the token is part of a proper name.
  enum Proper: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Proper is not applicable in the analyzed language or is not predicted.
    case unknown // = 0

    /// Proper
    case proper // = 1

    /// Not proper
    case notProper // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .proper
      case 2: self = .notProper
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .proper: return 1
      case .notProper: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Reciprocal features of a pronoun.
  enum Reciprocity: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Reciprocity is not applicable in the analyzed language or is not
    /// predicted.
    case unknown // = 0

    /// Reciprocal
    case reciprocal // = 1

    /// Non-reciprocal
    case nonReciprocal // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .reciprocal
      case 2: self = .nonReciprocal
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .reciprocal: return 1
      case .nonReciprocal: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Time reference.
  enum Tense: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Tense is not applicable in the analyzed language or is not predicted.
    case unknown // = 0

    /// Conditional
    case conditionalTense // = 1

    /// Future
    case future // = 2

    /// Past
    case past // = 3

    /// Present
    case present // = 4

    /// Imperfect
    case imperfect // = 5

    /// Pluperfect
    case pluperfect // = 6
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .conditionalTense
      case 2: self = .future
      case 3: self = .past
      case 4: self = .present
      case 5: self = .imperfect
      case 6: self = .pluperfect
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .conditionalTense: return 1
      case .future: return 2
      case .past: return 3
      case .present: return 4
      case .imperfect: return 5
      case .pluperfect: return 6
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// The relationship between the action that a verb expresses and the
  /// participants identified by its arguments.
  enum Voice: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Voice is not applicable in the analyzed language or is not predicted.
    case unknown // = 0

    /// Active
    case active // = 1

    /// Causative
    case causative // = 2

    /// Passive
    case passive // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .active
      case 2: self = .causative
      case 3: self = .passive
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .active: return 1
      case .causative: return 2
      case .passive: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Google_Cloud_Language_V1_PartOfSpeech.Tag: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Google_Cloud_Language_V1_PartOfSpeech.Tag] = [
    .unknown,
    .adj,
    .adp,
    .adv,
    .conj,
    .det,
    .noun,
    .num,
    .pron,
    .prt,
    .punct,
    .verb,
    .x,
    .affix,
  ]
}

extension Google_Cloud_Language_V1_PartOfSpeech.Aspect: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Google_Cloud_Language_V1_PartOfSpeech.Aspect] = [
    .unknown,
    .perfective,
    .imperfective,
    .progressive,
  ]
}

extension Google_Cloud_Language_V1_PartOfSpeech.Case: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Google_Cloud_Language_V1_PartOfSpeech.Case] = [
    .unknown,
    .accusative,
    .adverbial,
    .complementive,
    .dative,
    .genitive,
    .instrumental,
    .locative,
    .nominative,
    .oblique,
    .partitive,
    .prepositional,
    .reflexiveCase,
    .relativeCase,
    .vocative,
  ]
}

extension Google_Cloud_Language_V1_PartOfSpeech.Form: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Google_Cloud_Language_V1_PartOfSpeech.Form] = [
    .unknown,
    .adnomial,
    .auxiliary,
    .complementizer,
    .finalEnding,
    .gerund,
    .realis,
    .irrealis,
    .short,
    .long,
    .order,
    .specific,
  ]
}

extension Google_Cloud_Language_V1_PartOfSpeech.Gender: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Google_Cloud_Language_V1_PartOfSpeech.Gender] = [
    .unknown,
    .feminine,
    .masculine,
    .neuter,
  ]
}

extension Google_Cloud_Language_V1_PartOfSpeech.Mood: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Google_Cloud_Language_V1_PartOfSpeech.Mood] = [
    .unknown,
    .conditionalMood,
    .imperative,
    .indicative,
    .interrogative,
    .jussive,
    .subjunctive,
  ]
}

extension Google_Cloud_Language_V1_PartOfSpeech.Number: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Google_Cloud_Language_V1_PartOfSpeech.Number] = [
    .unknown,
    .singular,
    .plural,
    .dual,
  ]
}

extension Google_Cloud_Language_V1_PartOfSpeech.Person: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Google_Cloud_Language_V1_PartOfSpeech.Person] = [
    .unknown,
    .first,
    .second,
    .third,
    .reflexivePerson,
  ]
}

extension Google_Cloud_Language_V1_PartOfSpeech.Proper: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Google_Cloud_Language_V1_PartOfSpeech.Proper] = [
    .unknown,
    .proper,
    .notProper,
  ]
}

extension Google_Cloud_Language_V1_PartOfSpeech.Reciprocity: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Google_Cloud_Language_V1_PartOfSpeech.Reciprocity] = [
    .unknown,
    .reciprocal,
    .nonReciprocal,
  ]
}

extension Google_Cloud_Language_V1_PartOfSpeech.Tense: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Google_Cloud_Language_V1_PartOfSpeech.Tense] = [
    .unknown,
    .conditionalTense,
    .future,
    .past,
    .present,
    .imperfect,
    .pluperfect,
  ]
}

extension Google_Cloud_Language_V1_PartOfSpeech.Voice: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Google_Cloud_Language_V1_PartOfSpeech.Voice] = [
    .unknown,
    .active,
    .causative,
    .passive,
  ]
}

#endif  // swift(>=4.2)

/// Represents dependency parse tree information for a token. (For more
/// information on dependency labels, see
/// http://www.aclweb.org/anthology/P13-2017
struct Google_Cloud_Language_V1_DependencyEdge {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Represents the head of this token in the dependency tree.
  /// This is the index of the token which has an arc going to this token.
  /// The index is the position of the token in the array of tokens returned
  /// by the API method. If this token is a root token, then the
  /// `head_token_index` is its own index.
  var headTokenIndex: Int32 = 0

  /// The parse label for the token.
  var label: Google_Cloud_Language_V1_DependencyEdge.Label = .unknown

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The parse label enum for the token.
  enum Label: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Unknown
    case unknown // = 0

    /// Abbreviation modifier
    case abbrev // = 1

    /// Adjectival complement
    case acomp // = 2

    /// Adverbial clause modifier
    case advcl // = 3

    /// Adverbial modifier
    case advmod // = 4

    /// Adjectival modifier of an NP
    case amod // = 5

    /// Appositional modifier of an NP
    case appos // = 6

    /// Attribute dependent of a copular verb
    case attr // = 7

    /// Auxiliary (non-main) verb
    case aux // = 8

    /// Passive auxiliary
    case auxpass // = 9

    /// Coordinating conjunction
    case cc // = 10

    /// Clausal complement of a verb or adjective
    case ccomp // = 11

    /// Conjunct
    case conj // = 12

    /// Clausal subject
    case csubj // = 13

    /// Clausal passive subject
    case csubjpass // = 14

    /// Dependency (unable to determine)
    case dep // = 15

    /// Determiner
    case det // = 16

    /// Discourse
    case discourse // = 17

    /// Direct object
    case dobj // = 18

    /// Expletive
    case expl // = 19

    /// Goes with (part of a word in a text not well edited)
    case goeswith // = 20

    /// Indirect object
    case iobj // = 21

    /// Marker (word introducing a subordinate clause)
    case mark // = 22

    /// Multi-word expression
    case mwe // = 23

    /// Multi-word verbal expression
    case mwv // = 24

    /// Negation modifier
    case neg // = 25

    /// Noun compound modifier
    case nn // = 26

    /// Noun phrase used as an adverbial modifier
    case npadvmod // = 27

    /// Nominal subject
    case nsubj // = 28

    /// Passive nominal subject
    case nsubjpass // = 29

    /// Numeric modifier of a noun
    case num // = 30

    /// Element of compound number
    case number // = 31

    /// Punctuation mark
    case p // = 32

    /// Parataxis relation
    case parataxis // = 33

    /// Participial modifier
    case partmod // = 34

    /// The complement of a preposition is a clause
    case pcomp // = 35

    /// Object of a preposition
    case pobj // = 36

    /// Possession modifier
    case poss // = 37

    /// Postverbal negative particle
    case postneg // = 38

    /// Predicate complement
    case precomp // = 39

    /// Preconjunt
    case preconj // = 40

    /// Predeterminer
    case predet // = 41

    /// Prefix
    case pref // = 42

    /// Prepositional modifier
    case prep // = 43

    /// The relationship between a verb and verbal morpheme
    case pronl // = 44

    /// Particle
    case prt // = 45

    /// Associative or possessive marker
    case ps // = 46

    /// Quantifier phrase modifier
    case quantmod // = 47

    /// Relative clause modifier
    case rcmod // = 48

    /// Complementizer in relative clause
    case rcmodrel // = 49

    /// Ellipsis without a preceding predicate
    case rdrop // = 50

    /// Referent
    case ref // = 51

    /// Remnant
    case remnant // = 52

    /// Reparandum
    case reparandum // = 53

    /// Root
    case root // = 54

    /// Suffix specifying a unit of number
    case snum // = 55

    /// Suffix
    case suff // = 56

    /// Temporal modifier
    case tmod // = 57

    /// Topic marker
    case topic // = 58

    /// Clause headed by an infinite form of the verb that modifies a noun
    case vmod // = 59

    /// Vocative
    case vocative // = 60

    /// Open clausal complement
    case xcomp // = 61

    /// Name suffix
    case suffix // = 62

    /// Name title
    case title // = 63

    /// Adverbial phrase modifier
    case advphmod // = 64

    /// Causative auxiliary
    case auxcaus // = 65

    /// Helper auxiliary
    case auxvv // = 66

    /// Rentaishi (Prenominal modifier)
    case dtmod // = 67

    /// Foreign words
    case foreign // = 68

    /// Keyword
    case kw // = 69

    /// List for chains of comparable items
    case list // = 70

    /// Nominalized clause
    case nomc // = 71

    /// Nominalized clausal subject
    case nomcsubj // = 72

    /// Nominalized clausal passive
    case nomcsubjpass // = 73

    /// Compound of numeric modifier
    case numc // = 74

    /// Copula
    case cop // = 75

    /// Dislocated relation (for fronted/topicalized elements)
    case dislocated // = 76

    /// Aspect marker
    case asp // = 77

    /// Genitive modifier
    case gmod // = 78

    /// Genitive object
    case gobj // = 79

    /// Infinitival modifier
    case infmod // = 80

    /// Measure
    case mes // = 81

    /// Nominal complement of a noun
    case ncomp // = 82
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .abbrev
      case 2: self = .acomp
      case 3: self = .advcl
      case 4: self = .advmod
      case 5: self = .amod
      case 6: self = .appos
      case 7: self = .attr
      case 8: self = .aux
      case 9: self = .auxpass
      case 10: self = .cc
      case 11: self = .ccomp
      case 12: self = .conj
      case 13: self = .csubj
      case 14: self = .csubjpass
      case 15: self = .dep
      case 16: self = .det
      case 17: self = .discourse
      case 18: self = .dobj
      case 19: self = .expl
      case 20: self = .goeswith
      case 21: self = .iobj
      case 22: self = .mark
      case 23: self = .mwe
      case 24: self = .mwv
      case 25: self = .neg
      case 26: self = .nn
      case 27: self = .npadvmod
      case 28: self = .nsubj
      case 29: self = .nsubjpass
      case 30: self = .num
      case 31: self = .number
      case 32: self = .p
      case 33: self = .parataxis
      case 34: self = .partmod
      case 35: self = .pcomp
      case 36: self = .pobj
      case 37: self = .poss
      case 38: self = .postneg
      case 39: self = .precomp
      case 40: self = .preconj
      case 41: self = .predet
      case 42: self = .pref
      case 43: self = .prep
      case 44: self = .pronl
      case 45: self = .prt
      case 46: self = .ps
      case 47: self = .quantmod
      case 48: self = .rcmod
      case 49: self = .rcmodrel
      case 50: self = .rdrop
      case 51: self = .ref
      case 52: self = .remnant
      case 53: self = .reparandum
      case 54: self = .root
      case 55: self = .snum
      case 56: self = .suff
      case 57: self = .tmod
      case 58: self = .topic
      case 59: self = .vmod
      case 60: self = .vocative
      case 61: self = .xcomp
      case 62: self = .suffix
      case 63: self = .title
      case 64: self = .advphmod
      case 65: self = .auxcaus
      case 66: self = .auxvv
      case 67: self = .dtmod
      case 68: self = .foreign
      case 69: self = .kw
      case 70: self = .list
      case 71: self = .nomc
      case 72: self = .nomcsubj
      case 73: self = .nomcsubjpass
      case 74: self = .numc
      case 75: self = .cop
      case 76: self = .dislocated
      case 77: self = .asp
      case 78: self = .gmod
      case 79: self = .gobj
      case 80: self = .infmod
      case 81: self = .mes
      case 82: self = .ncomp
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .abbrev: return 1
      case .acomp: return 2
      case .advcl: return 3
      case .advmod: return 4
      case .amod: return 5
      case .appos: return 6
      case .attr: return 7
      case .aux: return 8
      case .auxpass: return 9
      case .cc: return 10
      case .ccomp: return 11
      case .conj: return 12
      case .csubj: return 13
      case .csubjpass: return 14
      case .dep: return 15
      case .det: return 16
      case .discourse: return 17
      case .dobj: return 18
      case .expl: return 19
      case .goeswith: return 20
      case .iobj: return 21
      case .mark: return 22
      case .mwe: return 23
      case .mwv: return 24
      case .neg: return 25
      case .nn: return 26
      case .npadvmod: return 27
      case .nsubj: return 28
      case .nsubjpass: return 29
      case .num: return 30
      case .number: return 31
      case .p: return 32
      case .parataxis: return 33
      case .partmod: return 34
      case .pcomp: return 35
      case .pobj: return 36
      case .poss: return 37
      case .postneg: return 38
      case .precomp: return 39
      case .preconj: return 40
      case .predet: return 41
      case .pref: return 42
      case .prep: return 43
      case .pronl: return 44
      case .prt: return 45
      case .ps: return 46
      case .quantmod: return 47
      case .rcmod: return 48
      case .rcmodrel: return 49
      case .rdrop: return 50
      case .ref: return 51
      case .remnant: return 52
      case .reparandum: return 53
      case .root: return 54
      case .snum: return 55
      case .suff: return 56
      case .tmod: return 57
      case .topic: return 58
      case .vmod: return 59
      case .vocative: return 60
      case .xcomp: return 61
      case .suffix: return 62
      case .title: return 63
      case .advphmod: return 64
      case .auxcaus: return 65
      case .auxvv: return 66
      case .dtmod: return 67
      case .foreign: return 68
      case .kw: return 69
      case .list: return 70
      case .nomc: return 71
      case .nomcsubj: return 72
      case .nomcsubjpass: return 73
      case .numc: return 74
      case .cop: return 75
      case .dislocated: return 76
      case .asp: return 77
      case .gmod: return 78
      case .gobj: return 79
      case .infmod: return 80
      case .mes: return 81
      case .ncomp: return 82
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Google_Cloud_Language_V1_DependencyEdge.Label: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Google_Cloud_Language_V1_DependencyEdge.Label] = [
    .unknown,
    .abbrev,
    .acomp,
    .advcl,
    .advmod,
    .amod,
    .appos,
    .attr,
    .aux,
    .auxpass,
    .cc,
    .ccomp,
    .conj,
    .csubj,
    .csubjpass,
    .dep,
    .det,
    .discourse,
    .dobj,
    .expl,
    .goeswith,
    .iobj,
    .mark,
    .mwe,
    .mwv,
    .neg,
    .nn,
    .npadvmod,
    .nsubj,
    .nsubjpass,
    .num,
    .number,
    .p,
    .parataxis,
    .partmod,
    .pcomp,
    .pobj,
    .poss,
    .postneg,
    .precomp,
    .preconj,
    .predet,
    .pref,
    .prep,
    .pronl,
    .prt,
    .ps,
    .quantmod,
    .rcmod,
    .rcmodrel,
    .rdrop,
    .ref,
    .remnant,
    .reparandum,
    .root,
    .snum,
    .suff,
    .tmod,
    .topic,
    .vmod,
    .vocative,
    .xcomp,
    .suffix,
    .title,
    .advphmod,
    .auxcaus,
    .auxvv,
    .dtmod,
    .foreign,
    .kw,
    .list,
    .nomc,
    .nomcsubj,
    .nomcsubjpass,
    .numc,
    .cop,
    .dislocated,
    .asp,
    .gmod,
    .gobj,
    .infmod,
    .mes,
    .ncomp,
  ]
}

#endif  // swift(>=4.2)

/// Represents a mention for an entity in the text. Currently, proper noun
/// mentions are supported.
struct Google_Cloud_Language_V1_EntityMention {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The mention text.
  var text: Google_Cloud_Language_V1_TextSpan {
    get {return _text ?? Google_Cloud_Language_V1_TextSpan()}
    set {_text = newValue}
  }
  /// Returns true if `text` has been explicitly set.
  var hasText: Bool {return self._text != nil}
  /// Clears the value of `text`. Subsequent reads from it will return its default value.
  mutating func clearText() {self._text = nil}

  /// The type of the entity mention.
  var type: Google_Cloud_Language_V1_EntityMention.TypeEnum = .unknown

  /// For calls to [AnalyzeEntitySentiment][] or if
  /// [AnnotateTextRequest.Features.extract_entity_sentiment][google.cloud.language.v1.AnnotateTextRequest.Features.extract_entity_sentiment]
  /// is set to true, this field will contain the sentiment expressed for this
  /// mention of the entity in the provided document.
  var sentiment: Google_Cloud_Language_V1_Sentiment {
    get {return _sentiment ?? Google_Cloud_Language_V1_Sentiment()}
    set {_sentiment = newValue}
  }
  /// Returns true if `sentiment` has been explicitly set.
  var hasSentiment: Bool {return self._sentiment != nil}
  /// Clears the value of `sentiment`. Subsequent reads from it will return its default value.
  mutating func clearSentiment() {self._sentiment = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The supported types of mentions.
  enum TypeEnum: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Unknown
    case unknown // = 0

    /// Proper name
    case proper // = 1

    /// Common noun (or noun compound)
    case common // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .proper
      case 2: self = .common
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .proper: return 1
      case .common: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _text: Google_Cloud_Language_V1_TextSpan? = nil
  fileprivate var _sentiment: Google_Cloud_Language_V1_Sentiment? = nil
}

#if swift(>=4.2)

extension Google_Cloud_Language_V1_EntityMention.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Google_Cloud_Language_V1_EntityMention.TypeEnum] = [
    .unknown,
    .proper,
    .common,
  ]
}

#endif  // swift(>=4.2)

/// Represents an output piece of text.
struct Google_Cloud_Language_V1_TextSpan {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The content of the output text.
  var content: String = String()

  /// The API calculates the beginning offset of the content in the original
  /// document according to the
  /// [EncodingType][google.cloud.language.v1.EncodingType] specified in the API
  /// request.
  var beginOffset: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Represents a category returned from the text classifier.
struct Google_Cloud_Language_V1_ClassificationCategory {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the category representing the document, from the [predefined
  /// taxonomy](https://cloud.google.com/natural-language/docs/categories).
  var name: String = String()

  /// The classifier's confidence of the category. Number represents how certain
  /// the classifier is that this category represents the given text.
  var confidence: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Model options available for classification requests.
struct Google_Cloud_Language_V1_ClassificationModelOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If this field is not set, then the `v1_model` will be used by default.
  var modelType: Google_Cloud_Language_V1_ClassificationModelOptions.OneOf_ModelType? = nil

  /// Setting this field will use the V1 model and V1 content categories
  /// version. The V1 model is a legacy model; support for this will be
  /// discontinued in the future.
  var v1Model: Google_Cloud_Language_V1_ClassificationModelOptions.V1Model {
    get {
      if case .v1Model(let v)? = modelType {return v}
      return Google_Cloud_Language_V1_ClassificationModelOptions.V1Model()
    }
    set {modelType = .v1Model(newValue)}
  }

  /// Setting this field will use the V2 model with the appropriate content
  /// categories version. The V2 model is a better performing model.
  var v2Model: Google_Cloud_Language_V1_ClassificationModelOptions.V2Model {
    get {
      if case .v2Model(let v)? = modelType {return v}
      return Google_Cloud_Language_V1_ClassificationModelOptions.V2Model()
    }
    set {modelType = .v2Model(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// If this field is not set, then the `v1_model` will be used by default.
  enum OneOf_ModelType: Equatable {
    /// Setting this field will use the V1 model and V1 content categories
    /// version. The V1 model is a legacy model; support for this will be
    /// discontinued in the future.
    case v1Model(Google_Cloud_Language_V1_ClassificationModelOptions.V1Model)
    /// Setting this field will use the V2 model with the appropriate content
    /// categories version. The V2 model is a better performing model.
    case v2Model(Google_Cloud_Language_V1_ClassificationModelOptions.V2Model)

  #if !swift(>=4.1)
    static func ==(lhs: Google_Cloud_Language_V1_ClassificationModelOptions.OneOf_ModelType, rhs: Google_Cloud_Language_V1_ClassificationModelOptions.OneOf_ModelType) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.v1Model, .v1Model): return {
        guard case .v1Model(let l) = lhs, case .v1Model(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.v2Model, .v2Model): return {
        guard case .v2Model(let l) = lhs, case .v2Model(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// Options for the V1 model.
  struct V1Model {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Options for the V2 model.
  struct V2Model {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The content categories used for classification.
    var contentCategoriesVersion: Google_Cloud_Language_V1_ClassificationModelOptions.V2Model.ContentCategoriesVersion = .unspecified

    var unknownFields = SwiftProtobuf.UnknownStorage()

    /// The content categories used for classification.
    enum ContentCategoriesVersion: SwiftProtobuf.Enum {
      typealias RawValue = Int

      /// If `ContentCategoriesVersion` is not specified, this option will
      /// default to `V1`.
      case unspecified // = 0

      /// Legacy content categories of our initial launch in 2017.
      case v1 // = 1

      /// Updated content categories in 2022.
      case v2 // = 2
      case UNRECOGNIZED(Int)

      init() {
        self = .unspecified
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unspecified
        case 1: self = .v1
        case 2: self = .v2
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .unspecified: return 0
        case .v1: return 1
        case .v2: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    init() {}
  }

  init() {}
}

#if swift(>=4.2)

extension Google_Cloud_Language_V1_ClassificationModelOptions.V2Model.ContentCategoriesVersion: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Google_Cloud_Language_V1_ClassificationModelOptions.V2Model.ContentCategoriesVersion] = [
    .unspecified,
    .v1,
    .v2,
  ]
}

#endif  // swift(>=4.2)

/// The sentiment analysis request message.
struct Google_Cloud_Language_V1_AnalyzeSentimentRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Input document.
  var document: Google_Cloud_Language_V1_Document {
    get {return _document ?? Google_Cloud_Language_V1_Document()}
    set {_document = newValue}
  }
  /// Returns true if `document` has been explicitly set.
  var hasDocument: Bool {return self._document != nil}
  /// Clears the value of `document`. Subsequent reads from it will return its default value.
  mutating func clearDocument() {self._document = nil}

  /// The encoding type used by the API to calculate sentence offsets.
  var encodingType: Google_Cloud_Language_V1_EncodingType = .none

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _document: Google_Cloud_Language_V1_Document? = nil
}

/// The sentiment analysis response message.
struct Google_Cloud_Language_V1_AnalyzeSentimentResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The overall sentiment of the input document.
  var documentSentiment: Google_Cloud_Language_V1_Sentiment {
    get {return _documentSentiment ?? Google_Cloud_Language_V1_Sentiment()}
    set {_documentSentiment = newValue}
  }
  /// Returns true if `documentSentiment` has been explicitly set.
  var hasDocumentSentiment: Bool {return self._documentSentiment != nil}
  /// Clears the value of `documentSentiment`. Subsequent reads from it will return its default value.
  mutating func clearDocumentSentiment() {self._documentSentiment = nil}

  /// The language of the text, which will be the same as the language specified
  /// in the request or, if not specified, the automatically-detected language.
  /// See [Document.language][google.cloud.language.v1.Document.language] field
  /// for more details.
  var language: String = String()

  /// The sentiment for all the sentences in the document.
  var sentences: [Google_Cloud_Language_V1_Sentence] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _documentSentiment: Google_Cloud_Language_V1_Sentiment? = nil
}

/// The entity-level sentiment analysis request message.
struct Google_Cloud_Language_V1_AnalyzeEntitySentimentRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Input document.
  var document: Google_Cloud_Language_V1_Document {
    get {return _document ?? Google_Cloud_Language_V1_Document()}
    set {_document = newValue}
  }
  /// Returns true if `document` has been explicitly set.
  var hasDocument: Bool {return self._document != nil}
  /// Clears the value of `document`. Subsequent reads from it will return its default value.
  mutating func clearDocument() {self._document = nil}

  /// The encoding type used by the API to calculate offsets.
  var encodingType: Google_Cloud_Language_V1_EncodingType = .none

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _document: Google_Cloud_Language_V1_Document? = nil
}

/// The entity-level sentiment analysis response message.
struct Google_Cloud_Language_V1_AnalyzeEntitySentimentResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The recognized entities in the input document with associated sentiments.
  var entities: [Google_Cloud_Language_V1_Entity] = []

  /// The language of the text, which will be the same as the language specified
  /// in the request or, if not specified, the automatically-detected language.
  /// See [Document.language][google.cloud.language.v1.Document.language] field
  /// for more details.
  var language: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The entity analysis request message.
struct Google_Cloud_Language_V1_AnalyzeEntitiesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Input document.
  var document: Google_Cloud_Language_V1_Document {
    get {return _document ?? Google_Cloud_Language_V1_Document()}
    set {_document = newValue}
  }
  /// Returns true if `document` has been explicitly set.
  var hasDocument: Bool {return self._document != nil}
  /// Clears the value of `document`. Subsequent reads from it will return its default value.
  mutating func clearDocument() {self._document = nil}

  /// The encoding type used by the API to calculate offsets.
  var encodingType: Google_Cloud_Language_V1_EncodingType = .none

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _document: Google_Cloud_Language_V1_Document? = nil
}

/// The entity analysis response message.
struct Google_Cloud_Language_V1_AnalyzeEntitiesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The recognized entities in the input document.
  var entities: [Google_Cloud_Language_V1_Entity] = []

  /// The language of the text, which will be the same as the language specified
  /// in the request or, if not specified, the automatically-detected language.
  /// See [Document.language][google.cloud.language.v1.Document.language] field
  /// for more details.
  var language: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The syntax analysis request message.
struct Google_Cloud_Language_V1_AnalyzeSyntaxRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Input document.
  var document: Google_Cloud_Language_V1_Document {
    get {return _document ?? Google_Cloud_Language_V1_Document()}
    set {_document = newValue}
  }
  /// Returns true if `document` has been explicitly set.
  var hasDocument: Bool {return self._document != nil}
  /// Clears the value of `document`. Subsequent reads from it will return its default value.
  mutating func clearDocument() {self._document = nil}

  /// The encoding type used by the API to calculate offsets.
  var encodingType: Google_Cloud_Language_V1_EncodingType = .none

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _document: Google_Cloud_Language_V1_Document? = nil
}

/// The syntax analysis response message.
struct Google_Cloud_Language_V1_AnalyzeSyntaxResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Sentences in the input document.
  var sentences: [Google_Cloud_Language_V1_Sentence] = []

  /// Tokens, along with their syntactic information, in the input document.
  var tokens: [Google_Cloud_Language_V1_Token] = []

  /// The language of the text, which will be the same as the language specified
  /// in the request or, if not specified, the automatically-detected language.
  /// See [Document.language][google.cloud.language.v1.Document.language] field
  /// for more details.
  var language: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The document classification request message.
struct Google_Cloud_Language_V1_ClassifyTextRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Input document.
  var document: Google_Cloud_Language_V1_Document {
    get {return _document ?? Google_Cloud_Language_V1_Document()}
    set {_document = newValue}
  }
  /// Returns true if `document` has been explicitly set.
  var hasDocument: Bool {return self._document != nil}
  /// Clears the value of `document`. Subsequent reads from it will return its default value.
  mutating func clearDocument() {self._document = nil}

  /// Model options to use for classification. Defaults to v1 options if not
  /// specified.
  var classificationModelOptions: Google_Cloud_Language_V1_ClassificationModelOptions {
    get {return _classificationModelOptions ?? Google_Cloud_Language_V1_ClassificationModelOptions()}
    set {_classificationModelOptions = newValue}
  }
  /// Returns true if `classificationModelOptions` has been explicitly set.
  var hasClassificationModelOptions: Bool {return self._classificationModelOptions != nil}
  /// Clears the value of `classificationModelOptions`. Subsequent reads from it will return its default value.
  mutating func clearClassificationModelOptions() {self._classificationModelOptions = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _document: Google_Cloud_Language_V1_Document? = nil
  fileprivate var _classificationModelOptions: Google_Cloud_Language_V1_ClassificationModelOptions? = nil
}

/// The document classification response message.
struct Google_Cloud_Language_V1_ClassifyTextResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Categories representing the input document.
  var categories: [Google_Cloud_Language_V1_ClassificationCategory] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The request message for the text annotation API, which can perform multiple
/// analysis types (sentiment, entities, and syntax) in one call.
struct Google_Cloud_Language_V1_AnnotateTextRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Input document.
  var document: Google_Cloud_Language_V1_Document {
    get {return _document ?? Google_Cloud_Language_V1_Document()}
    set {_document = newValue}
  }
  /// Returns true if `document` has been explicitly set.
  var hasDocument: Bool {return self._document != nil}
  /// Clears the value of `document`. Subsequent reads from it will return its default value.
  mutating func clearDocument() {self._document = nil}

  /// Required. The enabled features.
  var features: Google_Cloud_Language_V1_AnnotateTextRequest.Features {
    get {return _features ?? Google_Cloud_Language_V1_AnnotateTextRequest.Features()}
    set {_features = newValue}
  }
  /// Returns true if `features` has been explicitly set.
  var hasFeatures: Bool {return self._features != nil}
  /// Clears the value of `features`. Subsequent reads from it will return its default value.
  mutating func clearFeatures() {self._features = nil}

  /// The encoding type used by the API to calculate offsets.
  var encodingType: Google_Cloud_Language_V1_EncodingType = .none

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// All available features for sentiment, syntax, and semantic analysis.
  /// Setting each one to true will enable that specific analysis for the input.
  struct Features {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Extract syntax information.
    var extractSyntax: Bool = false

    /// Extract entities.
    var extractEntities: Bool = false

    /// Extract document-level sentiment.
    var extractDocumentSentiment: Bool = false

    /// Extract entities and their associated sentiment.
    var extractEntitySentiment: Bool = false

    /// Classify the full document into categories.
    var classifyText: Bool = false

    /// The model options to use for classification. Defaults to v1 options
    /// if not specified. Only used if `classify_text` is set to true.
    var classificationModelOptions: Google_Cloud_Language_V1_ClassificationModelOptions {
      get {return _classificationModelOptions ?? Google_Cloud_Language_V1_ClassificationModelOptions()}
      set {_classificationModelOptions = newValue}
    }
    /// Returns true if `classificationModelOptions` has been explicitly set.
    var hasClassificationModelOptions: Bool {return self._classificationModelOptions != nil}
    /// Clears the value of `classificationModelOptions`. Subsequent reads from it will return its default value.
    mutating func clearClassificationModelOptions() {self._classificationModelOptions = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _classificationModelOptions: Google_Cloud_Language_V1_ClassificationModelOptions? = nil
  }

  init() {}

  fileprivate var _document: Google_Cloud_Language_V1_Document? = nil
  fileprivate var _features: Google_Cloud_Language_V1_AnnotateTextRequest.Features? = nil
}

/// The text annotations response message.
struct Google_Cloud_Language_V1_AnnotateTextResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Sentences in the input document. Populated if the user enables
  /// [AnnotateTextRequest.Features.extract_syntax][google.cloud.language.v1.AnnotateTextRequest.Features.extract_syntax].
  var sentences: [Google_Cloud_Language_V1_Sentence] = []

  /// Tokens, along with their syntactic information, in the input document.
  /// Populated if the user enables
  /// [AnnotateTextRequest.Features.extract_syntax][google.cloud.language.v1.AnnotateTextRequest.Features.extract_syntax].
  var tokens: [Google_Cloud_Language_V1_Token] = []

  /// Entities, along with their semantic information, in the input document.
  /// Populated if the user enables
  /// [AnnotateTextRequest.Features.extract_entities][google.cloud.language.v1.AnnotateTextRequest.Features.extract_entities].
  var entities: [Google_Cloud_Language_V1_Entity] = []

  /// The overall sentiment for the document. Populated if the user enables
  /// [AnnotateTextRequest.Features.extract_document_sentiment][google.cloud.language.v1.AnnotateTextRequest.Features.extract_document_sentiment].
  var documentSentiment: Google_Cloud_Language_V1_Sentiment {
    get {return _documentSentiment ?? Google_Cloud_Language_V1_Sentiment()}
    set {_documentSentiment = newValue}
  }
  /// Returns true if `documentSentiment` has been explicitly set.
  var hasDocumentSentiment: Bool {return self._documentSentiment != nil}
  /// Clears the value of `documentSentiment`. Subsequent reads from it will return its default value.
  mutating func clearDocumentSentiment() {self._documentSentiment = nil}

  /// The language of the text, which will be the same as the language specified
  /// in the request or, if not specified, the automatically-detected language.
  /// See [Document.language][google.cloud.language.v1.Document.language] field
  /// for more details.
  var language: String = String()

  /// Categories identified in the input document.
  var categories: [Google_Cloud_Language_V1_ClassificationCategory] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _documentSentiment: Google_Cloud_Language_V1_Sentiment? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Google_Cloud_Language_V1_EncodingType: @unchecked Sendable {}
extension Google_Cloud_Language_V1_Document: @unchecked Sendable {}
extension Google_Cloud_Language_V1_Document.OneOf_Source: @unchecked Sendable {}
extension Google_Cloud_Language_V1_Document.TypeEnum: @unchecked Sendable {}
extension Google_Cloud_Language_V1_Sentence: @unchecked Sendable {}
extension Google_Cloud_Language_V1_Entity: @unchecked Sendable {}
extension Google_Cloud_Language_V1_Entity.TypeEnum: @unchecked Sendable {}
extension Google_Cloud_Language_V1_Token: @unchecked Sendable {}
extension Google_Cloud_Language_V1_Sentiment: @unchecked Sendable {}
extension Google_Cloud_Language_V1_PartOfSpeech: @unchecked Sendable {}
extension Google_Cloud_Language_V1_PartOfSpeech.Tag: @unchecked Sendable {}
extension Google_Cloud_Language_V1_PartOfSpeech.Aspect: @unchecked Sendable {}
extension Google_Cloud_Language_V1_PartOfSpeech.Case: @unchecked Sendable {}
extension Google_Cloud_Language_V1_PartOfSpeech.Form: @unchecked Sendable {}
extension Google_Cloud_Language_V1_PartOfSpeech.Gender: @unchecked Sendable {}
extension Google_Cloud_Language_V1_PartOfSpeech.Mood: @unchecked Sendable {}
extension Google_Cloud_Language_V1_PartOfSpeech.Number: @unchecked Sendable {}
extension Google_Cloud_Language_V1_PartOfSpeech.Person: @unchecked Sendable {}
extension Google_Cloud_Language_V1_PartOfSpeech.Proper: @unchecked Sendable {}
extension Google_Cloud_Language_V1_PartOfSpeech.Reciprocity: @unchecked Sendable {}
extension Google_Cloud_Language_V1_PartOfSpeech.Tense: @unchecked Sendable {}
extension Google_Cloud_Language_V1_PartOfSpeech.Voice: @unchecked Sendable {}
extension Google_Cloud_Language_V1_DependencyEdge: @unchecked Sendable {}
extension Google_Cloud_Language_V1_DependencyEdge.Label: @unchecked Sendable {}
extension Google_Cloud_Language_V1_EntityMention: @unchecked Sendable {}
extension Google_Cloud_Language_V1_EntityMention.TypeEnum: @unchecked Sendable {}
extension Google_Cloud_Language_V1_TextSpan: @unchecked Sendable {}
extension Google_Cloud_Language_V1_ClassificationCategory: @unchecked Sendable {}
extension Google_Cloud_Language_V1_ClassificationModelOptions: @unchecked Sendable {}
extension Google_Cloud_Language_V1_ClassificationModelOptions.OneOf_ModelType: @unchecked Sendable {}
extension Google_Cloud_Language_V1_ClassificationModelOptions.V1Model: @unchecked Sendable {}
extension Google_Cloud_Language_V1_ClassificationModelOptions.V2Model: @unchecked Sendable {}
extension Google_Cloud_Language_V1_ClassificationModelOptions.V2Model.ContentCategoriesVersion: @unchecked Sendable {}
extension Google_Cloud_Language_V1_AnalyzeSentimentRequest: @unchecked Sendable {}
extension Google_Cloud_Language_V1_AnalyzeSentimentResponse: @unchecked Sendable {}
extension Google_Cloud_Language_V1_AnalyzeEntitySentimentRequest: @unchecked Sendable {}
extension Google_Cloud_Language_V1_AnalyzeEntitySentimentResponse: @unchecked Sendable {}
extension Google_Cloud_Language_V1_AnalyzeEntitiesRequest: @unchecked Sendable {}
extension Google_Cloud_Language_V1_AnalyzeEntitiesResponse: @unchecked Sendable {}
extension Google_Cloud_Language_V1_AnalyzeSyntaxRequest: @unchecked Sendable {}
extension Google_Cloud_Language_V1_AnalyzeSyntaxResponse: @unchecked Sendable {}
extension Google_Cloud_Language_V1_ClassifyTextRequest: @unchecked Sendable {}
extension Google_Cloud_Language_V1_ClassifyTextResponse: @unchecked Sendable {}
extension Google_Cloud_Language_V1_AnnotateTextRequest: @unchecked Sendable {}
extension Google_Cloud_Language_V1_AnnotateTextRequest.Features: @unchecked Sendable {}
extension Google_Cloud_Language_V1_AnnotateTextResponse: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.language.v1"

extension Google_Cloud_Language_V1_EncodingType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NONE"),
    1: .same(proto: "UTF8"),
    2: .same(proto: "UTF16"),
    3: .same(proto: "UTF32"),
  ]
}

extension Google_Cloud_Language_V1_Document: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Document"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "content"),
    3: .standard(proto: "gcs_content_uri"),
    4: .same(proto: "language"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.source != nil {try decoder.handleConflictingOneOf()}
          self.source = .content(v)
        }
      }()
      case 3: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.source != nil {try decoder.handleConflictingOneOf()}
          self.source = .gcsContentUri(v)
        }
      }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.language) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.type != .unspecified {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    switch self.source {
    case .content?: try {
      guard case .content(let v)? = self.source else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case .gcsContentUri?: try {
      guard case .gcsContentUri(let v)? = self.source else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    if !self.language.isEmpty {
      try visitor.visitSingularStringField(value: self.language, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Language_V1_Document, rhs: Google_Cloud_Language_V1_Document) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.source != rhs.source {return false}
    if lhs.language != rhs.language {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Language_V1_Document.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TYPE_UNSPECIFIED"),
    1: .same(proto: "PLAIN_TEXT"),
    2: .same(proto: "HTML"),
  ]
}

extension Google_Cloud_Language_V1_Sentence: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Sentence"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .same(proto: "sentiment"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._text) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._sentiment) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._text {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._sentiment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Language_V1_Sentence, rhs: Google_Cloud_Language_V1_Sentence) -> Bool {
    if lhs._text != rhs._text {return false}
    if lhs._sentiment != rhs._sentiment {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Language_V1_Entity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Entity"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "type"),
    3: .same(proto: "metadata"),
    4: .same(proto: "salience"),
    5: .same(proto: "mentions"),
    6: .same(proto: "sentiment"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.metadata) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.salience) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.mentions) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._sentiment) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.type != .unknown {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    if !self.metadata.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.metadata, fieldNumber: 3)
    }
    if self.salience != 0 {
      try visitor.visitSingularFloatField(value: self.salience, fieldNumber: 4)
    }
    if !self.mentions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.mentions, fieldNumber: 5)
    }
    try { if let v = self._sentiment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Language_V1_Entity, rhs: Google_Cloud_Language_V1_Entity) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.type != rhs.type {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.salience != rhs.salience {return false}
    if lhs.mentions != rhs.mentions {return false}
    if lhs._sentiment != rhs._sentiment {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Language_V1_Entity.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "PERSON"),
    2: .same(proto: "LOCATION"),
    3: .same(proto: "ORGANIZATION"),
    4: .same(proto: "EVENT"),
    5: .same(proto: "WORK_OF_ART"),
    6: .same(proto: "CONSUMER_GOOD"),
    7: .same(proto: "OTHER"),
    9: .same(proto: "PHONE_NUMBER"),
    10: .same(proto: "ADDRESS"),
    11: .same(proto: "DATE"),
    12: .same(proto: "NUMBER"),
    13: .same(proto: "PRICE"),
  ]
}

extension Google_Cloud_Language_V1_Token: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Token"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .standard(proto: "part_of_speech"),
    3: .standard(proto: "dependency_edge"),
    4: .same(proto: "lemma"),
  ]

  fileprivate class _StorageClass {
    var _text: Google_Cloud_Language_V1_TextSpan? = nil
    var _partOfSpeech: Google_Cloud_Language_V1_PartOfSpeech? = nil
    var _dependencyEdge: Google_Cloud_Language_V1_DependencyEdge? = nil
    var _lemma: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _text = source._text
      _partOfSpeech = source._partOfSpeech
      _dependencyEdge = source._dependencyEdge
      _lemma = source._lemma
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._text) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._partOfSpeech) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._dependencyEdge) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._lemma) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._text {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._partOfSpeech {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._dependencyEdge {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._lemma.isEmpty {
        try visitor.visitSingularStringField(value: _storage._lemma, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Language_V1_Token, rhs: Google_Cloud_Language_V1_Token) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._text != rhs_storage._text {return false}
        if _storage._partOfSpeech != rhs_storage._partOfSpeech {return false}
        if _storage._dependencyEdge != rhs_storage._dependencyEdge {return false}
        if _storage._lemma != rhs_storage._lemma {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Language_V1_Sentiment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Sentiment"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "magnitude"),
    3: .same(proto: "score"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularFloatField(value: &self.magnitude) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.score) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.magnitude != 0 {
      try visitor.visitSingularFloatField(value: self.magnitude, fieldNumber: 2)
    }
    if self.score != 0 {
      try visitor.visitSingularFloatField(value: self.score, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Language_V1_Sentiment, rhs: Google_Cloud_Language_V1_Sentiment) -> Bool {
    if lhs.magnitude != rhs.magnitude {return false}
    if lhs.score != rhs.score {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Language_V1_PartOfSpeech: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PartOfSpeech"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tag"),
    2: .same(proto: "aspect"),
    3: .same(proto: "case"),
    4: .same(proto: "form"),
    5: .same(proto: "gender"),
    6: .same(proto: "mood"),
    7: .same(proto: "number"),
    8: .same(proto: "person"),
    9: .same(proto: "proper"),
    10: .same(proto: "reciprocity"),
    11: .same(proto: "tense"),
    12: .same(proto: "voice"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.tag) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.aspect) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.`case`) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.form) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.gender) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.mood) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.number) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.person) }()
      case 9: try { try decoder.decodeSingularEnumField(value: &self.proper) }()
      case 10: try { try decoder.decodeSingularEnumField(value: &self.reciprocity) }()
      case 11: try { try decoder.decodeSingularEnumField(value: &self.tense) }()
      case 12: try { try decoder.decodeSingularEnumField(value: &self.voice) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.tag != .unknown {
      try visitor.visitSingularEnumField(value: self.tag, fieldNumber: 1)
    }
    if self.aspect != .unknown {
      try visitor.visitSingularEnumField(value: self.aspect, fieldNumber: 2)
    }
    if self.`case` != .unknown {
      try visitor.visitSingularEnumField(value: self.`case`, fieldNumber: 3)
    }
    if self.form != .unknown {
      try visitor.visitSingularEnumField(value: self.form, fieldNumber: 4)
    }
    if self.gender != .unknown {
      try visitor.visitSingularEnumField(value: self.gender, fieldNumber: 5)
    }
    if self.mood != .unknown {
      try visitor.visitSingularEnumField(value: self.mood, fieldNumber: 6)
    }
    if self.number != .unknown {
      try visitor.visitSingularEnumField(value: self.number, fieldNumber: 7)
    }
    if self.person != .unknown {
      try visitor.visitSingularEnumField(value: self.person, fieldNumber: 8)
    }
    if self.proper != .unknown {
      try visitor.visitSingularEnumField(value: self.proper, fieldNumber: 9)
    }
    if self.reciprocity != .unknown {
      try visitor.visitSingularEnumField(value: self.reciprocity, fieldNumber: 10)
    }
    if self.tense != .unknown {
      try visitor.visitSingularEnumField(value: self.tense, fieldNumber: 11)
    }
    if self.voice != .unknown {
      try visitor.visitSingularEnumField(value: self.voice, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Language_V1_PartOfSpeech, rhs: Google_Cloud_Language_V1_PartOfSpeech) -> Bool {
    if lhs.tag != rhs.tag {return false}
    if lhs.aspect != rhs.aspect {return false}
    if lhs.`case` != rhs.`case` {return false}
    if lhs.form != rhs.form {return false}
    if lhs.gender != rhs.gender {return false}
    if lhs.mood != rhs.mood {return false}
    if lhs.number != rhs.number {return false}
    if lhs.person != rhs.person {return false}
    if lhs.proper != rhs.proper {return false}
    if lhs.reciprocity != rhs.reciprocity {return false}
    if lhs.tense != rhs.tense {return false}
    if lhs.voice != rhs.voice {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Language_V1_PartOfSpeech.Tag: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "ADJ"),
    2: .same(proto: "ADP"),
    3: .same(proto: "ADV"),
    4: .same(proto: "CONJ"),
    5: .same(proto: "DET"),
    6: .same(proto: "NOUN"),
    7: .same(proto: "NUM"),
    8: .same(proto: "PRON"),
    9: .same(proto: "PRT"),
    10: .same(proto: "PUNCT"),
    11: .same(proto: "VERB"),
    12: .same(proto: "X"),
    13: .same(proto: "AFFIX"),
  ]
}

extension Google_Cloud_Language_V1_PartOfSpeech.Aspect: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ASPECT_UNKNOWN"),
    1: .same(proto: "PERFECTIVE"),
    2: .same(proto: "IMPERFECTIVE"),
    3: .same(proto: "PROGRESSIVE"),
  ]
}

extension Google_Cloud_Language_V1_PartOfSpeech.Case: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CASE_UNKNOWN"),
    1: .same(proto: "ACCUSATIVE"),
    2: .same(proto: "ADVERBIAL"),
    3: .same(proto: "COMPLEMENTIVE"),
    4: .same(proto: "DATIVE"),
    5: .same(proto: "GENITIVE"),
    6: .same(proto: "INSTRUMENTAL"),
    7: .same(proto: "LOCATIVE"),
    8: .same(proto: "NOMINATIVE"),
    9: .same(proto: "OBLIQUE"),
    10: .same(proto: "PARTITIVE"),
    11: .same(proto: "PREPOSITIONAL"),
    12: .same(proto: "REFLEXIVE_CASE"),
    13: .same(proto: "RELATIVE_CASE"),
    14: .same(proto: "VOCATIVE"),
  ]
}

extension Google_Cloud_Language_V1_PartOfSpeech.Form: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FORM_UNKNOWN"),
    1: .same(proto: "ADNOMIAL"),
    2: .same(proto: "AUXILIARY"),
    3: .same(proto: "COMPLEMENTIZER"),
    4: .same(proto: "FINAL_ENDING"),
    5: .same(proto: "GERUND"),
    6: .same(proto: "REALIS"),
    7: .same(proto: "IRREALIS"),
    8: .same(proto: "SHORT"),
    9: .same(proto: "LONG"),
    10: .same(proto: "ORDER"),
    11: .same(proto: "SPECIFIC"),
  ]
}

extension Google_Cloud_Language_V1_PartOfSpeech.Gender: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "GENDER_UNKNOWN"),
    1: .same(proto: "FEMININE"),
    2: .same(proto: "MASCULINE"),
    3: .same(proto: "NEUTER"),
  ]
}

extension Google_Cloud_Language_V1_PartOfSpeech.Mood: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MOOD_UNKNOWN"),
    1: .same(proto: "CONDITIONAL_MOOD"),
    2: .same(proto: "IMPERATIVE"),
    3: .same(proto: "INDICATIVE"),
    4: .same(proto: "INTERROGATIVE"),
    5: .same(proto: "JUSSIVE"),
    6: .same(proto: "SUBJUNCTIVE"),
  ]
}

extension Google_Cloud_Language_V1_PartOfSpeech.Number: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NUMBER_UNKNOWN"),
    1: .same(proto: "SINGULAR"),
    2: .same(proto: "PLURAL"),
    3: .same(proto: "DUAL"),
  ]
}

extension Google_Cloud_Language_V1_PartOfSpeech.Person: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PERSON_UNKNOWN"),
    1: .same(proto: "FIRST"),
    2: .same(proto: "SECOND"),
    3: .same(proto: "THIRD"),
    4: .same(proto: "REFLEXIVE_PERSON"),
  ]
}

extension Google_Cloud_Language_V1_PartOfSpeech.Proper: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PROPER_UNKNOWN"),
    1: .same(proto: "PROPER"),
    2: .same(proto: "NOT_PROPER"),
  ]
}

extension Google_Cloud_Language_V1_PartOfSpeech.Reciprocity: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RECIPROCITY_UNKNOWN"),
    1: .same(proto: "RECIPROCAL"),
    2: .same(proto: "NON_RECIPROCAL"),
  ]
}

extension Google_Cloud_Language_V1_PartOfSpeech.Tense: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TENSE_UNKNOWN"),
    1: .same(proto: "CONDITIONAL_TENSE"),
    2: .same(proto: "FUTURE"),
    3: .same(proto: "PAST"),
    4: .same(proto: "PRESENT"),
    5: .same(proto: "IMPERFECT"),
    6: .same(proto: "PLUPERFECT"),
  ]
}

extension Google_Cloud_Language_V1_PartOfSpeech.Voice: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VOICE_UNKNOWN"),
    1: .same(proto: "ACTIVE"),
    2: .same(proto: "CAUSATIVE"),
    3: .same(proto: "PASSIVE"),
  ]
}

extension Google_Cloud_Language_V1_DependencyEdge: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DependencyEdge"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "head_token_index"),
    2: .same(proto: "label"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.headTokenIndex) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.label) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.headTokenIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.headTokenIndex, fieldNumber: 1)
    }
    if self.label != .unknown {
      try visitor.visitSingularEnumField(value: self.label, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Language_V1_DependencyEdge, rhs: Google_Cloud_Language_V1_DependencyEdge) -> Bool {
    if lhs.headTokenIndex != rhs.headTokenIndex {return false}
    if lhs.label != rhs.label {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Language_V1_DependencyEdge.Label: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "ABBREV"),
    2: .same(proto: "ACOMP"),
    3: .same(proto: "ADVCL"),
    4: .same(proto: "ADVMOD"),
    5: .same(proto: "AMOD"),
    6: .same(proto: "APPOS"),
    7: .same(proto: "ATTR"),
    8: .same(proto: "AUX"),
    9: .same(proto: "AUXPASS"),
    10: .same(proto: "CC"),
    11: .same(proto: "CCOMP"),
    12: .same(proto: "CONJ"),
    13: .same(proto: "CSUBJ"),
    14: .same(proto: "CSUBJPASS"),
    15: .same(proto: "DEP"),
    16: .same(proto: "DET"),
    17: .same(proto: "DISCOURSE"),
    18: .same(proto: "DOBJ"),
    19: .same(proto: "EXPL"),
    20: .same(proto: "GOESWITH"),
    21: .same(proto: "IOBJ"),
    22: .same(proto: "MARK"),
    23: .same(proto: "MWE"),
    24: .same(proto: "MWV"),
    25: .same(proto: "NEG"),
    26: .same(proto: "NN"),
    27: .same(proto: "NPADVMOD"),
    28: .same(proto: "NSUBJ"),
    29: .same(proto: "NSUBJPASS"),
    30: .same(proto: "NUM"),
    31: .same(proto: "NUMBER"),
    32: .same(proto: "P"),
    33: .same(proto: "PARATAXIS"),
    34: .same(proto: "PARTMOD"),
    35: .same(proto: "PCOMP"),
    36: .same(proto: "POBJ"),
    37: .same(proto: "POSS"),
    38: .same(proto: "POSTNEG"),
    39: .same(proto: "PRECOMP"),
    40: .same(proto: "PRECONJ"),
    41: .same(proto: "PREDET"),
    42: .same(proto: "PREF"),
    43: .same(proto: "PREP"),
    44: .same(proto: "PRONL"),
    45: .same(proto: "PRT"),
    46: .same(proto: "PS"),
    47: .same(proto: "QUANTMOD"),
    48: .same(proto: "RCMOD"),
    49: .same(proto: "RCMODREL"),
    50: .same(proto: "RDROP"),
    51: .same(proto: "REF"),
    52: .same(proto: "REMNANT"),
    53: .same(proto: "REPARANDUM"),
    54: .same(proto: "ROOT"),
    55: .same(proto: "SNUM"),
    56: .same(proto: "SUFF"),
    57: .same(proto: "TMOD"),
    58: .same(proto: "TOPIC"),
    59: .same(proto: "VMOD"),
    60: .same(proto: "VOCATIVE"),
    61: .same(proto: "XCOMP"),
    62: .same(proto: "SUFFIX"),
    63: .same(proto: "TITLE"),
    64: .same(proto: "ADVPHMOD"),
    65: .same(proto: "AUXCAUS"),
    66: .same(proto: "AUXVV"),
    67: .same(proto: "DTMOD"),
    68: .same(proto: "FOREIGN"),
    69: .same(proto: "KW"),
    70: .same(proto: "LIST"),
    71: .same(proto: "NOMC"),
    72: .same(proto: "NOMCSUBJ"),
    73: .same(proto: "NOMCSUBJPASS"),
    74: .same(proto: "NUMC"),
    75: .same(proto: "COP"),
    76: .same(proto: "DISLOCATED"),
    77: .same(proto: "ASP"),
    78: .same(proto: "GMOD"),
    79: .same(proto: "GOBJ"),
    80: .same(proto: "INFMOD"),
    81: .same(proto: "MES"),
    82: .same(proto: "NCOMP"),
  ]
}

extension Google_Cloud_Language_V1_EntityMention: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EntityMention"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .same(proto: "type"),
    3: .same(proto: "sentiment"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._text) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._sentiment) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._text {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.type != .unknown {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    try { if let v = self._sentiment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Language_V1_EntityMention, rhs: Google_Cloud_Language_V1_EntityMention) -> Bool {
    if lhs._text != rhs._text {return false}
    if lhs.type != rhs.type {return false}
    if lhs._sentiment != rhs._sentiment {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Language_V1_EntityMention.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TYPE_UNKNOWN"),
    1: .same(proto: "PROPER"),
    2: .same(proto: "COMMON"),
  ]
}

extension Google_Cloud_Language_V1_TextSpan: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TextSpan"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "content"),
    2: .standard(proto: "begin_offset"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.content) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.beginOffset) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.content.isEmpty {
      try visitor.visitSingularStringField(value: self.content, fieldNumber: 1)
    }
    if self.beginOffset != 0 {
      try visitor.visitSingularInt32Field(value: self.beginOffset, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Language_V1_TextSpan, rhs: Google_Cloud_Language_V1_TextSpan) -> Bool {
    if lhs.content != rhs.content {return false}
    if lhs.beginOffset != rhs.beginOffset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Language_V1_ClassificationCategory: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClassificationCategory"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "confidence"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.confidence) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.confidence != 0 {
      try visitor.visitSingularFloatField(value: self.confidence, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Language_V1_ClassificationCategory, rhs: Google_Cloud_Language_V1_ClassificationCategory) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.confidence != rhs.confidence {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Language_V1_ClassificationModelOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClassificationModelOptions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "v1_model"),
    2: .standard(proto: "v2_model"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Cloud_Language_V1_ClassificationModelOptions.V1Model?
        var hadOneofValue = false
        if let current = self.modelType {
          hadOneofValue = true
          if case .v1Model(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.modelType = .v1Model(v)
        }
      }()
      case 2: try {
        var v: Google_Cloud_Language_V1_ClassificationModelOptions.V2Model?
        var hadOneofValue = false
        if let current = self.modelType {
          hadOneofValue = true
          if case .v2Model(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.modelType = .v2Model(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.modelType {
    case .v1Model?: try {
      guard case .v1Model(let v)? = self.modelType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .v2Model?: try {
      guard case .v2Model(let v)? = self.modelType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Language_V1_ClassificationModelOptions, rhs: Google_Cloud_Language_V1_ClassificationModelOptions) -> Bool {
    if lhs.modelType != rhs.modelType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Language_V1_ClassificationModelOptions.V1Model: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Google_Cloud_Language_V1_ClassificationModelOptions.protoMessageName + ".V1Model"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Language_V1_ClassificationModelOptions.V1Model, rhs: Google_Cloud_Language_V1_ClassificationModelOptions.V1Model) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Language_V1_ClassificationModelOptions.V2Model: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Google_Cloud_Language_V1_ClassificationModelOptions.protoMessageName + ".V2Model"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "content_categories_version"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.contentCategoriesVersion) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.contentCategoriesVersion != .unspecified {
      try visitor.visitSingularEnumField(value: self.contentCategoriesVersion, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Language_V1_ClassificationModelOptions.V2Model, rhs: Google_Cloud_Language_V1_ClassificationModelOptions.V2Model) -> Bool {
    if lhs.contentCategoriesVersion != rhs.contentCategoriesVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Language_V1_ClassificationModelOptions.V2Model.ContentCategoriesVersion: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CONTENT_CATEGORIES_VERSION_UNSPECIFIED"),
    1: .same(proto: "V1"),
    2: .same(proto: "V2"),
  ]
}

extension Google_Cloud_Language_V1_AnalyzeSentimentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AnalyzeSentimentRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "document"),
    2: .standard(proto: "encoding_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._document) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.encodingType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._document {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.encodingType != .none {
      try visitor.visitSingularEnumField(value: self.encodingType, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Language_V1_AnalyzeSentimentRequest, rhs: Google_Cloud_Language_V1_AnalyzeSentimentRequest) -> Bool {
    if lhs._document != rhs._document {return false}
    if lhs.encodingType != rhs.encodingType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Language_V1_AnalyzeSentimentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AnalyzeSentimentResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "document_sentiment"),
    2: .same(proto: "language"),
    3: .same(proto: "sentences"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._documentSentiment) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.language) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.sentences) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._documentSentiment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.language.isEmpty {
      try visitor.visitSingularStringField(value: self.language, fieldNumber: 2)
    }
    if !self.sentences.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sentences, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Language_V1_AnalyzeSentimentResponse, rhs: Google_Cloud_Language_V1_AnalyzeSentimentResponse) -> Bool {
    if lhs._documentSentiment != rhs._documentSentiment {return false}
    if lhs.language != rhs.language {return false}
    if lhs.sentences != rhs.sentences {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Language_V1_AnalyzeEntitySentimentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AnalyzeEntitySentimentRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "document"),
    2: .standard(proto: "encoding_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._document) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.encodingType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._document {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.encodingType != .none {
      try visitor.visitSingularEnumField(value: self.encodingType, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Language_V1_AnalyzeEntitySentimentRequest, rhs: Google_Cloud_Language_V1_AnalyzeEntitySentimentRequest) -> Bool {
    if lhs._document != rhs._document {return false}
    if lhs.encodingType != rhs.encodingType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Language_V1_AnalyzeEntitySentimentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AnalyzeEntitySentimentResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "entities"),
    2: .same(proto: "language"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.entities) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.language) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.entities.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entities, fieldNumber: 1)
    }
    if !self.language.isEmpty {
      try visitor.visitSingularStringField(value: self.language, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Language_V1_AnalyzeEntitySentimentResponse, rhs: Google_Cloud_Language_V1_AnalyzeEntitySentimentResponse) -> Bool {
    if lhs.entities != rhs.entities {return false}
    if lhs.language != rhs.language {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Language_V1_AnalyzeEntitiesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AnalyzeEntitiesRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "document"),
    2: .standard(proto: "encoding_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._document) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.encodingType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._document {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.encodingType != .none {
      try visitor.visitSingularEnumField(value: self.encodingType, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Language_V1_AnalyzeEntitiesRequest, rhs: Google_Cloud_Language_V1_AnalyzeEntitiesRequest) -> Bool {
    if lhs._document != rhs._document {return false}
    if lhs.encodingType != rhs.encodingType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Language_V1_AnalyzeEntitiesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AnalyzeEntitiesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "entities"),
    2: .same(proto: "language"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.entities) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.language) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.entities.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entities, fieldNumber: 1)
    }
    if !self.language.isEmpty {
      try visitor.visitSingularStringField(value: self.language, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Language_V1_AnalyzeEntitiesResponse, rhs: Google_Cloud_Language_V1_AnalyzeEntitiesResponse) -> Bool {
    if lhs.entities != rhs.entities {return false}
    if lhs.language != rhs.language {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Language_V1_AnalyzeSyntaxRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AnalyzeSyntaxRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "document"),
    2: .standard(proto: "encoding_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._document) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.encodingType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._document {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.encodingType != .none {
      try visitor.visitSingularEnumField(value: self.encodingType, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Language_V1_AnalyzeSyntaxRequest, rhs: Google_Cloud_Language_V1_AnalyzeSyntaxRequest) -> Bool {
    if lhs._document != rhs._document {return false}
    if lhs.encodingType != rhs.encodingType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Language_V1_AnalyzeSyntaxResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AnalyzeSyntaxResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sentences"),
    2: .same(proto: "tokens"),
    3: .same(proto: "language"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.sentences) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.tokens) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.language) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sentences.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sentences, fieldNumber: 1)
    }
    if !self.tokens.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tokens, fieldNumber: 2)
    }
    if !self.language.isEmpty {
      try visitor.visitSingularStringField(value: self.language, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Language_V1_AnalyzeSyntaxResponse, rhs: Google_Cloud_Language_V1_AnalyzeSyntaxResponse) -> Bool {
    if lhs.sentences != rhs.sentences {return false}
    if lhs.tokens != rhs.tokens {return false}
    if lhs.language != rhs.language {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Language_V1_ClassifyTextRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClassifyTextRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "document"),
    3: .standard(proto: "classification_model_options"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._document) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._classificationModelOptions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._document {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._classificationModelOptions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Language_V1_ClassifyTextRequest, rhs: Google_Cloud_Language_V1_ClassifyTextRequest) -> Bool {
    if lhs._document != rhs._document {return false}
    if lhs._classificationModelOptions != rhs._classificationModelOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Language_V1_ClassifyTextResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClassifyTextResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "categories"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.categories) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.categories.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.categories, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Language_V1_ClassifyTextResponse, rhs: Google_Cloud_Language_V1_ClassifyTextResponse) -> Bool {
    if lhs.categories != rhs.categories {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Language_V1_AnnotateTextRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AnnotateTextRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "document"),
    2: .same(proto: "features"),
    3: .standard(proto: "encoding_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._document) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._features) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.encodingType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._document {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._features {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.encodingType != .none {
      try visitor.visitSingularEnumField(value: self.encodingType, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Language_V1_AnnotateTextRequest, rhs: Google_Cloud_Language_V1_AnnotateTextRequest) -> Bool {
    if lhs._document != rhs._document {return false}
    if lhs._features != rhs._features {return false}
    if lhs.encodingType != rhs.encodingType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Language_V1_AnnotateTextRequest.Features: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Google_Cloud_Language_V1_AnnotateTextRequest.protoMessageName + ".Features"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "extract_syntax"),
    2: .standard(proto: "extract_entities"),
    3: .standard(proto: "extract_document_sentiment"),
    4: .standard(proto: "extract_entity_sentiment"),
    6: .standard(proto: "classify_text"),
    10: .standard(proto: "classification_model_options"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.extractSyntax) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.extractEntities) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.extractDocumentSentiment) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.extractEntitySentiment) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.classifyText) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._classificationModelOptions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.extractSyntax != false {
      try visitor.visitSingularBoolField(value: self.extractSyntax, fieldNumber: 1)
    }
    if self.extractEntities != false {
      try visitor.visitSingularBoolField(value: self.extractEntities, fieldNumber: 2)
    }
    if self.extractDocumentSentiment != false {
      try visitor.visitSingularBoolField(value: self.extractDocumentSentiment, fieldNumber: 3)
    }
    if self.extractEntitySentiment != false {
      try visitor.visitSingularBoolField(value: self.extractEntitySentiment, fieldNumber: 4)
    }
    if self.classifyText != false {
      try visitor.visitSingularBoolField(value: self.classifyText, fieldNumber: 6)
    }
    try { if let v = self._classificationModelOptions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Language_V1_AnnotateTextRequest.Features, rhs: Google_Cloud_Language_V1_AnnotateTextRequest.Features) -> Bool {
    if lhs.extractSyntax != rhs.extractSyntax {return false}
    if lhs.extractEntities != rhs.extractEntities {return false}
    if lhs.extractDocumentSentiment != rhs.extractDocumentSentiment {return false}
    if lhs.extractEntitySentiment != rhs.extractEntitySentiment {return false}
    if lhs.classifyText != rhs.classifyText {return false}
    if lhs._classificationModelOptions != rhs._classificationModelOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Language_V1_AnnotateTextResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AnnotateTextResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sentences"),
    2: .same(proto: "tokens"),
    3: .same(proto: "entities"),
    4: .standard(proto: "document_sentiment"),
    5: .same(proto: "language"),
    6: .same(proto: "categories"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.sentences) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.tokens) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.entities) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._documentSentiment) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.language) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.categories) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.sentences.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sentences, fieldNumber: 1)
    }
    if !self.tokens.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tokens, fieldNumber: 2)
    }
    if !self.entities.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entities, fieldNumber: 3)
    }
    try { if let v = self._documentSentiment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.language.isEmpty {
      try visitor.visitSingularStringField(value: self.language, fieldNumber: 5)
    }
    if !self.categories.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.categories, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Cloud_Language_V1_AnnotateTextResponse, rhs: Google_Cloud_Language_V1_AnnotateTextResponse) -> Bool {
    if lhs.sentences != rhs.sentences {return false}
    if lhs.tokens != rhs.tokens {return false}
    if lhs.entities != rhs.entities {return false}
    if lhs._documentSentiment != rhs._documentSentiment {return false}
    if lhs.language != rhs.language {return false}
    if lhs.categories != rhs.categories {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
