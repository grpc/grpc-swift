// Copyright 2015-2016 gRPC authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// An integration test service that covers all the method signature permutations
// of unary/streaming requests/responses.

// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the gRPC Swift generator plugin for the protocol buffer compiler.
// Source: src/proto/grpc/testing/test.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/grpc/grpc-swift

import GRPCCore
import GRPCProtobuf

public enum Grpc_Testing_ReconnectService {
    public enum Method {
        public enum Start {
            public typealias Input = Grpc_Testing_ReconnectParams
            public typealias Output = Grpc_Testing_Empty
            public static let descriptor = MethodDescriptor(
                service: "grpc.testing.ReconnectService",
                method: "Start"
            )
        }
        public enum Stop {
            public typealias Input = Grpc_Testing_Empty
            public typealias Output = Grpc_Testing_ReconnectInfo
            public static let descriptor = MethodDescriptor(
                service: "grpc.testing.ReconnectService",
                method: "Stop"
            )
        }
        public static let descriptors: [MethodDescriptor] = [
            Start.descriptor,
            Stop.descriptor
        ]
    }
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public typealias StreamingServiceProtocol = Grpc_Testing_ReconnectServiceStreamingServiceProtocol
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public typealias ServiceProtocol = Grpc_Testing_ReconnectServiceServiceProtocol
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public typealias ClientProtocol = Grpc_Testing_ReconnectServiceClientProtocol
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public typealias Client = Grpc_Testing_ReconnectServiceClient
}

public enum Grpc_Testing_TestService {
    public enum Method {
        public enum EmptyCall {
            public typealias Input = Grpc_Testing_Empty
            public typealias Output = Grpc_Testing_Empty
            public static let descriptor = MethodDescriptor(
                service: "grpc.testing.TestService",
                method: "EmptyCall"
            )
        }
        public enum UnaryCall {
            public typealias Input = Grpc_Testing_SimpleRequest
            public typealias Output = Grpc_Testing_SimpleResponse
            public static let descriptor = MethodDescriptor(
                service: "grpc.testing.TestService",
                method: "UnaryCall"
            )
        }
        public enum CacheableUnaryCall {
            public typealias Input = Grpc_Testing_SimpleRequest
            public typealias Output = Grpc_Testing_SimpleResponse
            public static let descriptor = MethodDescriptor(
                service: "grpc.testing.TestService",
                method: "CacheableUnaryCall"
            )
        }
        public enum StreamingOutputCall {
            public typealias Input = Grpc_Testing_StreamingOutputCallRequest
            public typealias Output = Grpc_Testing_StreamingOutputCallResponse
            public static let descriptor = MethodDescriptor(
                service: "grpc.testing.TestService",
                method: "StreamingOutputCall"
            )
        }
        public enum StreamingInputCall {
            public typealias Input = Grpc_Testing_StreamingInputCallRequest
            public typealias Output = Grpc_Testing_StreamingInputCallResponse
            public static let descriptor = MethodDescriptor(
                service: "grpc.testing.TestService",
                method: "StreamingInputCall"
            )
        }
        public enum FullDuplexCall {
            public typealias Input = Grpc_Testing_StreamingOutputCallRequest
            public typealias Output = Grpc_Testing_StreamingOutputCallResponse
            public static let descriptor = MethodDescriptor(
                service: "grpc.testing.TestService",
                method: "FullDuplexCall"
            )
        }
        public enum HalfDuplexCall {
            public typealias Input = Grpc_Testing_StreamingOutputCallRequest
            public typealias Output = Grpc_Testing_StreamingOutputCallResponse
            public static let descriptor = MethodDescriptor(
                service: "grpc.testing.TestService",
                method: "HalfDuplexCall"
            )
        }
        public enum UnimplementedCall {
            public typealias Input = Grpc_Testing_Empty
            public typealias Output = Grpc_Testing_Empty
            public static let descriptor = MethodDescriptor(
                service: "grpc.testing.TestService",
                method: "UnimplementedCall"
            )
        }
        public static let descriptors: [MethodDescriptor] = [
            EmptyCall.descriptor,
            UnaryCall.descriptor,
            CacheableUnaryCall.descriptor,
            StreamingOutputCall.descriptor,
            StreamingInputCall.descriptor,
            FullDuplexCall.descriptor,
            HalfDuplexCall.descriptor,
            UnimplementedCall.descriptor
        ]
    }
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public typealias StreamingServiceProtocol = Grpc_Testing_TestServiceStreamingServiceProtocol
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public typealias ServiceProtocol = Grpc_Testing_TestServiceServiceProtocol
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public typealias ClientProtocol = Grpc_Testing_TestServiceClientProtocol
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public typealias Client = Grpc_Testing_TestServiceClient
}

public enum Grpc_Testing_UnimplementedService {
    public enum Method {
        public enum UnimplementedCall {
            public typealias Input = Grpc_Testing_Empty
            public typealias Output = Grpc_Testing_Empty
            public static let descriptor = MethodDescriptor(
                service: "grpc.testing.UnimplementedService",
                method: "UnimplementedCall"
            )
        }
        public static let descriptors: [MethodDescriptor] = [
            UnimplementedCall.descriptor
        ]
    }
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public typealias StreamingServiceProtocol = Grpc_Testing_UnimplementedServiceStreamingServiceProtocol
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public typealias ServiceProtocol = Grpc_Testing_UnimplementedServiceServiceProtocol
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public typealias ClientProtocol = Grpc_Testing_UnimplementedServiceClientProtocol
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public typealias Client = Grpc_Testing_UnimplementedServiceClient
}

/// A simple service to test the various types of RPCs and experiment with
/// performance with various types of payload.
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
public protocol Grpc_Testing_TestServiceStreamingServiceProtocol: GRPCCore.RegistrableRPCService {
    /// One empty request followed by one empty response.
    func emptyCall(request: ServerRequest.Stream<Grpc_Testing_Empty>) async throws -> ServerResponse.Stream<Grpc_Testing_Empty>

    /// One request followed by one response.
    func unaryCall(request: ServerRequest.Stream<Grpc_Testing_SimpleRequest>) async throws -> ServerResponse.Stream<Grpc_Testing_SimpleResponse>

    /// One request followed by one response. Response has cache control
    /// headers set such that a caching HTTP proxy (such as GFE) can
    /// satisfy subsequent requests.
    func cacheableUnaryCall(request: ServerRequest.Stream<Grpc_Testing_SimpleRequest>) async throws -> ServerResponse.Stream<Grpc_Testing_SimpleResponse>

    /// One request followed by a sequence of responses (streamed download).
    /// The server returns the payload with client desired type and sizes.
    func streamingOutputCall(request: ServerRequest.Stream<Grpc_Testing_StreamingOutputCallRequest>) async throws -> ServerResponse.Stream<Grpc_Testing_StreamingOutputCallResponse>

    /// A sequence of requests followed by one response (streamed upload).
    /// The server returns the aggregated size of client payload as the result.
    func streamingInputCall(request: ServerRequest.Stream<Grpc_Testing_StreamingInputCallRequest>) async throws -> ServerResponse.Stream<Grpc_Testing_StreamingInputCallResponse>

    /// A sequence of requests with each request served by the server immediately.
    /// As one request could lead to multiple responses, this interface
    /// demonstrates the idea of full duplexing.
    func fullDuplexCall(request: ServerRequest.Stream<Grpc_Testing_StreamingOutputCallRequest>) async throws -> ServerResponse.Stream<Grpc_Testing_StreamingOutputCallResponse>

    /// A sequence of requests followed by a sequence of responses.
    /// The server buffers all the client requests and then serves them in order. A
    /// stream of responses are returned to the client when the server starts with
    /// first request.
    func halfDuplexCall(request: ServerRequest.Stream<Grpc_Testing_StreamingOutputCallRequest>) async throws -> ServerResponse.Stream<Grpc_Testing_StreamingOutputCallResponse>

    /// The test server will not implement this method. It will be used
    /// to test the behavior when clients call unimplemented methods.
    func unimplementedCall(request: ServerRequest.Stream<Grpc_Testing_Empty>) async throws -> ServerResponse.Stream<Grpc_Testing_Empty>
}

/// Conformance to `GRPCCore.RegistrableRPCService`.
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension Grpc_Testing_TestService.StreamingServiceProtocol {
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func registerMethods(with router: inout GRPCCore.RPCRouter) {
        router.registerHandler(
            forMethod: Grpc_Testing_TestService.Method.EmptyCall.descriptor,
            deserializer: ProtobufDeserializer<Grpc_Testing_Empty>(),
            serializer: ProtobufSerializer<Grpc_Testing_Empty>(),
            handler: { request in
                try await self.emptyCall(request: request)
            }
        )
        router.registerHandler(
            forMethod: Grpc_Testing_TestService.Method.UnaryCall.descriptor,
            deserializer: ProtobufDeserializer<Grpc_Testing_SimpleRequest>(),
            serializer: ProtobufSerializer<Grpc_Testing_SimpleResponse>(),
            handler: { request in
                try await self.unaryCall(request: request)
            }
        )
        router.registerHandler(
            forMethod: Grpc_Testing_TestService.Method.CacheableUnaryCall.descriptor,
            deserializer: ProtobufDeserializer<Grpc_Testing_SimpleRequest>(),
            serializer: ProtobufSerializer<Grpc_Testing_SimpleResponse>(),
            handler: { request in
                try await self.cacheableUnaryCall(request: request)
            }
        )
        router.registerHandler(
            forMethod: Grpc_Testing_TestService.Method.StreamingOutputCall.descriptor,
            deserializer: ProtobufDeserializer<Grpc_Testing_StreamingOutputCallRequest>(),
            serializer: ProtobufSerializer<Grpc_Testing_StreamingOutputCallResponse>(),
            handler: { request in
                try await self.streamingOutputCall(request: request)
            }
        )
        router.registerHandler(
            forMethod: Grpc_Testing_TestService.Method.StreamingInputCall.descriptor,
            deserializer: ProtobufDeserializer<Grpc_Testing_StreamingInputCallRequest>(),
            serializer: ProtobufSerializer<Grpc_Testing_StreamingInputCallResponse>(),
            handler: { request in
                try await self.streamingInputCall(request: request)
            }
        )
        router.registerHandler(
            forMethod: Grpc_Testing_TestService.Method.FullDuplexCall.descriptor,
            deserializer: ProtobufDeserializer<Grpc_Testing_StreamingOutputCallRequest>(),
            serializer: ProtobufSerializer<Grpc_Testing_StreamingOutputCallResponse>(),
            handler: { request in
                try await self.fullDuplexCall(request: request)
            }
        )
        router.registerHandler(
            forMethod: Grpc_Testing_TestService.Method.HalfDuplexCall.descriptor,
            deserializer: ProtobufDeserializer<Grpc_Testing_StreamingOutputCallRequest>(),
            serializer: ProtobufSerializer<Grpc_Testing_StreamingOutputCallResponse>(),
            handler: { request in
                try await self.halfDuplexCall(request: request)
            }
        )
        router.registerHandler(
            forMethod: Grpc_Testing_TestService.Method.UnimplementedCall.descriptor,
            deserializer: ProtobufDeserializer<Grpc_Testing_Empty>(),
            serializer: ProtobufSerializer<Grpc_Testing_Empty>(),
            handler: { request in
                try await self.unimplementedCall(request: request)
            }
        )
    }
}

/// A simple service to test the various types of RPCs and experiment with
/// performance with various types of payload.
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
public protocol Grpc_Testing_TestServiceServiceProtocol: Grpc_Testing_TestService.StreamingServiceProtocol {
    /// One empty request followed by one empty response.
    func emptyCall(request: ServerRequest.Single<Grpc_Testing_Empty>) async throws -> ServerResponse.Single<Grpc_Testing_Empty>

    /// One request followed by one response.
    func unaryCall(request: ServerRequest.Single<Grpc_Testing_SimpleRequest>) async throws -> ServerResponse.Single<Grpc_Testing_SimpleResponse>

    /// One request followed by one response. Response has cache control
    /// headers set such that a caching HTTP proxy (such as GFE) can
    /// satisfy subsequent requests.
    func cacheableUnaryCall(request: ServerRequest.Single<Grpc_Testing_SimpleRequest>) async throws -> ServerResponse.Single<Grpc_Testing_SimpleResponse>

    /// One request followed by a sequence of responses (streamed download).
    /// The server returns the payload with client desired type and sizes.
    func streamingOutputCall(request: ServerRequest.Single<Grpc_Testing_StreamingOutputCallRequest>) async throws -> ServerResponse.Stream<Grpc_Testing_StreamingOutputCallResponse>

    /// A sequence of requests followed by one response (streamed upload).
    /// The server returns the aggregated size of client payload as the result.
    func streamingInputCall(request: ServerRequest.Stream<Grpc_Testing_StreamingInputCallRequest>) async throws -> ServerResponse.Single<Grpc_Testing_StreamingInputCallResponse>

    /// A sequence of requests with each request served by the server immediately.
    /// As one request could lead to multiple responses, this interface
    /// demonstrates the idea of full duplexing.
    func fullDuplexCall(request: ServerRequest.Stream<Grpc_Testing_StreamingOutputCallRequest>) async throws -> ServerResponse.Stream<Grpc_Testing_StreamingOutputCallResponse>

    /// A sequence of requests followed by a sequence of responses.
    /// The server buffers all the client requests and then serves them in order. A
    /// stream of responses are returned to the client when the server starts with
    /// first request.
    func halfDuplexCall(request: ServerRequest.Stream<Grpc_Testing_StreamingOutputCallRequest>) async throws -> ServerResponse.Stream<Grpc_Testing_StreamingOutputCallResponse>

    /// The test server will not implement this method. It will be used
    /// to test the behavior when clients call unimplemented methods.
    func unimplementedCall(request: ServerRequest.Single<Grpc_Testing_Empty>) async throws -> ServerResponse.Single<Grpc_Testing_Empty>
}

/// Partial conformance to `Grpc_Testing_TestServiceStreamingServiceProtocol`.
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension Grpc_Testing_TestService.ServiceProtocol {
    public func emptyCall(request: ServerRequest.Stream<Grpc_Testing_Empty>) async throws -> ServerResponse.Stream<Grpc_Testing_Empty> {
        let response = try await self.emptyCall(request: ServerRequest.Single(stream: request))
        return ServerResponse.Stream(single: response)
    }

    public func unaryCall(request: ServerRequest.Stream<Grpc_Testing_SimpleRequest>) async throws -> ServerResponse.Stream<Grpc_Testing_SimpleResponse> {
        let response = try await self.unaryCall(request: ServerRequest.Single(stream: request))
        return ServerResponse.Stream(single: response)
    }

    public func cacheableUnaryCall(request: ServerRequest.Stream<Grpc_Testing_SimpleRequest>) async throws -> ServerResponse.Stream<Grpc_Testing_SimpleResponse> {
        let response = try await self.cacheableUnaryCall(request: ServerRequest.Single(stream: request))
        return ServerResponse.Stream(single: response)
    }

    public func streamingOutputCall(request: ServerRequest.Stream<Grpc_Testing_StreamingOutputCallRequest>) async throws -> ServerResponse.Stream<Grpc_Testing_StreamingOutputCallResponse> {
        let response = try await self.streamingOutputCall(request: ServerRequest.Single(stream: request))
        return response
    }

    public func streamingInputCall(request: ServerRequest.Stream<Grpc_Testing_StreamingInputCallRequest>) async throws -> ServerResponse.Stream<Grpc_Testing_StreamingInputCallResponse> {
        let response = try await self.streamingInputCall(request: request)
        return ServerResponse.Stream(single: response)
    }

    public func unimplementedCall(request: ServerRequest.Stream<Grpc_Testing_Empty>) async throws -> ServerResponse.Stream<Grpc_Testing_Empty> {
        let response = try await self.unimplementedCall(request: ServerRequest.Single(stream: request))
        return ServerResponse.Stream(single: response)
    }
}

/// A simple service NOT implemented at servers so clients can test for
/// that case.
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
public protocol Grpc_Testing_UnimplementedServiceStreamingServiceProtocol: GRPCCore.RegistrableRPCService {
    /// A call that no server should implement
    func unimplementedCall(request: ServerRequest.Stream<Grpc_Testing_Empty>) async throws -> ServerResponse.Stream<Grpc_Testing_Empty>
}

/// Conformance to `GRPCCore.RegistrableRPCService`.
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension Grpc_Testing_UnimplementedService.StreamingServiceProtocol {
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func registerMethods(with router: inout GRPCCore.RPCRouter) {
        router.registerHandler(
            forMethod: Grpc_Testing_UnimplementedService.Method.UnimplementedCall.descriptor,
            deserializer: ProtobufDeserializer<Grpc_Testing_Empty>(),
            serializer: ProtobufSerializer<Grpc_Testing_Empty>(),
            handler: { request in
                try await self.unimplementedCall(request: request)
            }
        )
    }
}

/// A simple service NOT implemented at servers so clients can test for
/// that case.
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
public protocol Grpc_Testing_UnimplementedServiceServiceProtocol: Grpc_Testing_UnimplementedService.StreamingServiceProtocol {
    /// A call that no server should implement
    func unimplementedCall(request: ServerRequest.Single<Grpc_Testing_Empty>) async throws -> ServerResponse.Single<Grpc_Testing_Empty>
}

/// Partial conformance to `Grpc_Testing_UnimplementedServiceStreamingServiceProtocol`.
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension Grpc_Testing_UnimplementedService.ServiceProtocol {
    public func unimplementedCall(request: ServerRequest.Stream<Grpc_Testing_Empty>) async throws -> ServerResponse.Stream<Grpc_Testing_Empty> {
        let response = try await self.unimplementedCall(request: ServerRequest.Single(stream: request))
        return ServerResponse.Stream(single: response)
    }
}

/// A service used to control reconnect server.
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
public protocol Grpc_Testing_ReconnectServiceStreamingServiceProtocol: GRPCCore.RegistrableRPCService {
    func start(request: ServerRequest.Stream<Grpc_Testing_ReconnectParams>) async throws -> ServerResponse.Stream<Grpc_Testing_Empty>

    func stop(request: ServerRequest.Stream<Grpc_Testing_Empty>) async throws -> ServerResponse.Stream<Grpc_Testing_ReconnectInfo>
}

/// Conformance to `GRPCCore.RegistrableRPCService`.
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension Grpc_Testing_ReconnectService.StreamingServiceProtocol {
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func registerMethods(with router: inout GRPCCore.RPCRouter) {
        router.registerHandler(
            forMethod: Grpc_Testing_ReconnectService.Method.Start.descriptor,
            deserializer: ProtobufDeserializer<Grpc_Testing_ReconnectParams>(),
            serializer: ProtobufSerializer<Grpc_Testing_Empty>(),
            handler: { request in
                try await self.start(request: request)
            }
        )
        router.registerHandler(
            forMethod: Grpc_Testing_ReconnectService.Method.Stop.descriptor,
            deserializer: ProtobufDeserializer<Grpc_Testing_Empty>(),
            serializer: ProtobufSerializer<Grpc_Testing_ReconnectInfo>(),
            handler: { request in
                try await self.stop(request: request)
            }
        )
    }
}

/// A service used to control reconnect server.
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
public protocol Grpc_Testing_ReconnectServiceServiceProtocol: Grpc_Testing_ReconnectService.StreamingServiceProtocol {
    func start(request: ServerRequest.Single<Grpc_Testing_ReconnectParams>) async throws -> ServerResponse.Single<Grpc_Testing_Empty>

    func stop(request: ServerRequest.Single<Grpc_Testing_Empty>) async throws -> ServerResponse.Single<Grpc_Testing_ReconnectInfo>
}

/// Partial conformance to `Grpc_Testing_ReconnectServiceStreamingServiceProtocol`.
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension Grpc_Testing_ReconnectService.ServiceProtocol {
    public func start(request: ServerRequest.Stream<Grpc_Testing_ReconnectParams>) async throws -> ServerResponse.Stream<Grpc_Testing_Empty> {
        let response = try await self.start(request: ServerRequest.Single(stream: request))
        return ServerResponse.Stream(single: response)
    }

    public func stop(request: ServerRequest.Stream<Grpc_Testing_Empty>) async throws -> ServerResponse.Stream<Grpc_Testing_ReconnectInfo> {
        let response = try await self.stop(request: ServerRequest.Single(stream: request))
        return ServerResponse.Stream(single: response)
    }
}

/// A simple service to test the various types of RPCs and experiment with
/// performance with various types of payload.
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
public protocol Grpc_Testing_TestServiceClientProtocol: Sendable {
    /// One empty request followed by one empty response.
    func emptyCall<R>(
        request: ClientRequest.Single<Grpc_Testing_Empty>,
        serializer: some MessageSerializer<Grpc_Testing_Empty>,
        deserializer: some MessageDeserializer<Grpc_Testing_Empty>,
        options: CallOptions,
        _ body: @Sendable @escaping (ClientResponse.Single<Grpc_Testing_Empty>) async throws -> R
    ) async throws -> R where R: Sendable

    /// One request followed by one response.
    func unaryCall<R>(
        request: ClientRequest.Single<Grpc_Testing_SimpleRequest>,
        serializer: some MessageSerializer<Grpc_Testing_SimpleRequest>,
        deserializer: some MessageDeserializer<Grpc_Testing_SimpleResponse>,
        options: CallOptions,
        _ body: @Sendable @escaping (ClientResponse.Single<Grpc_Testing_SimpleResponse>) async throws -> R
    ) async throws -> R where R: Sendable

    /// One request followed by one response. Response has cache control
    /// headers set such that a caching HTTP proxy (such as GFE) can
    /// satisfy subsequent requests.
    func cacheableUnaryCall<R>(
        request: ClientRequest.Single<Grpc_Testing_SimpleRequest>,
        serializer: some MessageSerializer<Grpc_Testing_SimpleRequest>,
        deserializer: some MessageDeserializer<Grpc_Testing_SimpleResponse>,
        options: CallOptions,
        _ body: @Sendable @escaping (ClientResponse.Single<Grpc_Testing_SimpleResponse>) async throws -> R
    ) async throws -> R where R: Sendable

    /// One request followed by a sequence of responses (streamed download).
    /// The server returns the payload with client desired type and sizes.
    func streamingOutputCall<R>(
        request: ClientRequest.Single<Grpc_Testing_StreamingOutputCallRequest>,
        serializer: some MessageSerializer<Grpc_Testing_StreamingOutputCallRequest>,
        deserializer: some MessageDeserializer<Grpc_Testing_StreamingOutputCallResponse>,
        options: CallOptions,
        _ body: @Sendable @escaping (ClientResponse.Stream<Grpc_Testing_StreamingOutputCallResponse>) async throws -> R
    ) async throws -> R where R: Sendable

    /// A sequence of requests followed by one response (streamed upload).
    /// The server returns the aggregated size of client payload as the result.
    func streamingInputCall<R>(
        request: ClientRequest.Stream<Grpc_Testing_StreamingInputCallRequest>,
        serializer: some MessageSerializer<Grpc_Testing_StreamingInputCallRequest>,
        deserializer: some MessageDeserializer<Grpc_Testing_StreamingInputCallResponse>,
        options: CallOptions,
        _ body: @Sendable @escaping (ClientResponse.Single<Grpc_Testing_StreamingInputCallResponse>) async throws -> R
    ) async throws -> R where R: Sendable

    /// A sequence of requests with each request served by the server immediately.
    /// As one request could lead to multiple responses, this interface
    /// demonstrates the idea of full duplexing.
    func fullDuplexCall<R>(
        request: ClientRequest.Stream<Grpc_Testing_StreamingOutputCallRequest>,
        serializer: some MessageSerializer<Grpc_Testing_StreamingOutputCallRequest>,
        deserializer: some MessageDeserializer<Grpc_Testing_StreamingOutputCallResponse>,
        options: CallOptions,
        _ body: @Sendable @escaping (ClientResponse.Stream<Grpc_Testing_StreamingOutputCallResponse>) async throws -> R
    ) async throws -> R where R: Sendable

    /// A sequence of requests followed by a sequence of responses.
    /// The server buffers all the client requests and then serves them in order. A
    /// stream of responses are returned to the client when the server starts with
    /// first request.
    func halfDuplexCall<R>(
        request: ClientRequest.Stream<Grpc_Testing_StreamingOutputCallRequest>,
        serializer: some MessageSerializer<Grpc_Testing_StreamingOutputCallRequest>,
        deserializer: some MessageDeserializer<Grpc_Testing_StreamingOutputCallResponse>,
        options: CallOptions,
        _ body: @Sendable @escaping (ClientResponse.Stream<Grpc_Testing_StreamingOutputCallResponse>) async throws -> R
    ) async throws -> R where R: Sendable

    /// The test server will not implement this method. It will be used
    /// to test the behavior when clients call unimplemented methods.
    func unimplementedCall<R>(
        request: ClientRequest.Single<Grpc_Testing_Empty>,
        serializer: some MessageSerializer<Grpc_Testing_Empty>,
        deserializer: some MessageDeserializer<Grpc_Testing_Empty>,
        options: CallOptions,
        _ body: @Sendable @escaping (ClientResponse.Single<Grpc_Testing_Empty>) async throws -> R
    ) async throws -> R where R: Sendable
}

@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension Grpc_Testing_TestService.ClientProtocol {
    public func emptyCall<R>(
        request: ClientRequest.Single<Grpc_Testing_Empty>,
        options: CallOptions = .defaults,
        _ body: @Sendable @escaping (ClientResponse.Single<Grpc_Testing_Empty>) async throws -> R
    ) async throws -> R where R: Sendable {
        try await self.emptyCall(
            request: request,
            serializer: ProtobufSerializer<Grpc_Testing_Empty>(),
            deserializer: ProtobufDeserializer<Grpc_Testing_Empty>(),
            options: options,
            body
        )
    }

    public func unaryCall<R>(
        request: ClientRequest.Single<Grpc_Testing_SimpleRequest>,
        options: CallOptions = .defaults,
        _ body: @Sendable @escaping (ClientResponse.Single<Grpc_Testing_SimpleResponse>) async throws -> R
    ) async throws -> R where R: Sendable {
        try await self.unaryCall(
            request: request,
            serializer: ProtobufSerializer<Grpc_Testing_SimpleRequest>(),
            deserializer: ProtobufDeserializer<Grpc_Testing_SimpleResponse>(),
            options: options,
            body
        )
    }

    public func cacheableUnaryCall<R>(
        request: ClientRequest.Single<Grpc_Testing_SimpleRequest>,
        options: CallOptions = .defaults,
        _ body: @Sendable @escaping (ClientResponse.Single<Grpc_Testing_SimpleResponse>) async throws -> R
    ) async throws -> R where R: Sendable {
        try await self.cacheableUnaryCall(
            request: request,
            serializer: ProtobufSerializer<Grpc_Testing_SimpleRequest>(),
            deserializer: ProtobufDeserializer<Grpc_Testing_SimpleResponse>(),
            options: options,
            body
        )
    }

    public func streamingOutputCall<R>(
        request: ClientRequest.Single<Grpc_Testing_StreamingOutputCallRequest>,
        options: CallOptions = .defaults,
        _ body: @Sendable @escaping (ClientResponse.Stream<Grpc_Testing_StreamingOutputCallResponse>) async throws -> R
    ) async throws -> R where R: Sendable {
        try await self.streamingOutputCall(
            request: request,
            serializer: ProtobufSerializer<Grpc_Testing_StreamingOutputCallRequest>(),
            deserializer: ProtobufDeserializer<Grpc_Testing_StreamingOutputCallResponse>(),
            options: options,
            body
        )
    }

    public func streamingInputCall<R>(
        request: ClientRequest.Stream<Grpc_Testing_StreamingInputCallRequest>,
        options: CallOptions = .defaults,
        _ body: @Sendable @escaping (ClientResponse.Single<Grpc_Testing_StreamingInputCallResponse>) async throws -> R
    ) async throws -> R where R: Sendable {
        try await self.streamingInputCall(
            request: request,
            serializer: ProtobufSerializer<Grpc_Testing_StreamingInputCallRequest>(),
            deserializer: ProtobufDeserializer<Grpc_Testing_StreamingInputCallResponse>(),
            options: options,
            body
        )
    }

    public func fullDuplexCall<R>(
        request: ClientRequest.Stream<Grpc_Testing_StreamingOutputCallRequest>,
        options: CallOptions = .defaults,
        _ body: @Sendable @escaping (ClientResponse.Stream<Grpc_Testing_StreamingOutputCallResponse>) async throws -> R
    ) async throws -> R where R: Sendable {
        try await self.fullDuplexCall(
            request: request,
            serializer: ProtobufSerializer<Grpc_Testing_StreamingOutputCallRequest>(),
            deserializer: ProtobufDeserializer<Grpc_Testing_StreamingOutputCallResponse>(),
            options: options,
            body
        )
    }

    public func halfDuplexCall<R>(
        request: ClientRequest.Stream<Grpc_Testing_StreamingOutputCallRequest>,
        options: CallOptions = .defaults,
        _ body: @Sendable @escaping (ClientResponse.Stream<Grpc_Testing_StreamingOutputCallResponse>) async throws -> R
    ) async throws -> R where R: Sendable {
        try await self.halfDuplexCall(
            request: request,
            serializer: ProtobufSerializer<Grpc_Testing_StreamingOutputCallRequest>(),
            deserializer: ProtobufDeserializer<Grpc_Testing_StreamingOutputCallResponse>(),
            options: options,
            body
        )
    }

    public func unimplementedCall<R>(
        request: ClientRequest.Single<Grpc_Testing_Empty>,
        options: CallOptions = .defaults,
        _ body: @Sendable @escaping (ClientResponse.Single<Grpc_Testing_Empty>) async throws -> R
    ) async throws -> R where R: Sendable {
        try await self.unimplementedCall(
            request: request,
            serializer: ProtobufSerializer<Grpc_Testing_Empty>(),
            deserializer: ProtobufDeserializer<Grpc_Testing_Empty>(),
            options: options,
            body
        )
    }
}

/// A simple service to test the various types of RPCs and experiment with
/// performance with various types of payload.
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
public struct Grpc_Testing_TestServiceClient: Grpc_Testing_TestService.ClientProtocol {
    private let client: GRPCCore.GRPCClient

    public init(client: GRPCCore.GRPCClient) {
        self.client = client
    }

    /// One empty request followed by one empty response.
    public func emptyCall<R>(
        request: ClientRequest.Single<Grpc_Testing_Empty>,
        serializer: some MessageSerializer<Grpc_Testing_Empty>,
        deserializer: some MessageDeserializer<Grpc_Testing_Empty>,
        options: CallOptions = .defaults,
        _ body: @Sendable @escaping (ClientResponse.Single<Grpc_Testing_Empty>) async throws -> R
    ) async throws -> R where R: Sendable {
        try await self.client.unary(
            request: request,
            descriptor: Grpc_Testing_TestService.Method.EmptyCall.descriptor,
            serializer: serializer,
            deserializer: deserializer,
            options: options,
            handler: body
        )
    }

    /// One request followed by one response.
    public func unaryCall<R>(
        request: ClientRequest.Single<Grpc_Testing_SimpleRequest>,
        serializer: some MessageSerializer<Grpc_Testing_SimpleRequest>,
        deserializer: some MessageDeserializer<Grpc_Testing_SimpleResponse>,
        options: CallOptions = .defaults,
        _ body: @Sendable @escaping (ClientResponse.Single<Grpc_Testing_SimpleResponse>) async throws -> R
    ) async throws -> R where R: Sendable {
        try await self.client.unary(
            request: request,
            descriptor: Grpc_Testing_TestService.Method.UnaryCall.descriptor,
            serializer: serializer,
            deserializer: deserializer,
            options: options,
            handler: body
        )
    }

    /// One request followed by one response. Response has cache control
    /// headers set such that a caching HTTP proxy (such as GFE) can
    /// satisfy subsequent requests.
    public func cacheableUnaryCall<R>(
        request: ClientRequest.Single<Grpc_Testing_SimpleRequest>,
        serializer: some MessageSerializer<Grpc_Testing_SimpleRequest>,
        deserializer: some MessageDeserializer<Grpc_Testing_SimpleResponse>,
        options: CallOptions = .defaults,
        _ body: @Sendable @escaping (ClientResponse.Single<Grpc_Testing_SimpleResponse>) async throws -> R
    ) async throws -> R where R: Sendable {
        try await self.client.unary(
            request: request,
            descriptor: Grpc_Testing_TestService.Method.CacheableUnaryCall.descriptor,
            serializer: serializer,
            deserializer: deserializer,
            options: options,
            handler: body
        )
    }

    /// One request followed by a sequence of responses (streamed download).
    /// The server returns the payload with client desired type and sizes.
    public func streamingOutputCall<R>(
        request: ClientRequest.Single<Grpc_Testing_StreamingOutputCallRequest>,
        serializer: some MessageSerializer<Grpc_Testing_StreamingOutputCallRequest>,
        deserializer: some MessageDeserializer<Grpc_Testing_StreamingOutputCallResponse>,
        options: CallOptions = .defaults,
        _ body: @Sendable @escaping (ClientResponse.Stream<Grpc_Testing_StreamingOutputCallResponse>) async throws -> R
    ) async throws -> R where R: Sendable {
        try await self.client.serverStreaming(
            request: request,
            descriptor: Grpc_Testing_TestService.Method.StreamingOutputCall.descriptor,
            serializer: serializer,
            deserializer: deserializer,
            options: options,
            handler: body
        )
    }

    /// A sequence of requests followed by one response (streamed upload).
    /// The server returns the aggregated size of client payload as the result.
    public func streamingInputCall<R>(
        request: ClientRequest.Stream<Grpc_Testing_StreamingInputCallRequest>,
        serializer: some MessageSerializer<Grpc_Testing_StreamingInputCallRequest>,
        deserializer: some MessageDeserializer<Grpc_Testing_StreamingInputCallResponse>,
        options: CallOptions = .defaults,
        _ body: @Sendable @escaping (ClientResponse.Single<Grpc_Testing_StreamingInputCallResponse>) async throws -> R
    ) async throws -> R where R: Sendable {
        try await self.client.clientStreaming(
            request: request,
            descriptor: Grpc_Testing_TestService.Method.StreamingInputCall.descriptor,
            serializer: serializer,
            deserializer: deserializer,
            options: options,
            handler: body
        )
    }

    /// A sequence of requests with each request served by the server immediately.
    /// As one request could lead to multiple responses, this interface
    /// demonstrates the idea of full duplexing.
    public func fullDuplexCall<R>(
        request: ClientRequest.Stream<Grpc_Testing_StreamingOutputCallRequest>,
        serializer: some MessageSerializer<Grpc_Testing_StreamingOutputCallRequest>,
        deserializer: some MessageDeserializer<Grpc_Testing_StreamingOutputCallResponse>,
        options: CallOptions = .defaults,
        _ body: @Sendable @escaping (ClientResponse.Stream<Grpc_Testing_StreamingOutputCallResponse>) async throws -> R
    ) async throws -> R where R: Sendable {
        try await self.client.bidirectionalStreaming(
            request: request,
            descriptor: Grpc_Testing_TestService.Method.FullDuplexCall.descriptor,
            serializer: serializer,
            deserializer: deserializer,
            options: options,
            handler: body
        )
    }

    /// A sequence of requests followed by a sequence of responses.
    /// The server buffers all the client requests and then serves them in order. A
    /// stream of responses are returned to the client when the server starts with
    /// first request.
    public func halfDuplexCall<R>(
        request: ClientRequest.Stream<Grpc_Testing_StreamingOutputCallRequest>,
        serializer: some MessageSerializer<Grpc_Testing_StreamingOutputCallRequest>,
        deserializer: some MessageDeserializer<Grpc_Testing_StreamingOutputCallResponse>,
        options: CallOptions = .defaults,
        _ body: @Sendable @escaping (ClientResponse.Stream<Grpc_Testing_StreamingOutputCallResponse>) async throws -> R
    ) async throws -> R where R: Sendable {
        try await self.client.bidirectionalStreaming(
            request: request,
            descriptor: Grpc_Testing_TestService.Method.HalfDuplexCall.descriptor,
            serializer: serializer,
            deserializer: deserializer,
            options: options,
            handler: body
        )
    }

    /// The test server will not implement this method. It will be used
    /// to test the behavior when clients call unimplemented methods.
    public func unimplementedCall<R>(
        request: ClientRequest.Single<Grpc_Testing_Empty>,
        serializer: some MessageSerializer<Grpc_Testing_Empty>,
        deserializer: some MessageDeserializer<Grpc_Testing_Empty>,
        options: CallOptions = .defaults,
        _ body: @Sendable @escaping (ClientResponse.Single<Grpc_Testing_Empty>) async throws -> R
    ) async throws -> R where R: Sendable {
        try await self.client.unary(
            request: request,
            descriptor: Grpc_Testing_TestService.Method.UnimplementedCall.descriptor,
            serializer: serializer,
            deserializer: deserializer,
            options: options,
            handler: body
        )
    }
}

/// A simple service NOT implemented at servers so clients can test for
/// that case.
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
public protocol Grpc_Testing_UnimplementedServiceClientProtocol: Sendable {
    /// A call that no server should implement
    func unimplementedCall<R>(
        request: ClientRequest.Single<Grpc_Testing_Empty>,
        serializer: some MessageSerializer<Grpc_Testing_Empty>,
        deserializer: some MessageDeserializer<Grpc_Testing_Empty>,
        options: CallOptions,
        _ body: @Sendable @escaping (ClientResponse.Single<Grpc_Testing_Empty>) async throws -> R
    ) async throws -> R where R: Sendable
}

@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension Grpc_Testing_UnimplementedService.ClientProtocol {
    public func unimplementedCall<R>(
        request: ClientRequest.Single<Grpc_Testing_Empty>,
        options: CallOptions = .defaults,
        _ body: @Sendable @escaping (ClientResponse.Single<Grpc_Testing_Empty>) async throws -> R
    ) async throws -> R where R: Sendable {
        try await self.unimplementedCall(
            request: request,
            serializer: ProtobufSerializer<Grpc_Testing_Empty>(),
            deserializer: ProtobufDeserializer<Grpc_Testing_Empty>(),
            options: options,
            body
        )
    }
}

/// A simple service NOT implemented at servers so clients can test for
/// that case.
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
public struct Grpc_Testing_UnimplementedServiceClient: Grpc_Testing_UnimplementedService.ClientProtocol {
    private let client: GRPCCore.GRPCClient

    public init(client: GRPCCore.GRPCClient) {
        self.client = client
    }

    /// A call that no server should implement
    public func unimplementedCall<R>(
        request: ClientRequest.Single<Grpc_Testing_Empty>,
        serializer: some MessageSerializer<Grpc_Testing_Empty>,
        deserializer: some MessageDeserializer<Grpc_Testing_Empty>,
        options: CallOptions = .defaults,
        _ body: @Sendable @escaping (ClientResponse.Single<Grpc_Testing_Empty>) async throws -> R
    ) async throws -> R where R: Sendable {
        try await self.client.unary(
            request: request,
            descriptor: Grpc_Testing_UnimplementedService.Method.UnimplementedCall.descriptor,
            serializer: serializer,
            deserializer: deserializer,
            options: options,
            handler: body
        )
    }
}

/// A service used to control reconnect server.
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
public protocol Grpc_Testing_ReconnectServiceClientProtocol: Sendable {
    func start<R>(
        request: ClientRequest.Single<Grpc_Testing_ReconnectParams>,
        serializer: some MessageSerializer<Grpc_Testing_ReconnectParams>,
        deserializer: some MessageDeserializer<Grpc_Testing_Empty>,
        options: CallOptions,
        _ body: @Sendable @escaping (ClientResponse.Single<Grpc_Testing_Empty>) async throws -> R
    ) async throws -> R where R: Sendable

    func stop<R>(
        request: ClientRequest.Single<Grpc_Testing_Empty>,
        serializer: some MessageSerializer<Grpc_Testing_Empty>,
        deserializer: some MessageDeserializer<Grpc_Testing_ReconnectInfo>,
        options: CallOptions,
        _ body: @Sendable @escaping (ClientResponse.Single<Grpc_Testing_ReconnectInfo>) async throws -> R
    ) async throws -> R where R: Sendable
}

@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension Grpc_Testing_ReconnectService.ClientProtocol {
    public func start<R>(
        request: ClientRequest.Single<Grpc_Testing_ReconnectParams>,
        options: CallOptions = .defaults,
        _ body: @Sendable @escaping (ClientResponse.Single<Grpc_Testing_Empty>) async throws -> R
    ) async throws -> R where R: Sendable {
        try await self.start(
            request: request,
            serializer: ProtobufSerializer<Grpc_Testing_ReconnectParams>(),
            deserializer: ProtobufDeserializer<Grpc_Testing_Empty>(),
            options: options,
            body
        )
    }

    public func stop<R>(
        request: ClientRequest.Single<Grpc_Testing_Empty>,
        options: CallOptions = .defaults,
        _ body: @Sendable @escaping (ClientResponse.Single<Grpc_Testing_ReconnectInfo>) async throws -> R
    ) async throws -> R where R: Sendable {
        try await self.stop(
            request: request,
            serializer: ProtobufSerializer<Grpc_Testing_Empty>(),
            deserializer: ProtobufDeserializer<Grpc_Testing_ReconnectInfo>(),
            options: options,
            body
        )
    }
}

/// A service used to control reconnect server.
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
public struct Grpc_Testing_ReconnectServiceClient: Grpc_Testing_ReconnectService.ClientProtocol {
    private let client: GRPCCore.GRPCClient

    public init(client: GRPCCore.GRPCClient) {
        self.client = client
    }

    public func start<R>(
        request: ClientRequest.Single<Grpc_Testing_ReconnectParams>,
        serializer: some MessageSerializer<Grpc_Testing_ReconnectParams>,
        deserializer: some MessageDeserializer<Grpc_Testing_Empty>,
        options: CallOptions = .defaults,
        _ body: @Sendable @escaping (ClientResponse.Single<Grpc_Testing_Empty>) async throws -> R
    ) async throws -> R where R: Sendable {
        try await self.client.unary(
            request: request,
            descriptor: Grpc_Testing_ReconnectService.Method.Start.descriptor,
            serializer: serializer,
            deserializer: deserializer,
            options: options,
            handler: body
        )
    }

    public func stop<R>(
        request: ClientRequest.Single<Grpc_Testing_Empty>,
        serializer: some MessageSerializer<Grpc_Testing_Empty>,
        deserializer: some MessageDeserializer<Grpc_Testing_ReconnectInfo>,
        options: CallOptions = .defaults,
        _ body: @Sendable @escaping (ClientResponse.Single<Grpc_Testing_ReconnectInfo>) async throws -> R
    ) async throws -> R where R: Sendable {
        try await self.client.unary(
            request: request,
            descriptor: Grpc_Testing_ReconnectService.Method.Stop.descriptor,
            serializer: serializer,
            deserializer: deserializer,
            options: options,
            handler: body
        )
    }
}