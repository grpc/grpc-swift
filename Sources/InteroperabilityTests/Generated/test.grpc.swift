// Copyright 2015-2016 gRPC authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// An integration test service that covers all the method signature permutations
// of unary/streaming requests/responses.

// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the gRPC Swift generator plugin for the protocol buffer compiler.
// Source: src/proto/grpc/testing/test.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/grpc/grpc-swift

public import GRPCCore
internal import GRPCProtobuf

public enum Grpc_Testing_ReconnectService {
    public static let descriptor = GRPCCore.ServiceDescriptor.grpc_testing_ReconnectService
    public enum Method {
        public enum Start {
            public typealias Input = Grpc_Testing_ReconnectParams
            public typealias Output = Grpc_Testing_Empty
            public static let descriptor = GRPCCore.MethodDescriptor(
                service: Grpc_Testing_ReconnectService.descriptor.fullyQualifiedService,
                method: "Start"
            )
        }
        public enum Stop {
            public typealias Input = Grpc_Testing_Empty
            public typealias Output = Grpc_Testing_ReconnectInfo
            public static let descriptor = GRPCCore.MethodDescriptor(
                service: Grpc_Testing_ReconnectService.descriptor.fullyQualifiedService,
                method: "Stop"
            )
        }
        public static let descriptors: [GRPCCore.MethodDescriptor] = [
            Start.descriptor,
            Stop.descriptor
        ]
    }
    @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
    public typealias StreamingServiceProtocol = Grpc_Testing_ReconnectServiceStreamingServiceProtocol
    @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
    public typealias ServiceProtocol = Grpc_Testing_ReconnectServiceServiceProtocol
    @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
    public typealias ClientProtocol = Grpc_Testing_ReconnectServiceClientProtocol
    @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
    public typealias Client = Grpc_Testing_ReconnectServiceClient
}

extension GRPCCore.ServiceDescriptor {
    public static let grpc_testing_ReconnectService = Self(
        package: "grpc.testing",
        service: "ReconnectService"
    )
}

public enum Grpc_Testing_TestService {
    public static let descriptor = GRPCCore.ServiceDescriptor.grpc_testing_TestService
    public enum Method {
        public enum EmptyCall {
            public typealias Input = Grpc_Testing_Empty
            public typealias Output = Grpc_Testing_Empty
            public static let descriptor = GRPCCore.MethodDescriptor(
                service: Grpc_Testing_TestService.descriptor.fullyQualifiedService,
                method: "EmptyCall"
            )
        }
        public enum UnaryCall {
            public typealias Input = Grpc_Testing_SimpleRequest
            public typealias Output = Grpc_Testing_SimpleResponse
            public static let descriptor = GRPCCore.MethodDescriptor(
                service: Grpc_Testing_TestService.descriptor.fullyQualifiedService,
                method: "UnaryCall"
            )
        }
        public enum CacheableUnaryCall {
            public typealias Input = Grpc_Testing_SimpleRequest
            public typealias Output = Grpc_Testing_SimpleResponse
            public static let descriptor = GRPCCore.MethodDescriptor(
                service: Grpc_Testing_TestService.descriptor.fullyQualifiedService,
                method: "CacheableUnaryCall"
            )
        }
        public enum StreamingOutputCall {
            public typealias Input = Grpc_Testing_StreamingOutputCallRequest
            public typealias Output = Grpc_Testing_StreamingOutputCallResponse
            public static let descriptor = GRPCCore.MethodDescriptor(
                service: Grpc_Testing_TestService.descriptor.fullyQualifiedService,
                method: "StreamingOutputCall"
            )
        }
        public enum StreamingInputCall {
            public typealias Input = Grpc_Testing_StreamingInputCallRequest
            public typealias Output = Grpc_Testing_StreamingInputCallResponse
            public static let descriptor = GRPCCore.MethodDescriptor(
                service: Grpc_Testing_TestService.descriptor.fullyQualifiedService,
                method: "StreamingInputCall"
            )
        }
        public enum FullDuplexCall {
            public typealias Input = Grpc_Testing_StreamingOutputCallRequest
            public typealias Output = Grpc_Testing_StreamingOutputCallResponse
            public static let descriptor = GRPCCore.MethodDescriptor(
                service: Grpc_Testing_TestService.descriptor.fullyQualifiedService,
                method: "FullDuplexCall"
            )
        }
        public enum HalfDuplexCall {
            public typealias Input = Grpc_Testing_StreamingOutputCallRequest
            public typealias Output = Grpc_Testing_StreamingOutputCallResponse
            public static let descriptor = GRPCCore.MethodDescriptor(
                service: Grpc_Testing_TestService.descriptor.fullyQualifiedService,
                method: "HalfDuplexCall"
            )
        }
        public enum UnimplementedCall {
            public typealias Input = Grpc_Testing_Empty
            public typealias Output = Grpc_Testing_Empty
            public static let descriptor = GRPCCore.MethodDescriptor(
                service: Grpc_Testing_TestService.descriptor.fullyQualifiedService,
                method: "UnimplementedCall"
            )
        }
        public static let descriptors: [GRPCCore.MethodDescriptor] = [
            EmptyCall.descriptor,
            UnaryCall.descriptor,
            CacheableUnaryCall.descriptor,
            StreamingOutputCall.descriptor,
            StreamingInputCall.descriptor,
            FullDuplexCall.descriptor,
            HalfDuplexCall.descriptor,
            UnimplementedCall.descriptor
        ]
    }
    @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
    public typealias StreamingServiceProtocol = Grpc_Testing_TestServiceStreamingServiceProtocol
    @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
    public typealias ServiceProtocol = Grpc_Testing_TestServiceServiceProtocol
    @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
    public typealias ClientProtocol = Grpc_Testing_TestServiceClientProtocol
    @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
    public typealias Client = Grpc_Testing_TestServiceClient
}

extension GRPCCore.ServiceDescriptor {
    public static let grpc_testing_TestService = Self(
        package: "grpc.testing",
        service: "TestService"
    )
}

public enum Grpc_Testing_UnimplementedService {
    public static let descriptor = GRPCCore.ServiceDescriptor.grpc_testing_UnimplementedService
    public enum Method {
        public enum UnimplementedCall {
            public typealias Input = Grpc_Testing_Empty
            public typealias Output = Grpc_Testing_Empty
            public static let descriptor = GRPCCore.MethodDescriptor(
                service: Grpc_Testing_UnimplementedService.descriptor.fullyQualifiedService,
                method: "UnimplementedCall"
            )
        }
        public static let descriptors: [GRPCCore.MethodDescriptor] = [
            UnimplementedCall.descriptor
        ]
    }
    @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
    public typealias StreamingServiceProtocol = Grpc_Testing_UnimplementedServiceStreamingServiceProtocol
    @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
    public typealias ServiceProtocol = Grpc_Testing_UnimplementedServiceServiceProtocol
    @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
    public typealias ClientProtocol = Grpc_Testing_UnimplementedServiceClientProtocol
    @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
    public typealias Client = Grpc_Testing_UnimplementedServiceClient
}

extension GRPCCore.ServiceDescriptor {
    public static let grpc_testing_UnimplementedService = Self(
        package: "grpc.testing",
        service: "UnimplementedService"
    )
}

/// A simple service to test the various types of RPCs and experiment with
/// performance with various types of payload.
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
public protocol Grpc_Testing_TestServiceStreamingServiceProtocol: GRPCCore.RegistrableRPCService {
    /// One empty request followed by one empty response.
    func emptyCall(
        request: GRPCCore.ServerRequest.Stream<Grpc_Testing_Empty>,
        context: GRPCCore.ServerContext
    ) async throws -> GRPCCore.ServerResponse.Stream<Grpc_Testing_Empty>
    
    /// One request followed by one response.
    func unaryCall(
        request: GRPCCore.ServerRequest.Stream<Grpc_Testing_SimpleRequest>,
        context: GRPCCore.ServerContext
    ) async throws -> GRPCCore.ServerResponse.Stream<Grpc_Testing_SimpleResponse>
    
    /// One request followed by one response. Response has cache control
    /// headers set such that a caching HTTP proxy (such as GFE) can
    /// satisfy subsequent requests.
    func cacheableUnaryCall(
        request: GRPCCore.ServerRequest.Stream<Grpc_Testing_SimpleRequest>,
        context: GRPCCore.ServerContext
    ) async throws -> GRPCCore.ServerResponse.Stream<Grpc_Testing_SimpleResponse>
    
    /// One request followed by a sequence of responses (streamed download).
    /// The server returns the payload with client desired type and sizes.
    func streamingOutputCall(
        request: GRPCCore.ServerRequest.Stream<Grpc_Testing_StreamingOutputCallRequest>,
        context: GRPCCore.ServerContext
    ) async throws -> GRPCCore.ServerResponse.Stream<Grpc_Testing_StreamingOutputCallResponse>
    
    /// A sequence of requests followed by one response (streamed upload).
    /// The server returns the aggregated size of client payload as the result.
    func streamingInputCall(
        request: GRPCCore.ServerRequest.Stream<Grpc_Testing_StreamingInputCallRequest>,
        context: GRPCCore.ServerContext
    ) async throws -> GRPCCore.ServerResponse.Stream<Grpc_Testing_StreamingInputCallResponse>
    
    /// A sequence of requests with each request served by the server immediately.
    /// As one request could lead to multiple responses, this interface
    /// demonstrates the idea of full duplexing.
    func fullDuplexCall(
        request: GRPCCore.ServerRequest.Stream<Grpc_Testing_StreamingOutputCallRequest>,
        context: GRPCCore.ServerContext
    ) async throws -> GRPCCore.ServerResponse.Stream<Grpc_Testing_StreamingOutputCallResponse>
    
    /// A sequence of requests followed by a sequence of responses.
    /// The server buffers all the client requests and then serves them in order. A
    /// stream of responses are returned to the client when the server starts with
    /// first request.
    func halfDuplexCall(
        request: GRPCCore.ServerRequest.Stream<Grpc_Testing_StreamingOutputCallRequest>,
        context: GRPCCore.ServerContext
    ) async throws -> GRPCCore.ServerResponse.Stream<Grpc_Testing_StreamingOutputCallResponse>
    
    /// The test server will not implement this method. It will be used
    /// to test the behavior when clients call unimplemented methods.
    func unimplementedCall(
        request: GRPCCore.ServerRequest.Stream<Grpc_Testing_Empty>,
        context: GRPCCore.ServerContext
    ) async throws -> GRPCCore.ServerResponse.Stream<Grpc_Testing_Empty>
}

/// Conformance to `GRPCCore.RegistrableRPCService`.
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Grpc_Testing_TestService.StreamingServiceProtocol {
    @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
    public func registerMethods(with router: inout GRPCCore.RPCRouter) {
        router.registerHandler(
            forMethod: Grpc_Testing_TestService.Method.EmptyCall.descriptor,
            deserializer: GRPCProtobuf.ProtobufDeserializer<Grpc_Testing_Empty>(),
            serializer: GRPCProtobuf.ProtobufSerializer<Grpc_Testing_Empty>(),
            handler: { request, context in
                try await self.emptyCall(
                    request: request,
                    context: context
                )
            }
        )
        router.registerHandler(
            forMethod: Grpc_Testing_TestService.Method.UnaryCall.descriptor,
            deserializer: GRPCProtobuf.ProtobufDeserializer<Grpc_Testing_SimpleRequest>(),
            serializer: GRPCProtobuf.ProtobufSerializer<Grpc_Testing_SimpleResponse>(),
            handler: { request, context in
                try await self.unaryCall(
                    request: request,
                    context: context
                )
            }
        )
        router.registerHandler(
            forMethod: Grpc_Testing_TestService.Method.CacheableUnaryCall.descriptor,
            deserializer: GRPCProtobuf.ProtobufDeserializer<Grpc_Testing_SimpleRequest>(),
            serializer: GRPCProtobuf.ProtobufSerializer<Grpc_Testing_SimpleResponse>(),
            handler: { request, context in
                try await self.cacheableUnaryCall(
                    request: request,
                    context: context
                )
            }
        )
        router.registerHandler(
            forMethod: Grpc_Testing_TestService.Method.StreamingOutputCall.descriptor,
            deserializer: GRPCProtobuf.ProtobufDeserializer<Grpc_Testing_StreamingOutputCallRequest>(),
            serializer: GRPCProtobuf.ProtobufSerializer<Grpc_Testing_StreamingOutputCallResponse>(),
            handler: { request, context in
                try await self.streamingOutputCall(
                    request: request,
                    context: context
                )
            }
        )
        router.registerHandler(
            forMethod: Grpc_Testing_TestService.Method.StreamingInputCall.descriptor,
            deserializer: GRPCProtobuf.ProtobufDeserializer<Grpc_Testing_StreamingInputCallRequest>(),
            serializer: GRPCProtobuf.ProtobufSerializer<Grpc_Testing_StreamingInputCallResponse>(),
            handler: { request, context in
                try await self.streamingInputCall(
                    request: request,
                    context: context
                )
            }
        )
        router.registerHandler(
            forMethod: Grpc_Testing_TestService.Method.FullDuplexCall.descriptor,
            deserializer: GRPCProtobuf.ProtobufDeserializer<Grpc_Testing_StreamingOutputCallRequest>(),
            serializer: GRPCProtobuf.ProtobufSerializer<Grpc_Testing_StreamingOutputCallResponse>(),
            handler: { request, context in
                try await self.fullDuplexCall(
                    request: request,
                    context: context
                )
            }
        )
        router.registerHandler(
            forMethod: Grpc_Testing_TestService.Method.HalfDuplexCall.descriptor,
            deserializer: GRPCProtobuf.ProtobufDeserializer<Grpc_Testing_StreamingOutputCallRequest>(),
            serializer: GRPCProtobuf.ProtobufSerializer<Grpc_Testing_StreamingOutputCallResponse>(),
            handler: { request, context in
                try await self.halfDuplexCall(
                    request: request,
                    context: context
                )
            }
        )
        router.registerHandler(
            forMethod: Grpc_Testing_TestService.Method.UnimplementedCall.descriptor,
            deserializer: GRPCProtobuf.ProtobufDeserializer<Grpc_Testing_Empty>(),
            serializer: GRPCProtobuf.ProtobufSerializer<Grpc_Testing_Empty>(),
            handler: { request, context in
                try await self.unimplementedCall(
                    request: request,
                    context: context
                )
            }
        )
    }
}

/// A simple service to test the various types of RPCs and experiment with
/// performance with various types of payload.
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
public protocol Grpc_Testing_TestServiceServiceProtocol: Grpc_Testing_TestService.StreamingServiceProtocol {
    /// One empty request followed by one empty response.
    func emptyCall(
        request: GRPCCore.ServerRequest.Single<Grpc_Testing_Empty>,
        context: GRPCCore.ServerContext
    ) async throws -> GRPCCore.ServerResponse.Single<Grpc_Testing_Empty>
    
    /// One request followed by one response.
    func unaryCall(
        request: GRPCCore.ServerRequest.Single<Grpc_Testing_SimpleRequest>,
        context: GRPCCore.ServerContext
    ) async throws -> GRPCCore.ServerResponse.Single<Grpc_Testing_SimpleResponse>
    
    /// One request followed by one response. Response has cache control
    /// headers set such that a caching HTTP proxy (such as GFE) can
    /// satisfy subsequent requests.
    func cacheableUnaryCall(
        request: GRPCCore.ServerRequest.Single<Grpc_Testing_SimpleRequest>,
        context: GRPCCore.ServerContext
    ) async throws -> GRPCCore.ServerResponse.Single<Grpc_Testing_SimpleResponse>
    
    /// One request followed by a sequence of responses (streamed download).
    /// The server returns the payload with client desired type and sizes.
    func streamingOutputCall(
        request: GRPCCore.ServerRequest.Single<Grpc_Testing_StreamingOutputCallRequest>,
        context: GRPCCore.ServerContext
    ) async throws -> GRPCCore.ServerResponse.Stream<Grpc_Testing_StreamingOutputCallResponse>
    
    /// A sequence of requests followed by one response (streamed upload).
    /// The server returns the aggregated size of client payload as the result.
    func streamingInputCall(
        request: GRPCCore.ServerRequest.Stream<Grpc_Testing_StreamingInputCallRequest>,
        context: GRPCCore.ServerContext
    ) async throws -> GRPCCore.ServerResponse.Single<Grpc_Testing_StreamingInputCallResponse>
    
    /// A sequence of requests with each request served by the server immediately.
    /// As one request could lead to multiple responses, this interface
    /// demonstrates the idea of full duplexing.
    func fullDuplexCall(
        request: GRPCCore.ServerRequest.Stream<Grpc_Testing_StreamingOutputCallRequest>,
        context: GRPCCore.ServerContext
    ) async throws -> GRPCCore.ServerResponse.Stream<Grpc_Testing_StreamingOutputCallResponse>
    
    /// A sequence of requests followed by a sequence of responses.
    /// The server buffers all the client requests and then serves them in order. A
    /// stream of responses are returned to the client when the server starts with
    /// first request.
    func halfDuplexCall(
        request: GRPCCore.ServerRequest.Stream<Grpc_Testing_StreamingOutputCallRequest>,
        context: GRPCCore.ServerContext
    ) async throws -> GRPCCore.ServerResponse.Stream<Grpc_Testing_StreamingOutputCallResponse>
    
    /// The test server will not implement this method. It will be used
    /// to test the behavior when clients call unimplemented methods.
    func unimplementedCall(
        request: GRPCCore.ServerRequest.Single<Grpc_Testing_Empty>,
        context: GRPCCore.ServerContext
    ) async throws -> GRPCCore.ServerResponse.Single<Grpc_Testing_Empty>
}

/// Partial conformance to `Grpc_Testing_TestServiceStreamingServiceProtocol`.
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Grpc_Testing_TestService.ServiceProtocol {
    public func emptyCall(
        request: GRPCCore.ServerRequest.Stream<Grpc_Testing_Empty>,
        context: GRPCCore.ServerContext
    ) async throws -> GRPCCore.ServerResponse.Stream<Grpc_Testing_Empty> {
        let response = try await self.emptyCall(
            request: GRPCCore.ServerRequest.Single(stream: request),
            context: context
        )
        return GRPCCore.ServerResponse.Stream(single: response)
    }
    
    public func unaryCall(
        request: GRPCCore.ServerRequest.Stream<Grpc_Testing_SimpleRequest>,
        context: GRPCCore.ServerContext
    ) async throws -> GRPCCore.ServerResponse.Stream<Grpc_Testing_SimpleResponse> {
        let response = try await self.unaryCall(
            request: GRPCCore.ServerRequest.Single(stream: request),
            context: context
        )
        return GRPCCore.ServerResponse.Stream(single: response)
    }
    
    public func cacheableUnaryCall(
        request: GRPCCore.ServerRequest.Stream<Grpc_Testing_SimpleRequest>,
        context: GRPCCore.ServerContext
    ) async throws -> GRPCCore.ServerResponse.Stream<Grpc_Testing_SimpleResponse> {
        let response = try await self.cacheableUnaryCall(
            request: GRPCCore.ServerRequest.Single(stream: request),
            context: context
        )
        return GRPCCore.ServerResponse.Stream(single: response)
    }
    
    public func streamingOutputCall(
        request: GRPCCore.ServerRequest.Stream<Grpc_Testing_StreamingOutputCallRequest>,
        context: GRPCCore.ServerContext
    ) async throws -> GRPCCore.ServerResponse.Stream<Grpc_Testing_StreamingOutputCallResponse> {
        let response = try await self.streamingOutputCall(
            request: GRPCCore.ServerRequest.Single(stream: request),
            context: context
        )
        return response
    }
    
    public func streamingInputCall(
        request: GRPCCore.ServerRequest.Stream<Grpc_Testing_StreamingInputCallRequest>,
        context: GRPCCore.ServerContext
    ) async throws -> GRPCCore.ServerResponse.Stream<Grpc_Testing_StreamingInputCallResponse> {
        let response = try await self.streamingInputCall(
            request: request,
            context: context
        )
        return GRPCCore.ServerResponse.Stream(single: response)
    }
    
    public func unimplementedCall(
        request: GRPCCore.ServerRequest.Stream<Grpc_Testing_Empty>,
        context: GRPCCore.ServerContext
    ) async throws -> GRPCCore.ServerResponse.Stream<Grpc_Testing_Empty> {
        let response = try await self.unimplementedCall(
            request: GRPCCore.ServerRequest.Single(stream: request),
            context: context
        )
        return GRPCCore.ServerResponse.Stream(single: response)
    }
}

/// A simple service NOT implemented at servers so clients can test for
/// that case.
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
public protocol Grpc_Testing_UnimplementedServiceStreamingServiceProtocol: GRPCCore.RegistrableRPCService {
    /// A call that no server should implement
    func unimplementedCall(
        request: GRPCCore.ServerRequest.Stream<Grpc_Testing_Empty>,
        context: GRPCCore.ServerContext
    ) async throws -> GRPCCore.ServerResponse.Stream<Grpc_Testing_Empty>
}

/// Conformance to `GRPCCore.RegistrableRPCService`.
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Grpc_Testing_UnimplementedService.StreamingServiceProtocol {
    @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
    public func registerMethods(with router: inout GRPCCore.RPCRouter) {
        router.registerHandler(
            forMethod: Grpc_Testing_UnimplementedService.Method.UnimplementedCall.descriptor,
            deserializer: GRPCProtobuf.ProtobufDeserializer<Grpc_Testing_Empty>(),
            serializer: GRPCProtobuf.ProtobufSerializer<Grpc_Testing_Empty>(),
            handler: { request, context in
                try await self.unimplementedCall(
                    request: request,
                    context: context
                )
            }
        )
    }
}

/// A simple service NOT implemented at servers so clients can test for
/// that case.
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
public protocol Grpc_Testing_UnimplementedServiceServiceProtocol: Grpc_Testing_UnimplementedService.StreamingServiceProtocol {
    /// A call that no server should implement
    func unimplementedCall(
        request: GRPCCore.ServerRequest.Single<Grpc_Testing_Empty>,
        context: GRPCCore.ServerContext
    ) async throws -> GRPCCore.ServerResponse.Single<Grpc_Testing_Empty>
}

/// Partial conformance to `Grpc_Testing_UnimplementedServiceStreamingServiceProtocol`.
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Grpc_Testing_UnimplementedService.ServiceProtocol {
    public func unimplementedCall(
        request: GRPCCore.ServerRequest.Stream<Grpc_Testing_Empty>,
        context: GRPCCore.ServerContext
    ) async throws -> GRPCCore.ServerResponse.Stream<Grpc_Testing_Empty> {
        let response = try await self.unimplementedCall(
            request: GRPCCore.ServerRequest.Single(stream: request),
            context: context
        )
        return GRPCCore.ServerResponse.Stream(single: response)
    }
}

/// A service used to control reconnect server.
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
public protocol Grpc_Testing_ReconnectServiceStreamingServiceProtocol: GRPCCore.RegistrableRPCService {
    func start(
        request: GRPCCore.ServerRequest.Stream<Grpc_Testing_ReconnectParams>,
        context: GRPCCore.ServerContext
    ) async throws -> GRPCCore.ServerResponse.Stream<Grpc_Testing_Empty>
    
    func stop(
        request: GRPCCore.ServerRequest.Stream<Grpc_Testing_Empty>,
        context: GRPCCore.ServerContext
    ) async throws -> GRPCCore.ServerResponse.Stream<Grpc_Testing_ReconnectInfo>
}

/// Conformance to `GRPCCore.RegistrableRPCService`.
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Grpc_Testing_ReconnectService.StreamingServiceProtocol {
    @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
    public func registerMethods(with router: inout GRPCCore.RPCRouter) {
        router.registerHandler(
            forMethod: Grpc_Testing_ReconnectService.Method.Start.descriptor,
            deserializer: GRPCProtobuf.ProtobufDeserializer<Grpc_Testing_ReconnectParams>(),
            serializer: GRPCProtobuf.ProtobufSerializer<Grpc_Testing_Empty>(),
            handler: { request, context in
                try await self.start(
                    request: request,
                    context: context
                )
            }
        )
        router.registerHandler(
            forMethod: Grpc_Testing_ReconnectService.Method.Stop.descriptor,
            deserializer: GRPCProtobuf.ProtobufDeserializer<Grpc_Testing_Empty>(),
            serializer: GRPCProtobuf.ProtobufSerializer<Grpc_Testing_ReconnectInfo>(),
            handler: { request, context in
                try await self.stop(
                    request: request,
                    context: context
                )
            }
        )
    }
}

/// A service used to control reconnect server.
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
public protocol Grpc_Testing_ReconnectServiceServiceProtocol: Grpc_Testing_ReconnectService.StreamingServiceProtocol {
    func start(
        request: GRPCCore.ServerRequest.Single<Grpc_Testing_ReconnectParams>,
        context: GRPCCore.ServerContext
    ) async throws -> GRPCCore.ServerResponse.Single<Grpc_Testing_Empty>
    
    func stop(
        request: GRPCCore.ServerRequest.Single<Grpc_Testing_Empty>,
        context: GRPCCore.ServerContext
    ) async throws -> GRPCCore.ServerResponse.Single<Grpc_Testing_ReconnectInfo>
}

/// Partial conformance to `Grpc_Testing_ReconnectServiceStreamingServiceProtocol`.
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Grpc_Testing_ReconnectService.ServiceProtocol {
    public func start(
        request: GRPCCore.ServerRequest.Stream<Grpc_Testing_ReconnectParams>,
        context: GRPCCore.ServerContext
    ) async throws -> GRPCCore.ServerResponse.Stream<Grpc_Testing_Empty> {
        let response = try await self.start(
            request: GRPCCore.ServerRequest.Single(stream: request),
            context: context
        )
        return GRPCCore.ServerResponse.Stream(single: response)
    }
    
    public func stop(
        request: GRPCCore.ServerRequest.Stream<Grpc_Testing_Empty>,
        context: GRPCCore.ServerContext
    ) async throws -> GRPCCore.ServerResponse.Stream<Grpc_Testing_ReconnectInfo> {
        let response = try await self.stop(
            request: GRPCCore.ServerRequest.Single(stream: request),
            context: context
        )
        return GRPCCore.ServerResponse.Stream(single: response)
    }
}

/// A simple service to test the various types of RPCs and experiment with
/// performance with various types of payload.
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
public protocol Grpc_Testing_TestServiceClientProtocol: Sendable {
    /// One empty request followed by one empty response.
    func emptyCall<R>(
        request: GRPCCore.ClientRequest.Single<Grpc_Testing_Empty>,
        serializer: some GRPCCore.MessageSerializer<Grpc_Testing_Empty>,
        deserializer: some GRPCCore.MessageDeserializer<Grpc_Testing_Empty>,
        options: GRPCCore.CallOptions,
        _ body: @Sendable @escaping (GRPCCore.ClientResponse.Single<Grpc_Testing_Empty>) async throws -> R
    ) async throws -> R where R: Sendable
    
    /// One request followed by one response.
    func unaryCall<R>(
        request: GRPCCore.ClientRequest.Single<Grpc_Testing_SimpleRequest>,
        serializer: some GRPCCore.MessageSerializer<Grpc_Testing_SimpleRequest>,
        deserializer: some GRPCCore.MessageDeserializer<Grpc_Testing_SimpleResponse>,
        options: GRPCCore.CallOptions,
        _ body: @Sendable @escaping (GRPCCore.ClientResponse.Single<Grpc_Testing_SimpleResponse>) async throws -> R
    ) async throws -> R where R: Sendable
    
    /// One request followed by one response. Response has cache control
    /// headers set such that a caching HTTP proxy (such as GFE) can
    /// satisfy subsequent requests.
    func cacheableUnaryCall<R>(
        request: GRPCCore.ClientRequest.Single<Grpc_Testing_SimpleRequest>,
        serializer: some GRPCCore.MessageSerializer<Grpc_Testing_SimpleRequest>,
        deserializer: some GRPCCore.MessageDeserializer<Grpc_Testing_SimpleResponse>,
        options: GRPCCore.CallOptions,
        _ body: @Sendable @escaping (GRPCCore.ClientResponse.Single<Grpc_Testing_SimpleResponse>) async throws -> R
    ) async throws -> R where R: Sendable
    
    /// One request followed by a sequence of responses (streamed download).
    /// The server returns the payload with client desired type and sizes.
    func streamingOutputCall<R>(
        request: GRPCCore.ClientRequest.Single<Grpc_Testing_StreamingOutputCallRequest>,
        serializer: some GRPCCore.MessageSerializer<Grpc_Testing_StreamingOutputCallRequest>,
        deserializer: some GRPCCore.MessageDeserializer<Grpc_Testing_StreamingOutputCallResponse>,
        options: GRPCCore.CallOptions,
        _ body: @Sendable @escaping (GRPCCore.ClientResponse.Stream<Grpc_Testing_StreamingOutputCallResponse>) async throws -> R
    ) async throws -> R where R: Sendable
    
    /// A sequence of requests followed by one response (streamed upload).
    /// The server returns the aggregated size of client payload as the result.
    func streamingInputCall<R>(
        request: GRPCCore.ClientRequest.Stream<Grpc_Testing_StreamingInputCallRequest>,
        serializer: some GRPCCore.MessageSerializer<Grpc_Testing_StreamingInputCallRequest>,
        deserializer: some GRPCCore.MessageDeserializer<Grpc_Testing_StreamingInputCallResponse>,
        options: GRPCCore.CallOptions,
        _ body: @Sendable @escaping (GRPCCore.ClientResponse.Single<Grpc_Testing_StreamingInputCallResponse>) async throws -> R
    ) async throws -> R where R: Sendable
    
    /// A sequence of requests with each request served by the server immediately.
    /// As one request could lead to multiple responses, this interface
    /// demonstrates the idea of full duplexing.
    func fullDuplexCall<R>(
        request: GRPCCore.ClientRequest.Stream<Grpc_Testing_StreamingOutputCallRequest>,
        serializer: some GRPCCore.MessageSerializer<Grpc_Testing_StreamingOutputCallRequest>,
        deserializer: some GRPCCore.MessageDeserializer<Grpc_Testing_StreamingOutputCallResponse>,
        options: GRPCCore.CallOptions,
        _ body: @Sendable @escaping (GRPCCore.ClientResponse.Stream<Grpc_Testing_StreamingOutputCallResponse>) async throws -> R
    ) async throws -> R where R: Sendable
    
    /// A sequence of requests followed by a sequence of responses.
    /// The server buffers all the client requests and then serves them in order. A
    /// stream of responses are returned to the client when the server starts with
    /// first request.
    func halfDuplexCall<R>(
        request: GRPCCore.ClientRequest.Stream<Grpc_Testing_StreamingOutputCallRequest>,
        serializer: some GRPCCore.MessageSerializer<Grpc_Testing_StreamingOutputCallRequest>,
        deserializer: some GRPCCore.MessageDeserializer<Grpc_Testing_StreamingOutputCallResponse>,
        options: GRPCCore.CallOptions,
        _ body: @Sendable @escaping (GRPCCore.ClientResponse.Stream<Grpc_Testing_StreamingOutputCallResponse>) async throws -> R
    ) async throws -> R where R: Sendable
    
    /// The test server will not implement this method. It will be used
    /// to test the behavior when clients call unimplemented methods.
    func unimplementedCall<R>(
        request: GRPCCore.ClientRequest.Single<Grpc_Testing_Empty>,
        serializer: some GRPCCore.MessageSerializer<Grpc_Testing_Empty>,
        deserializer: some GRPCCore.MessageDeserializer<Grpc_Testing_Empty>,
        options: GRPCCore.CallOptions,
        _ body: @Sendable @escaping (GRPCCore.ClientResponse.Single<Grpc_Testing_Empty>) async throws -> R
    ) async throws -> R where R: Sendable
}

@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Grpc_Testing_TestService.ClientProtocol {
    public func emptyCall<R>(
        request: GRPCCore.ClientRequest.Single<Grpc_Testing_Empty>,
        options: GRPCCore.CallOptions = .defaults,
        _ body: @Sendable @escaping (GRPCCore.ClientResponse.Single<Grpc_Testing_Empty>) async throws -> R = {
            try $0.message
        }
    ) async throws -> R where R: Sendable {
        try await self.emptyCall(
            request: request,
            serializer: GRPCProtobuf.ProtobufSerializer<Grpc_Testing_Empty>(),
            deserializer: GRPCProtobuf.ProtobufDeserializer<Grpc_Testing_Empty>(),
            options: options,
            body
        )
    }
    
    public func unaryCall<R>(
        request: GRPCCore.ClientRequest.Single<Grpc_Testing_SimpleRequest>,
        options: GRPCCore.CallOptions = .defaults,
        _ body: @Sendable @escaping (GRPCCore.ClientResponse.Single<Grpc_Testing_SimpleResponse>) async throws -> R = {
            try $0.message
        }
    ) async throws -> R where R: Sendable {
        try await self.unaryCall(
            request: request,
            serializer: GRPCProtobuf.ProtobufSerializer<Grpc_Testing_SimpleRequest>(),
            deserializer: GRPCProtobuf.ProtobufDeserializer<Grpc_Testing_SimpleResponse>(),
            options: options,
            body
        )
    }
    
    public func cacheableUnaryCall<R>(
        request: GRPCCore.ClientRequest.Single<Grpc_Testing_SimpleRequest>,
        options: GRPCCore.CallOptions = .defaults,
        _ body: @Sendable @escaping (GRPCCore.ClientResponse.Single<Grpc_Testing_SimpleResponse>) async throws -> R = {
            try $0.message
        }
    ) async throws -> R where R: Sendable {
        try await self.cacheableUnaryCall(
            request: request,
            serializer: GRPCProtobuf.ProtobufSerializer<Grpc_Testing_SimpleRequest>(),
            deserializer: GRPCProtobuf.ProtobufDeserializer<Grpc_Testing_SimpleResponse>(),
            options: options,
            body
        )
    }
    
    public func streamingOutputCall<R>(
        request: GRPCCore.ClientRequest.Single<Grpc_Testing_StreamingOutputCallRequest>,
        options: GRPCCore.CallOptions = .defaults,
        _ body: @Sendable @escaping (GRPCCore.ClientResponse.Stream<Grpc_Testing_StreamingOutputCallResponse>) async throws -> R
    ) async throws -> R where R: Sendable {
        try await self.streamingOutputCall(
            request: request,
            serializer: GRPCProtobuf.ProtobufSerializer<Grpc_Testing_StreamingOutputCallRequest>(),
            deserializer: GRPCProtobuf.ProtobufDeserializer<Grpc_Testing_StreamingOutputCallResponse>(),
            options: options,
            body
        )
    }
    
    public func streamingInputCall<R>(
        request: GRPCCore.ClientRequest.Stream<Grpc_Testing_StreamingInputCallRequest>,
        options: GRPCCore.CallOptions = .defaults,
        _ body: @Sendable @escaping (GRPCCore.ClientResponse.Single<Grpc_Testing_StreamingInputCallResponse>) async throws -> R = {
            try $0.message
        }
    ) async throws -> R where R: Sendable {
        try await self.streamingInputCall(
            request: request,
            serializer: GRPCProtobuf.ProtobufSerializer<Grpc_Testing_StreamingInputCallRequest>(),
            deserializer: GRPCProtobuf.ProtobufDeserializer<Grpc_Testing_StreamingInputCallResponse>(),
            options: options,
            body
        )
    }
    
    public func fullDuplexCall<R>(
        request: GRPCCore.ClientRequest.Stream<Grpc_Testing_StreamingOutputCallRequest>,
        options: GRPCCore.CallOptions = .defaults,
        _ body: @Sendable @escaping (GRPCCore.ClientResponse.Stream<Grpc_Testing_StreamingOutputCallResponse>) async throws -> R
    ) async throws -> R where R: Sendable {
        try await self.fullDuplexCall(
            request: request,
            serializer: GRPCProtobuf.ProtobufSerializer<Grpc_Testing_StreamingOutputCallRequest>(),
            deserializer: GRPCProtobuf.ProtobufDeserializer<Grpc_Testing_StreamingOutputCallResponse>(),
            options: options,
            body
        )
    }
    
    public func halfDuplexCall<R>(
        request: GRPCCore.ClientRequest.Stream<Grpc_Testing_StreamingOutputCallRequest>,
        options: GRPCCore.CallOptions = .defaults,
        _ body: @Sendable @escaping (GRPCCore.ClientResponse.Stream<Grpc_Testing_StreamingOutputCallResponse>) async throws -> R
    ) async throws -> R where R: Sendable {
        try await self.halfDuplexCall(
            request: request,
            serializer: GRPCProtobuf.ProtobufSerializer<Grpc_Testing_StreamingOutputCallRequest>(),
            deserializer: GRPCProtobuf.ProtobufDeserializer<Grpc_Testing_StreamingOutputCallResponse>(),
            options: options,
            body
        )
    }
    
    public func unimplementedCall<R>(
        request: GRPCCore.ClientRequest.Single<Grpc_Testing_Empty>,
        options: GRPCCore.CallOptions = .defaults,
        _ body: @Sendable @escaping (GRPCCore.ClientResponse.Single<Grpc_Testing_Empty>) async throws -> R = {
            try $0.message
        }
    ) async throws -> R where R: Sendable {
        try await self.unimplementedCall(
            request: request,
            serializer: GRPCProtobuf.ProtobufSerializer<Grpc_Testing_Empty>(),
            deserializer: GRPCProtobuf.ProtobufDeserializer<Grpc_Testing_Empty>(),
            options: options,
            body
        )
    }
}

@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Grpc_Testing_TestService.ClientProtocol {
    /// One empty request followed by one empty response.
    public func emptyCall<Result>(
        _ message: Grpc_Testing_Empty,
        metadata: GRPCCore.Metadata = [:],
        options: GRPCCore.CallOptions = .defaults,
        onResponse handleResponse: @Sendable @escaping (GRPCCore.ClientResponse.Single<Grpc_Testing_Empty>) async throws -> Result = {
            try $0.message
        }
    ) async throws -> Result where Result: Sendable {
        let request = GRPCCore.ClientRequest.Single<Grpc_Testing_Empty>(
            message: message,
            metadata: metadata
        )
        return try await self.emptyCall(
            request: request,
            options: options,
            handleResponse
        )
    }
    
    /// One request followed by one response.
    public func unaryCall<Result>(
        _ message: Grpc_Testing_SimpleRequest,
        metadata: GRPCCore.Metadata = [:],
        options: GRPCCore.CallOptions = .defaults,
        onResponse handleResponse: @Sendable @escaping (GRPCCore.ClientResponse.Single<Grpc_Testing_SimpleResponse>) async throws -> Result = {
            try $0.message
        }
    ) async throws -> Result where Result: Sendable {
        let request = GRPCCore.ClientRequest.Single<Grpc_Testing_SimpleRequest>(
            message: message,
            metadata: metadata
        )
        return try await self.unaryCall(
            request: request,
            options: options,
            handleResponse
        )
    }
    
    /// One request followed by one response. Response has cache control
    /// headers set such that a caching HTTP proxy (such as GFE) can
    /// satisfy subsequent requests.
    public func cacheableUnaryCall<Result>(
        _ message: Grpc_Testing_SimpleRequest,
        metadata: GRPCCore.Metadata = [:],
        options: GRPCCore.CallOptions = .defaults,
        onResponse handleResponse: @Sendable @escaping (GRPCCore.ClientResponse.Single<Grpc_Testing_SimpleResponse>) async throws -> Result = {
            try $0.message
        }
    ) async throws -> Result where Result: Sendable {
        let request = GRPCCore.ClientRequest.Single<Grpc_Testing_SimpleRequest>(
            message: message,
            metadata: metadata
        )
        return try await self.cacheableUnaryCall(
            request: request,
            options: options,
            handleResponse
        )
    }
    
    /// One request followed by a sequence of responses (streamed download).
    /// The server returns the payload with client desired type and sizes.
    public func streamingOutputCall<Result>(
        _ message: Grpc_Testing_StreamingOutputCallRequest,
        metadata: GRPCCore.Metadata = [:],
        options: GRPCCore.CallOptions = .defaults,
        onResponse handleResponse: @Sendable @escaping (GRPCCore.ClientResponse.Stream<Grpc_Testing_StreamingOutputCallResponse>) async throws -> Result
    ) async throws -> Result where Result: Sendable {
        let request = GRPCCore.ClientRequest.Single<Grpc_Testing_StreamingOutputCallRequest>(
            message: message,
            metadata: metadata
        )
        return try await self.streamingOutputCall(
            request: request,
            options: options,
            handleResponse
        )
    }
    
    /// A sequence of requests followed by one response (streamed upload).
    /// The server returns the aggregated size of client payload as the result.
    public func streamingInputCall<Result>(
        metadata: GRPCCore.Metadata = [:],
        options: GRPCCore.CallOptions = .defaults,
        requestProducer: @Sendable @escaping (GRPCCore.RPCWriter<Grpc_Testing_StreamingInputCallRequest>) async throws -> Void,
        onResponse handleResponse: @Sendable @escaping (GRPCCore.ClientResponse.Single<Grpc_Testing_StreamingInputCallResponse>) async throws -> Result = {
            try $0.message
        }
    ) async throws -> Result where Result: Sendable {
        let request = GRPCCore.ClientRequest.Stream<Grpc_Testing_StreamingInputCallRequest>(
            metadata: metadata,
            producer: requestProducer
        )
        return try await self.streamingInputCall(
            request: request,
            options: options,
            handleResponse
        )
    }
    
    /// A sequence of requests with each request served by the server immediately.
    /// As one request could lead to multiple responses, this interface
    /// demonstrates the idea of full duplexing.
    public func fullDuplexCall<Result>(
        metadata: GRPCCore.Metadata = [:],
        options: GRPCCore.CallOptions = .defaults,
        requestProducer: @Sendable @escaping (GRPCCore.RPCWriter<Grpc_Testing_StreamingOutputCallRequest>) async throws -> Void,
        onResponse handleResponse: @Sendable @escaping (GRPCCore.ClientResponse.Stream<Grpc_Testing_StreamingOutputCallResponse>) async throws -> Result
    ) async throws -> Result where Result: Sendable {
        let request = GRPCCore.ClientRequest.Stream<Grpc_Testing_StreamingOutputCallRequest>(
            metadata: metadata,
            producer: requestProducer
        )
        return try await self.fullDuplexCall(
            request: request,
            options: options,
            handleResponse
        )
    }
    
    /// A sequence of requests followed by a sequence of responses.
    /// The server buffers all the client requests and then serves them in order. A
    /// stream of responses are returned to the client when the server starts with
    /// first request.
    public func halfDuplexCall<Result>(
        metadata: GRPCCore.Metadata = [:],
        options: GRPCCore.CallOptions = .defaults,
        requestProducer: @Sendable @escaping (GRPCCore.RPCWriter<Grpc_Testing_StreamingOutputCallRequest>) async throws -> Void,
        onResponse handleResponse: @Sendable @escaping (GRPCCore.ClientResponse.Stream<Grpc_Testing_StreamingOutputCallResponse>) async throws -> Result
    ) async throws -> Result where Result: Sendable {
        let request = GRPCCore.ClientRequest.Stream<Grpc_Testing_StreamingOutputCallRequest>(
            metadata: metadata,
            producer: requestProducer
        )
        return try await self.halfDuplexCall(
            request: request,
            options: options,
            handleResponse
        )
    }
    
    /// The test server will not implement this method. It will be used
    /// to test the behavior when clients call unimplemented methods.
    public func unimplementedCall<Result>(
        _ message: Grpc_Testing_Empty,
        metadata: GRPCCore.Metadata = [:],
        options: GRPCCore.CallOptions = .defaults,
        onResponse handleResponse: @Sendable @escaping (GRPCCore.ClientResponse.Single<Grpc_Testing_Empty>) async throws -> Result = {
            try $0.message
        }
    ) async throws -> Result where Result: Sendable {
        let request = GRPCCore.ClientRequest.Single<Grpc_Testing_Empty>(
            message: message,
            metadata: metadata
        )
        return try await self.unimplementedCall(
            request: request,
            options: options,
            handleResponse
        )
    }
}

/// A simple service to test the various types of RPCs and experiment with
/// performance with various types of payload.
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
public struct Grpc_Testing_TestServiceClient: Grpc_Testing_TestService.ClientProtocol {
    private let client: GRPCCore.GRPCClient
    
    public init(wrapping client: GRPCCore.GRPCClient) {
        self.client = client
    }
    
    /// One empty request followed by one empty response.
    public func emptyCall<R>(
        request: GRPCCore.ClientRequest.Single<Grpc_Testing_Empty>,
        serializer: some GRPCCore.MessageSerializer<Grpc_Testing_Empty>,
        deserializer: some GRPCCore.MessageDeserializer<Grpc_Testing_Empty>,
        options: GRPCCore.CallOptions = .defaults,
        _ body: @Sendable @escaping (GRPCCore.ClientResponse.Single<Grpc_Testing_Empty>) async throws -> R = {
            try $0.message
        }
    ) async throws -> R where R: Sendable {
        try await self.client.unary(
            request: request,
            descriptor: Grpc_Testing_TestService.Method.EmptyCall.descriptor,
            serializer: serializer,
            deserializer: deserializer,
            options: options,
            handler: body
        )
    }
    
    /// One request followed by one response.
    public func unaryCall<R>(
        request: GRPCCore.ClientRequest.Single<Grpc_Testing_SimpleRequest>,
        serializer: some GRPCCore.MessageSerializer<Grpc_Testing_SimpleRequest>,
        deserializer: some GRPCCore.MessageDeserializer<Grpc_Testing_SimpleResponse>,
        options: GRPCCore.CallOptions = .defaults,
        _ body: @Sendable @escaping (GRPCCore.ClientResponse.Single<Grpc_Testing_SimpleResponse>) async throws -> R = {
            try $0.message
        }
    ) async throws -> R where R: Sendable {
        try await self.client.unary(
            request: request,
            descriptor: Grpc_Testing_TestService.Method.UnaryCall.descriptor,
            serializer: serializer,
            deserializer: deserializer,
            options: options,
            handler: body
        )
    }
    
    /// One request followed by one response. Response has cache control
    /// headers set such that a caching HTTP proxy (such as GFE) can
    /// satisfy subsequent requests.
    public func cacheableUnaryCall<R>(
        request: GRPCCore.ClientRequest.Single<Grpc_Testing_SimpleRequest>,
        serializer: some GRPCCore.MessageSerializer<Grpc_Testing_SimpleRequest>,
        deserializer: some GRPCCore.MessageDeserializer<Grpc_Testing_SimpleResponse>,
        options: GRPCCore.CallOptions = .defaults,
        _ body: @Sendable @escaping (GRPCCore.ClientResponse.Single<Grpc_Testing_SimpleResponse>) async throws -> R = {
            try $0.message
        }
    ) async throws -> R where R: Sendable {
        try await self.client.unary(
            request: request,
            descriptor: Grpc_Testing_TestService.Method.CacheableUnaryCall.descriptor,
            serializer: serializer,
            deserializer: deserializer,
            options: options,
            handler: body
        )
    }
    
    /// One request followed by a sequence of responses (streamed download).
    /// The server returns the payload with client desired type and sizes.
    public func streamingOutputCall<R>(
        request: GRPCCore.ClientRequest.Single<Grpc_Testing_StreamingOutputCallRequest>,
        serializer: some GRPCCore.MessageSerializer<Grpc_Testing_StreamingOutputCallRequest>,
        deserializer: some GRPCCore.MessageDeserializer<Grpc_Testing_StreamingOutputCallResponse>,
        options: GRPCCore.CallOptions = .defaults,
        _ body: @Sendable @escaping (GRPCCore.ClientResponse.Stream<Grpc_Testing_StreamingOutputCallResponse>) async throws -> R
    ) async throws -> R where R: Sendable {
        try await self.client.serverStreaming(
            request: request,
            descriptor: Grpc_Testing_TestService.Method.StreamingOutputCall.descriptor,
            serializer: serializer,
            deserializer: deserializer,
            options: options,
            handler: body
        )
    }
    
    /// A sequence of requests followed by one response (streamed upload).
    /// The server returns the aggregated size of client payload as the result.
    public func streamingInputCall<R>(
        request: GRPCCore.ClientRequest.Stream<Grpc_Testing_StreamingInputCallRequest>,
        serializer: some GRPCCore.MessageSerializer<Grpc_Testing_StreamingInputCallRequest>,
        deserializer: some GRPCCore.MessageDeserializer<Grpc_Testing_StreamingInputCallResponse>,
        options: GRPCCore.CallOptions = .defaults,
        _ body: @Sendable @escaping (GRPCCore.ClientResponse.Single<Grpc_Testing_StreamingInputCallResponse>) async throws -> R = {
            try $0.message
        }
    ) async throws -> R where R: Sendable {
        try await self.client.clientStreaming(
            request: request,
            descriptor: Grpc_Testing_TestService.Method.StreamingInputCall.descriptor,
            serializer: serializer,
            deserializer: deserializer,
            options: options,
            handler: body
        )
    }
    
    /// A sequence of requests with each request served by the server immediately.
    /// As one request could lead to multiple responses, this interface
    /// demonstrates the idea of full duplexing.
    public func fullDuplexCall<R>(
        request: GRPCCore.ClientRequest.Stream<Grpc_Testing_StreamingOutputCallRequest>,
        serializer: some GRPCCore.MessageSerializer<Grpc_Testing_StreamingOutputCallRequest>,
        deserializer: some GRPCCore.MessageDeserializer<Grpc_Testing_StreamingOutputCallResponse>,
        options: GRPCCore.CallOptions = .defaults,
        _ body: @Sendable @escaping (GRPCCore.ClientResponse.Stream<Grpc_Testing_StreamingOutputCallResponse>) async throws -> R
    ) async throws -> R where R: Sendable {
        try await self.client.bidirectionalStreaming(
            request: request,
            descriptor: Grpc_Testing_TestService.Method.FullDuplexCall.descriptor,
            serializer: serializer,
            deserializer: deserializer,
            options: options,
            handler: body
        )
    }
    
    /// A sequence of requests followed by a sequence of responses.
    /// The server buffers all the client requests and then serves them in order. A
    /// stream of responses are returned to the client when the server starts with
    /// first request.
    public func halfDuplexCall<R>(
        request: GRPCCore.ClientRequest.Stream<Grpc_Testing_StreamingOutputCallRequest>,
        serializer: some GRPCCore.MessageSerializer<Grpc_Testing_StreamingOutputCallRequest>,
        deserializer: some GRPCCore.MessageDeserializer<Grpc_Testing_StreamingOutputCallResponse>,
        options: GRPCCore.CallOptions = .defaults,
        _ body: @Sendable @escaping (GRPCCore.ClientResponse.Stream<Grpc_Testing_StreamingOutputCallResponse>) async throws -> R
    ) async throws -> R where R: Sendable {
        try await self.client.bidirectionalStreaming(
            request: request,
            descriptor: Grpc_Testing_TestService.Method.HalfDuplexCall.descriptor,
            serializer: serializer,
            deserializer: deserializer,
            options: options,
            handler: body
        )
    }
    
    /// The test server will not implement this method. It will be used
    /// to test the behavior when clients call unimplemented methods.
    public func unimplementedCall<R>(
        request: GRPCCore.ClientRequest.Single<Grpc_Testing_Empty>,
        serializer: some GRPCCore.MessageSerializer<Grpc_Testing_Empty>,
        deserializer: some GRPCCore.MessageDeserializer<Grpc_Testing_Empty>,
        options: GRPCCore.CallOptions = .defaults,
        _ body: @Sendable @escaping (GRPCCore.ClientResponse.Single<Grpc_Testing_Empty>) async throws -> R = {
            try $0.message
        }
    ) async throws -> R where R: Sendable {
        try await self.client.unary(
            request: request,
            descriptor: Grpc_Testing_TestService.Method.UnimplementedCall.descriptor,
            serializer: serializer,
            deserializer: deserializer,
            options: options,
            handler: body
        )
    }
}

/// A simple service NOT implemented at servers so clients can test for
/// that case.
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
public protocol Grpc_Testing_UnimplementedServiceClientProtocol: Sendable {
    /// A call that no server should implement
    func unimplementedCall<R>(
        request: GRPCCore.ClientRequest.Single<Grpc_Testing_Empty>,
        serializer: some GRPCCore.MessageSerializer<Grpc_Testing_Empty>,
        deserializer: some GRPCCore.MessageDeserializer<Grpc_Testing_Empty>,
        options: GRPCCore.CallOptions,
        _ body: @Sendable @escaping (GRPCCore.ClientResponse.Single<Grpc_Testing_Empty>) async throws -> R
    ) async throws -> R where R: Sendable
}

@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Grpc_Testing_UnimplementedService.ClientProtocol {
    public func unimplementedCall<R>(
        request: GRPCCore.ClientRequest.Single<Grpc_Testing_Empty>,
        options: GRPCCore.CallOptions = .defaults,
        _ body: @Sendable @escaping (GRPCCore.ClientResponse.Single<Grpc_Testing_Empty>) async throws -> R = {
            try $0.message
        }
    ) async throws -> R where R: Sendable {
        try await self.unimplementedCall(
            request: request,
            serializer: GRPCProtobuf.ProtobufSerializer<Grpc_Testing_Empty>(),
            deserializer: GRPCProtobuf.ProtobufDeserializer<Grpc_Testing_Empty>(),
            options: options,
            body
        )
    }
}

@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Grpc_Testing_UnimplementedService.ClientProtocol {
    /// A call that no server should implement
    public func unimplementedCall<Result>(
        _ message: Grpc_Testing_Empty,
        metadata: GRPCCore.Metadata = [:],
        options: GRPCCore.CallOptions = .defaults,
        onResponse handleResponse: @Sendable @escaping (GRPCCore.ClientResponse.Single<Grpc_Testing_Empty>) async throws -> Result = {
            try $0.message
        }
    ) async throws -> Result where Result: Sendable {
        let request = GRPCCore.ClientRequest.Single<Grpc_Testing_Empty>(
            message: message,
            metadata: metadata
        )
        return try await self.unimplementedCall(
            request: request,
            options: options,
            handleResponse
        )
    }
}

/// A simple service NOT implemented at servers so clients can test for
/// that case.
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
public struct Grpc_Testing_UnimplementedServiceClient: Grpc_Testing_UnimplementedService.ClientProtocol {
    private let client: GRPCCore.GRPCClient
    
    public init(wrapping client: GRPCCore.GRPCClient) {
        self.client = client
    }
    
    /// A call that no server should implement
    public func unimplementedCall<R>(
        request: GRPCCore.ClientRequest.Single<Grpc_Testing_Empty>,
        serializer: some GRPCCore.MessageSerializer<Grpc_Testing_Empty>,
        deserializer: some GRPCCore.MessageDeserializer<Grpc_Testing_Empty>,
        options: GRPCCore.CallOptions = .defaults,
        _ body: @Sendable @escaping (GRPCCore.ClientResponse.Single<Grpc_Testing_Empty>) async throws -> R = {
            try $0.message
        }
    ) async throws -> R where R: Sendable {
        try await self.client.unary(
            request: request,
            descriptor: Grpc_Testing_UnimplementedService.Method.UnimplementedCall.descriptor,
            serializer: serializer,
            deserializer: deserializer,
            options: options,
            handler: body
        )
    }
}

/// A service used to control reconnect server.
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
public protocol Grpc_Testing_ReconnectServiceClientProtocol: Sendable {
    func start<R>(
        request: GRPCCore.ClientRequest.Single<Grpc_Testing_ReconnectParams>,
        serializer: some GRPCCore.MessageSerializer<Grpc_Testing_ReconnectParams>,
        deserializer: some GRPCCore.MessageDeserializer<Grpc_Testing_Empty>,
        options: GRPCCore.CallOptions,
        _ body: @Sendable @escaping (GRPCCore.ClientResponse.Single<Grpc_Testing_Empty>) async throws -> R
    ) async throws -> R where R: Sendable
    
    func stop<R>(
        request: GRPCCore.ClientRequest.Single<Grpc_Testing_Empty>,
        serializer: some GRPCCore.MessageSerializer<Grpc_Testing_Empty>,
        deserializer: some GRPCCore.MessageDeserializer<Grpc_Testing_ReconnectInfo>,
        options: GRPCCore.CallOptions,
        _ body: @Sendable @escaping (GRPCCore.ClientResponse.Single<Grpc_Testing_ReconnectInfo>) async throws -> R
    ) async throws -> R where R: Sendable
}

@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Grpc_Testing_ReconnectService.ClientProtocol {
    public func start<R>(
        request: GRPCCore.ClientRequest.Single<Grpc_Testing_ReconnectParams>,
        options: GRPCCore.CallOptions = .defaults,
        _ body: @Sendable @escaping (GRPCCore.ClientResponse.Single<Grpc_Testing_Empty>) async throws -> R = {
            try $0.message
        }
    ) async throws -> R where R: Sendable {
        try await self.start(
            request: request,
            serializer: GRPCProtobuf.ProtobufSerializer<Grpc_Testing_ReconnectParams>(),
            deserializer: GRPCProtobuf.ProtobufDeserializer<Grpc_Testing_Empty>(),
            options: options,
            body
        )
    }
    
    public func stop<R>(
        request: GRPCCore.ClientRequest.Single<Grpc_Testing_Empty>,
        options: GRPCCore.CallOptions = .defaults,
        _ body: @Sendable @escaping (GRPCCore.ClientResponse.Single<Grpc_Testing_ReconnectInfo>) async throws -> R = {
            try $0.message
        }
    ) async throws -> R where R: Sendable {
        try await self.stop(
            request: request,
            serializer: GRPCProtobuf.ProtobufSerializer<Grpc_Testing_Empty>(),
            deserializer: GRPCProtobuf.ProtobufDeserializer<Grpc_Testing_ReconnectInfo>(),
            options: options,
            body
        )
    }
}

@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Grpc_Testing_ReconnectService.ClientProtocol {
    public func start<Result>(
        _ message: Grpc_Testing_ReconnectParams,
        metadata: GRPCCore.Metadata = [:],
        options: GRPCCore.CallOptions = .defaults,
        onResponse handleResponse: @Sendable @escaping (GRPCCore.ClientResponse.Single<Grpc_Testing_Empty>) async throws -> Result = {
            try $0.message
        }
    ) async throws -> Result where Result: Sendable {
        let request = GRPCCore.ClientRequest.Single<Grpc_Testing_ReconnectParams>(
            message: message,
            metadata: metadata
        )
        return try await self.start(
            request: request,
            options: options,
            handleResponse
        )
    }
    
    public func stop<Result>(
        _ message: Grpc_Testing_Empty,
        metadata: GRPCCore.Metadata = [:],
        options: GRPCCore.CallOptions = .defaults,
        onResponse handleResponse: @Sendable @escaping (GRPCCore.ClientResponse.Single<Grpc_Testing_ReconnectInfo>) async throws -> Result = {
            try $0.message
        }
    ) async throws -> Result where Result: Sendable {
        let request = GRPCCore.ClientRequest.Single<Grpc_Testing_Empty>(
            message: message,
            metadata: metadata
        )
        return try await self.stop(
            request: request,
            options: options,
            handleResponse
        )
    }
}

/// A service used to control reconnect server.
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
public struct Grpc_Testing_ReconnectServiceClient: Grpc_Testing_ReconnectService.ClientProtocol {
    private let client: GRPCCore.GRPCClient
    
    public init(wrapping client: GRPCCore.GRPCClient) {
        self.client = client
    }
    
    public func start<R>(
        request: GRPCCore.ClientRequest.Single<Grpc_Testing_ReconnectParams>,
        serializer: some GRPCCore.MessageSerializer<Grpc_Testing_ReconnectParams>,
        deserializer: some GRPCCore.MessageDeserializer<Grpc_Testing_Empty>,
        options: GRPCCore.CallOptions = .defaults,
        _ body: @Sendable @escaping (GRPCCore.ClientResponse.Single<Grpc_Testing_Empty>) async throws -> R = {
            try $0.message
        }
    ) async throws -> R where R: Sendable {
        try await self.client.unary(
            request: request,
            descriptor: Grpc_Testing_ReconnectService.Method.Start.descriptor,
            serializer: serializer,
            deserializer: deserializer,
            options: options,
            handler: body
        )
    }
    
    public func stop<R>(
        request: GRPCCore.ClientRequest.Single<Grpc_Testing_Empty>,
        serializer: some GRPCCore.MessageSerializer<Grpc_Testing_Empty>,
        deserializer: some GRPCCore.MessageDeserializer<Grpc_Testing_ReconnectInfo>,
        options: GRPCCore.CallOptions = .defaults,
        _ body: @Sendable @escaping (GRPCCore.ClientResponse.Single<Grpc_Testing_ReconnectInfo>) async throws -> R = {
            try $0.message
        }
    ) async throws -> R where R: Sendable {
        try await self.client.unary(
            request: request,
            descriptor: Grpc_Testing_ReconnectService.Method.Stop.descriptor,
            serializer: serializer,
            deserializer: deserializer,
            options: options,
            handler: body
        )
    }
}