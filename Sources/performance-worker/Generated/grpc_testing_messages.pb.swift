// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: grpc/testing/messages.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2015-2016 gRPC authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Message definitions to be used by integration test service definitions.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// The type of payload that should be returned.
enum Grpc_Testing_PayloadType: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Compressable text format.
  case compressable // = 0
  case UNRECOGNIZED(Int)

  init() {
    self = .compressable
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .compressable
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .compressable: return 0
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Grpc_Testing_PayloadType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Grpc_Testing_PayloadType] = [
    .compressable,
  ]
}

#endif  // swift(>=4.2)

/// The type of route that a client took to reach a server w.r.t. gRPCLB.
/// The server must fill in "fallback" if it detects that the RPC reached
/// the server via the "gRPCLB fallback" path, and "backend" if it detects
/// that the RPC reached the server via "gRPCLB backend" path (i.e. if it got
/// the address of this server from the gRPCLB server BalanceLoad RPC). Exactly
/// how this detection is done is context and server dependent.
enum Grpc_Testing_GrpclbRouteType: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Server didn't detect the route that a client took to reach it.
  case unknown // = 0

  /// Indicates that a client reached a server via gRPCLB fallback.
  case fallback // = 1

  /// Indicates that a client reached a server as a gRPCLB-given backend.
  case backend // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .fallback
    case 2: self = .backend
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .fallback: return 1
    case .backend: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Grpc_Testing_GrpclbRouteType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Grpc_Testing_GrpclbRouteType] = [
    .unknown,
    .fallback,
    .backend,
  ]
}

#endif  // swift(>=4.2)

/// TODO(dgq): Go back to using well-known types once
/// https://github.com/grpc/grpc/issues/6980 has been fixed.
/// import "google/protobuf/wrappers.proto";
struct Grpc_Testing_BoolValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The bool value.
  var value: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A block of data, to simply increase gRPC message size.
struct Grpc_Testing_Payload {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The type of data in body.
  var type: Grpc_Testing_PayloadType = .compressable

  /// Primary contents of payload.
  var body: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A protobuf representation for grpc status. This is used by test
/// clients to specify a status that the server should attempt to return.
struct Grpc_Testing_EchoStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var code: Int32 = 0

  var message: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Unary request.
struct Grpc_Testing_SimpleRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Desired payload type in the response from the server.
  /// If response_type is RANDOM, server randomly chooses one from other formats.
  var responseType: Grpc_Testing_PayloadType = .compressable

  /// Desired payload size in the response from the server.
  var responseSize: Int32 = 0

  /// Optional input payload sent along with the request.
  var payload: Grpc_Testing_Payload {
    get {return _payload ?? Grpc_Testing_Payload()}
    set {_payload = newValue}
  }
  /// Returns true if `payload` has been explicitly set.
  var hasPayload: Bool {return self._payload != nil}
  /// Clears the value of `payload`. Subsequent reads from it will return its default value.
  mutating func clearPayload() {self._payload = nil}

  /// Whether SimpleResponse should include username.
  var fillUsername: Bool = false

  /// Whether SimpleResponse should include OAuth scope.
  var fillOauthScope: Bool = false

  /// Whether to request the server to compress the response. This field is
  /// "nullable" in order to interoperate seamlessly with clients not able to
  /// implement the full compression tests by introspecting the call to verify
  /// the response's compression status.
  var responseCompressed: Grpc_Testing_BoolValue {
    get {return _responseCompressed ?? Grpc_Testing_BoolValue()}
    set {_responseCompressed = newValue}
  }
  /// Returns true if `responseCompressed` has been explicitly set.
  var hasResponseCompressed: Bool {return self._responseCompressed != nil}
  /// Clears the value of `responseCompressed`. Subsequent reads from it will return its default value.
  mutating func clearResponseCompressed() {self._responseCompressed = nil}

  /// Whether server should return a given status
  var responseStatus: Grpc_Testing_EchoStatus {
    get {return _responseStatus ?? Grpc_Testing_EchoStatus()}
    set {_responseStatus = newValue}
  }
  /// Returns true if `responseStatus` has been explicitly set.
  var hasResponseStatus: Bool {return self._responseStatus != nil}
  /// Clears the value of `responseStatus`. Subsequent reads from it will return its default value.
  mutating func clearResponseStatus() {self._responseStatus = nil}

  /// Whether the server should expect this request to be compressed.
  var expectCompressed: Grpc_Testing_BoolValue {
    get {return _expectCompressed ?? Grpc_Testing_BoolValue()}
    set {_expectCompressed = newValue}
  }
  /// Returns true if `expectCompressed` has been explicitly set.
  var hasExpectCompressed: Bool {return self._expectCompressed != nil}
  /// Clears the value of `expectCompressed`. Subsequent reads from it will return its default value.
  mutating func clearExpectCompressed() {self._expectCompressed = nil}

  /// Whether SimpleResponse should include server_id.
  var fillServerID: Bool = false

  /// Whether SimpleResponse should include grpclb_route_type.
  var fillGrpclbRouteType: Bool = false

  /// If set the server should record this metrics report data for the current RPC.
  var orcaPerQueryReport: Grpc_Testing_TestOrcaReport {
    get {return _orcaPerQueryReport ?? Grpc_Testing_TestOrcaReport()}
    set {_orcaPerQueryReport = newValue}
  }
  /// Returns true if `orcaPerQueryReport` has been explicitly set.
  var hasOrcaPerQueryReport: Bool {return self._orcaPerQueryReport != nil}
  /// Clears the value of `orcaPerQueryReport`. Subsequent reads from it will return its default value.
  mutating func clearOrcaPerQueryReport() {self._orcaPerQueryReport = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _payload: Grpc_Testing_Payload? = nil
  fileprivate var _responseCompressed: Grpc_Testing_BoolValue? = nil
  fileprivate var _responseStatus: Grpc_Testing_EchoStatus? = nil
  fileprivate var _expectCompressed: Grpc_Testing_BoolValue? = nil
  fileprivate var _orcaPerQueryReport: Grpc_Testing_TestOrcaReport? = nil
}

/// Unary response, as configured by the request.
struct Grpc_Testing_SimpleResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Payload to increase message size.
  var payload: Grpc_Testing_Payload {
    get {return _payload ?? Grpc_Testing_Payload()}
    set {_payload = newValue}
  }
  /// Returns true if `payload` has been explicitly set.
  var hasPayload: Bool {return self._payload != nil}
  /// Clears the value of `payload`. Subsequent reads from it will return its default value.
  mutating func clearPayload() {self._payload = nil}

  /// The user the request came from, for verifying authentication was
  /// successful when the client expected it.
  var username: String = String()

  /// OAuth scope.
  var oauthScope: String = String()

  /// Server ID. This must be unique among different server instances,
  /// but the same across all RPC's made to a particular server instance.
  var serverID: String = String()

  /// gRPCLB Path.
  var grpclbRouteType: Grpc_Testing_GrpclbRouteType = .unknown

  /// Server hostname.
  var hostname: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _payload: Grpc_Testing_Payload? = nil
}

/// Client-streaming request.
struct Grpc_Testing_StreamingInputCallRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional input payload sent along with the request.
  var payload: Grpc_Testing_Payload {
    get {return _payload ?? Grpc_Testing_Payload()}
    set {_payload = newValue}
  }
  /// Returns true if `payload` has been explicitly set.
  var hasPayload: Bool {return self._payload != nil}
  /// Clears the value of `payload`. Subsequent reads from it will return its default value.
  mutating func clearPayload() {self._payload = nil}

  /// Whether the server should expect this request to be compressed. This field
  /// is "nullable" in order to interoperate seamlessly with servers not able to
  /// implement the full compression tests by introspecting the call to verify
  /// the request's compression status.
  var expectCompressed: Grpc_Testing_BoolValue {
    get {return _expectCompressed ?? Grpc_Testing_BoolValue()}
    set {_expectCompressed = newValue}
  }
  /// Returns true if `expectCompressed` has been explicitly set.
  var hasExpectCompressed: Bool {return self._expectCompressed != nil}
  /// Clears the value of `expectCompressed`. Subsequent reads from it will return its default value.
  mutating func clearExpectCompressed() {self._expectCompressed = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _payload: Grpc_Testing_Payload? = nil
  fileprivate var _expectCompressed: Grpc_Testing_BoolValue? = nil
}

/// Client-streaming response.
struct Grpc_Testing_StreamingInputCallResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Aggregated size of payloads received from the client.
  var aggregatedPayloadSize: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Configuration for a particular response.
struct Grpc_Testing_ResponseParameters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Desired payload sizes in responses from the server.
  var size: Int32 = 0

  /// Desired interval between consecutive responses in the response stream in
  /// microseconds.
  var intervalUs: Int32 = 0

  /// Whether to request the server to compress the response. This field is
  /// "nullable" in order to interoperate seamlessly with clients not able to
  /// implement the full compression tests by introspecting the call to verify
  /// the response's compression status.
  var compressed: Grpc_Testing_BoolValue {
    get {return _compressed ?? Grpc_Testing_BoolValue()}
    set {_compressed = newValue}
  }
  /// Returns true if `compressed` has been explicitly set.
  var hasCompressed: Bool {return self._compressed != nil}
  /// Clears the value of `compressed`. Subsequent reads from it will return its default value.
  mutating func clearCompressed() {self._compressed = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _compressed: Grpc_Testing_BoolValue? = nil
}

/// Server-streaming request.
struct Grpc_Testing_StreamingOutputCallRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Desired payload type in the response from the server.
  /// If response_type is RANDOM, the payload from each response in the stream
  /// might be of different types. This is to simulate a mixed type of payload
  /// stream.
  var responseType: Grpc_Testing_PayloadType = .compressable

  /// Configuration for each expected response message.
  var responseParameters: [Grpc_Testing_ResponseParameters] = []

  /// Optional input payload sent along with the request.
  var payload: Grpc_Testing_Payload {
    get {return _payload ?? Grpc_Testing_Payload()}
    set {_payload = newValue}
  }
  /// Returns true if `payload` has been explicitly set.
  var hasPayload: Bool {return self._payload != nil}
  /// Clears the value of `payload`. Subsequent reads from it will return its default value.
  mutating func clearPayload() {self._payload = nil}

  /// Whether server should return a given status
  var responseStatus: Grpc_Testing_EchoStatus {
    get {return _responseStatus ?? Grpc_Testing_EchoStatus()}
    set {_responseStatus = newValue}
  }
  /// Returns true if `responseStatus` has been explicitly set.
  var hasResponseStatus: Bool {return self._responseStatus != nil}
  /// Clears the value of `responseStatus`. Subsequent reads from it will return its default value.
  mutating func clearResponseStatus() {self._responseStatus = nil}

  /// If set the server should update this metrics report data at the OOB server.
  var orcaOobReport: Grpc_Testing_TestOrcaReport {
    get {return _orcaOobReport ?? Grpc_Testing_TestOrcaReport()}
    set {_orcaOobReport = newValue}
  }
  /// Returns true if `orcaOobReport` has been explicitly set.
  var hasOrcaOobReport: Bool {return self._orcaOobReport != nil}
  /// Clears the value of `orcaOobReport`. Subsequent reads from it will return its default value.
  mutating func clearOrcaOobReport() {self._orcaOobReport = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _payload: Grpc_Testing_Payload? = nil
  fileprivate var _responseStatus: Grpc_Testing_EchoStatus? = nil
  fileprivate var _orcaOobReport: Grpc_Testing_TestOrcaReport? = nil
}

/// Server-streaming response, as configured by the request and parameters.
struct Grpc_Testing_StreamingOutputCallResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Payload to increase response size.
  var payload: Grpc_Testing_Payload {
    get {return _payload ?? Grpc_Testing_Payload()}
    set {_payload = newValue}
  }
  /// Returns true if `payload` has been explicitly set.
  var hasPayload: Bool {return self._payload != nil}
  /// Clears the value of `payload`. Subsequent reads from it will return its default value.
  mutating func clearPayload() {self._payload = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _payload: Grpc_Testing_Payload? = nil
}

/// For reconnect interop test only.
/// Client tells server what reconnection parameters it used.
struct Grpc_Testing_ReconnectParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var maxReconnectBackoffMs: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// For reconnect interop test only.
/// Server tells client whether its reconnects are following the spec and the
/// reconnect backoffs it saw.
struct Grpc_Testing_ReconnectInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var passed: Bool = false

  var backoffMs: [Int32] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Grpc_Testing_LoadBalancerStatsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Request stats for the next num_rpcs sent by client.
  var numRpcs: Int32 = 0

  /// If num_rpcs have not completed within timeout_sec, return partial results.
  var timeoutSec: Int32 = 0

  /// Response header + trailer metadata entries we want the values of.
  /// Matching of the keys is case-insensitive as per rfc7540#section-8.1.2
  /// * (asterisk) is a special value that will return all metadata entries
  var metadataKeys: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Grpc_Testing_LoadBalancerStatsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The number of completed RPCs for each peer.
  var rpcsByPeer: Dictionary<String,Int32> = [:]

  /// The number of RPCs that failed to record a remote peer.
  var numFailures: Int32 = 0

  var rpcsByMethod: Dictionary<String,Grpc_Testing_LoadBalancerStatsResponse.RpcsByPeer> = [:]

  /// All the metadata of all RPCs for each peer.
  var metadatasByPeer: Dictionary<String,Grpc_Testing_LoadBalancerStatsResponse.MetadataByPeer> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum MetadataType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unknown // = 0
    case initial // = 1
    case trailing // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .initial
      case 2: self = .trailing
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .initial: return 1
      case .trailing: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  struct MetadataEntry {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Key, exactly as received from the server. Case may be different from what
    /// was requested in the LoadBalancerStatsRequest)
    var key: String = String()

    /// Value, exactly as received from the server.
    var value: String = String()

    /// Metadata type
    var type: Grpc_Testing_LoadBalancerStatsResponse.MetadataType = .unknown

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct RpcMetadata {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// metadata values for each rpc for the keys specified in
    /// LoadBalancerStatsRequest.metadata_keys.
    var metadata: [Grpc_Testing_LoadBalancerStatsResponse.MetadataEntry] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct MetadataByPeer {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// List of RpcMetadata in for each RPC with a given peer
    var rpcMetadata: [Grpc_Testing_LoadBalancerStatsResponse.RpcMetadata] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct RpcsByPeer {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The number of completed RPCs for each peer.
    var rpcsByPeer: Dictionary<String,Int32> = [:]

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

#if swift(>=4.2)

extension Grpc_Testing_LoadBalancerStatsResponse.MetadataType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Grpc_Testing_LoadBalancerStatsResponse.MetadataType] = [
    .unknown,
    .initial,
    .trailing,
  ]
}

#endif  // swift(>=4.2)

/// Request for retrieving a test client's accumulated stats.
struct Grpc_Testing_LoadBalancerAccumulatedStatsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Accumulated stats for RPCs sent by a test client.
struct Grpc_Testing_LoadBalancerAccumulatedStatsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The total number of RPCs have ever issued for each type.
  /// Deprecated: use stats_per_method.rpcs_started instead.
  var numRpcsStartedByMethod: Dictionary<String,Int32> = [:]

  /// The total number of RPCs have ever completed successfully for each type.
  /// Deprecated: use stats_per_method.result instead.
  var numRpcsSucceededByMethod: Dictionary<String,Int32> = [:]

  /// The total number of RPCs have ever failed for each type.
  /// Deprecated: use stats_per_method.result instead.
  var numRpcsFailedByMethod: Dictionary<String,Int32> = [:]

  /// Per-method RPC statistics.  The key is the RpcType in string form; e.g.
  /// 'EMPTY_CALL' or 'UNARY_CALL'
  var statsPerMethod: Dictionary<String,Grpc_Testing_LoadBalancerAccumulatedStatsResponse.MethodStats> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct MethodStats {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The number of RPCs that were started for this method.
    var rpcsStarted: Int32 = 0

    /// The number of RPCs that completed with each status for this method.  The
    /// key is the integral value of a google.rpc.Code; the value is the count.
    var result: Dictionary<Int32,Int32> = [:]

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

/// Configurations for a test client.
struct Grpc_Testing_ClientConfigureRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The types of RPCs the client sends.
  var types: [Grpc_Testing_ClientConfigureRequest.RpcType] = []

  /// The collection of custom metadata to be attached to RPCs sent by the client.
  var metadata: [Grpc_Testing_ClientConfigureRequest.Metadata] = []

  /// The deadline to use, in seconds, for all RPCs.  If unset or zero, the
  /// client will use the default from the command-line.
  var timeoutSec: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Type of RPCs to send.
  enum RpcType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case emptyCall // = 0
    case unaryCall // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .emptyCall
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .emptyCall
      case 1: self = .unaryCall
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .emptyCall: return 0
      case .unaryCall: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Metadata to be attached for the given type of RPCs.
  struct Metadata {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var type: Grpc_Testing_ClientConfigureRequest.RpcType = .emptyCall

    var key: String = String()

    var value: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

#if swift(>=4.2)

extension Grpc_Testing_ClientConfigureRequest.RpcType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Grpc_Testing_ClientConfigureRequest.RpcType] = [
    .emptyCall,
    .unaryCall,
  ]
}

#endif  // swift(>=4.2)

/// Response for updating a test client's configuration.
struct Grpc_Testing_ClientConfigureResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Grpc_Testing_MemorySize {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var rss: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Metrics data the server will update and send to the client. It mirrors orca load report
/// https://github.com/cncf/xds/blob/eded343319d09f30032952beda9840bbd3dcf7ac/xds/data/orca/v3/orca_load_report.proto#L15,
/// but avoids orca dependency. Used by both per-query and out-of-band reporting tests.
struct Grpc_Testing_TestOrcaReport {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var cpuUtilization: Double = 0

  var memoryUtilization: Double = 0

  var requestCost: Dictionary<String,Double> = [:]

  var utilization: Dictionary<String,Double> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Status that will be return to callers of the Hook method
struct Grpc_Testing_SetReturnStatusRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var grpcCodeToReturn: Int32 = 0

  var grpcStatusDescription: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Grpc_Testing_HookRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var command: Grpc_Testing_HookRequest.HookRequestCommand = .unspecified

  var grpcCodeToReturn: Int32 = 0

  var grpcStatusDescription: String = String()

  /// Server port to listen to
  var serverPort: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum HookRequestCommand: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Default value
    case unspecified // = 0

    /// Start the HTTP endpoint
    case start // = 1

    /// Stop
    case stop // = 2

    /// Return from HTTP GET/POST
    case `return` // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .start
      case 2: self = .stop
      case 3: self = .return
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .start: return 1
      case .stop: return 2
      case .return: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Grpc_Testing_HookRequest.HookRequestCommand: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Grpc_Testing_HookRequest.HookRequestCommand] = [
    .unspecified,
    .start,
    .stop,
    .return,
  ]
}

#endif  // swift(>=4.2)

struct Grpc_Testing_HookResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Grpc_Testing_PayloadType: @unchecked Sendable {}
extension Grpc_Testing_GrpclbRouteType: @unchecked Sendable {}
extension Grpc_Testing_BoolValue: @unchecked Sendable {}
extension Grpc_Testing_Payload: @unchecked Sendable {}
extension Grpc_Testing_EchoStatus: @unchecked Sendable {}
extension Grpc_Testing_SimpleRequest: @unchecked Sendable {}
extension Grpc_Testing_SimpleResponse: @unchecked Sendable {}
extension Grpc_Testing_StreamingInputCallRequest: @unchecked Sendable {}
extension Grpc_Testing_StreamingInputCallResponse: @unchecked Sendable {}
extension Grpc_Testing_ResponseParameters: @unchecked Sendable {}
extension Grpc_Testing_StreamingOutputCallRequest: @unchecked Sendable {}
extension Grpc_Testing_StreamingOutputCallResponse: @unchecked Sendable {}
extension Grpc_Testing_ReconnectParams: @unchecked Sendable {}
extension Grpc_Testing_ReconnectInfo: @unchecked Sendable {}
extension Grpc_Testing_LoadBalancerStatsRequest: @unchecked Sendable {}
extension Grpc_Testing_LoadBalancerStatsResponse: @unchecked Sendable {}
extension Grpc_Testing_LoadBalancerStatsResponse.MetadataType: @unchecked Sendable {}
extension Grpc_Testing_LoadBalancerStatsResponse.MetadataEntry: @unchecked Sendable {}
extension Grpc_Testing_LoadBalancerStatsResponse.RpcMetadata: @unchecked Sendable {}
extension Grpc_Testing_LoadBalancerStatsResponse.MetadataByPeer: @unchecked Sendable {}
extension Grpc_Testing_LoadBalancerStatsResponse.RpcsByPeer: @unchecked Sendable {}
extension Grpc_Testing_LoadBalancerAccumulatedStatsRequest: @unchecked Sendable {}
extension Grpc_Testing_LoadBalancerAccumulatedStatsResponse: @unchecked Sendable {}
extension Grpc_Testing_LoadBalancerAccumulatedStatsResponse.MethodStats: @unchecked Sendable {}
extension Grpc_Testing_ClientConfigureRequest: @unchecked Sendable {}
extension Grpc_Testing_ClientConfigureRequest.RpcType: @unchecked Sendable {}
extension Grpc_Testing_ClientConfigureRequest.Metadata: @unchecked Sendable {}
extension Grpc_Testing_ClientConfigureResponse: @unchecked Sendable {}
extension Grpc_Testing_MemorySize: @unchecked Sendable {}
extension Grpc_Testing_TestOrcaReport: @unchecked Sendable {}
extension Grpc_Testing_SetReturnStatusRequest: @unchecked Sendable {}
extension Grpc_Testing_HookRequest: @unchecked Sendable {}
extension Grpc_Testing_HookRequest.HookRequestCommand: @unchecked Sendable {}
extension Grpc_Testing_HookResponse: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "grpc.testing"

extension Grpc_Testing_PayloadType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "COMPRESSABLE"),
  ]
}

extension Grpc_Testing_GrpclbRouteType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "GRPCLB_ROUTE_TYPE_UNKNOWN"),
    1: .same(proto: "GRPCLB_ROUTE_TYPE_FALLBACK"),
    2: .same(proto: "GRPCLB_ROUTE_TYPE_BACKEND"),
  ]
}

extension Grpc_Testing_BoolValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BoolValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != false {
      try visitor.visitSingularBoolField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_Testing_BoolValue, rhs: Grpc_Testing_BoolValue) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_Testing_Payload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Payload"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "body"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.body) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .compressable {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.body.isEmpty {
      try visitor.visitSingularBytesField(value: self.body, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_Testing_Payload, rhs: Grpc_Testing_Payload) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.body != rhs.body {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_Testing_EchoStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EchoStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != 0 {
      try visitor.visitSingularInt32Field(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_Testing_EchoStatus, rhs: Grpc_Testing_EchoStatus) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_Testing_SimpleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SimpleRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "response_type"),
    2: .standard(proto: "response_size"),
    3: .same(proto: "payload"),
    4: .standard(proto: "fill_username"),
    5: .standard(proto: "fill_oauth_scope"),
    6: .standard(proto: "response_compressed"),
    7: .standard(proto: "response_status"),
    8: .standard(proto: "expect_compressed"),
    9: .standard(proto: "fill_server_id"),
    10: .standard(proto: "fill_grpclb_route_type"),
    11: .standard(proto: "orca_per_query_report"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.responseType) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.responseSize) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._payload) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.fillUsername) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.fillOauthScope) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._responseCompressed) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._responseStatus) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._expectCompressed) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.fillServerID) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self.fillGrpclbRouteType) }()
      case 11: try { try decoder.decodeSingularMessageField(value: &self._orcaPerQueryReport) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.responseType != .compressable {
      try visitor.visitSingularEnumField(value: self.responseType, fieldNumber: 1)
    }
    if self.responseSize != 0 {
      try visitor.visitSingularInt32Field(value: self.responseSize, fieldNumber: 2)
    }
    try { if let v = self._payload {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.fillUsername != false {
      try visitor.visitSingularBoolField(value: self.fillUsername, fieldNumber: 4)
    }
    if self.fillOauthScope != false {
      try visitor.visitSingularBoolField(value: self.fillOauthScope, fieldNumber: 5)
    }
    try { if let v = self._responseCompressed {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._responseStatus {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._expectCompressed {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    if self.fillServerID != false {
      try visitor.visitSingularBoolField(value: self.fillServerID, fieldNumber: 9)
    }
    if self.fillGrpclbRouteType != false {
      try visitor.visitSingularBoolField(value: self.fillGrpclbRouteType, fieldNumber: 10)
    }
    try { if let v = self._orcaPerQueryReport {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_Testing_SimpleRequest, rhs: Grpc_Testing_SimpleRequest) -> Bool {
    if lhs.responseType != rhs.responseType {return false}
    if lhs.responseSize != rhs.responseSize {return false}
    if lhs._payload != rhs._payload {return false}
    if lhs.fillUsername != rhs.fillUsername {return false}
    if lhs.fillOauthScope != rhs.fillOauthScope {return false}
    if lhs._responseCompressed != rhs._responseCompressed {return false}
    if lhs._responseStatus != rhs._responseStatus {return false}
    if lhs._expectCompressed != rhs._expectCompressed {return false}
    if lhs.fillServerID != rhs.fillServerID {return false}
    if lhs.fillGrpclbRouteType != rhs.fillGrpclbRouteType {return false}
    if lhs._orcaPerQueryReport != rhs._orcaPerQueryReport {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_Testing_SimpleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SimpleResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "payload"),
    2: .same(proto: "username"),
    3: .standard(proto: "oauth_scope"),
    4: .standard(proto: "server_id"),
    5: .standard(proto: "grpclb_route_type"),
    6: .same(proto: "hostname"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._payload) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.username) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.oauthScope) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.serverID) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.grpclbRouteType) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.hostname) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._payload {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 2)
    }
    if !self.oauthScope.isEmpty {
      try visitor.visitSingularStringField(value: self.oauthScope, fieldNumber: 3)
    }
    if !self.serverID.isEmpty {
      try visitor.visitSingularStringField(value: self.serverID, fieldNumber: 4)
    }
    if self.grpclbRouteType != .unknown {
      try visitor.visitSingularEnumField(value: self.grpclbRouteType, fieldNumber: 5)
    }
    if !self.hostname.isEmpty {
      try visitor.visitSingularStringField(value: self.hostname, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_Testing_SimpleResponse, rhs: Grpc_Testing_SimpleResponse) -> Bool {
    if lhs._payload != rhs._payload {return false}
    if lhs.username != rhs.username {return false}
    if lhs.oauthScope != rhs.oauthScope {return false}
    if lhs.serverID != rhs.serverID {return false}
    if lhs.grpclbRouteType != rhs.grpclbRouteType {return false}
    if lhs.hostname != rhs.hostname {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_Testing_StreamingInputCallRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StreamingInputCallRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "payload"),
    2: .standard(proto: "expect_compressed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._payload) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._expectCompressed) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._payload {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._expectCompressed {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_Testing_StreamingInputCallRequest, rhs: Grpc_Testing_StreamingInputCallRequest) -> Bool {
    if lhs._payload != rhs._payload {return false}
    if lhs._expectCompressed != rhs._expectCompressed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_Testing_StreamingInputCallResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StreamingInputCallResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "aggregated_payload_size"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.aggregatedPayloadSize) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.aggregatedPayloadSize != 0 {
      try visitor.visitSingularInt32Field(value: self.aggregatedPayloadSize, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_Testing_StreamingInputCallResponse, rhs: Grpc_Testing_StreamingInputCallResponse) -> Bool {
    if lhs.aggregatedPayloadSize != rhs.aggregatedPayloadSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_Testing_ResponseParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResponseParameters"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "size"),
    2: .standard(proto: "interval_us"),
    3: .same(proto: "compressed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.size) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.intervalUs) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._compressed) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.size != 0 {
      try visitor.visitSingularInt32Field(value: self.size, fieldNumber: 1)
    }
    if self.intervalUs != 0 {
      try visitor.visitSingularInt32Field(value: self.intervalUs, fieldNumber: 2)
    }
    try { if let v = self._compressed {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_Testing_ResponseParameters, rhs: Grpc_Testing_ResponseParameters) -> Bool {
    if lhs.size != rhs.size {return false}
    if lhs.intervalUs != rhs.intervalUs {return false}
    if lhs._compressed != rhs._compressed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_Testing_StreamingOutputCallRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StreamingOutputCallRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "response_type"),
    2: .standard(proto: "response_parameters"),
    3: .same(proto: "payload"),
    7: .standard(proto: "response_status"),
    8: .standard(proto: "orca_oob_report"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.responseType) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.responseParameters) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._payload) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._responseStatus) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._orcaOobReport) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.responseType != .compressable {
      try visitor.visitSingularEnumField(value: self.responseType, fieldNumber: 1)
    }
    if !self.responseParameters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.responseParameters, fieldNumber: 2)
    }
    try { if let v = self._payload {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._responseStatus {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._orcaOobReport {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_Testing_StreamingOutputCallRequest, rhs: Grpc_Testing_StreamingOutputCallRequest) -> Bool {
    if lhs.responseType != rhs.responseType {return false}
    if lhs.responseParameters != rhs.responseParameters {return false}
    if lhs._payload != rhs._payload {return false}
    if lhs._responseStatus != rhs._responseStatus {return false}
    if lhs._orcaOobReport != rhs._orcaOobReport {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_Testing_StreamingOutputCallResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StreamingOutputCallResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "payload"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._payload) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._payload {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_Testing_StreamingOutputCallResponse, rhs: Grpc_Testing_StreamingOutputCallResponse) -> Bool {
    if lhs._payload != rhs._payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_Testing_ReconnectParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReconnectParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "max_reconnect_backoff_ms"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.maxReconnectBackoffMs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.maxReconnectBackoffMs != 0 {
      try visitor.visitSingularInt32Field(value: self.maxReconnectBackoffMs, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_Testing_ReconnectParams, rhs: Grpc_Testing_ReconnectParams) -> Bool {
    if lhs.maxReconnectBackoffMs != rhs.maxReconnectBackoffMs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_Testing_ReconnectInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReconnectInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "passed"),
    2: .standard(proto: "backoff_ms"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.passed) }()
      case 2: try { try decoder.decodeRepeatedInt32Field(value: &self.backoffMs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.passed != false {
      try visitor.visitSingularBoolField(value: self.passed, fieldNumber: 1)
    }
    if !self.backoffMs.isEmpty {
      try visitor.visitPackedInt32Field(value: self.backoffMs, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_Testing_ReconnectInfo, rhs: Grpc_Testing_ReconnectInfo) -> Bool {
    if lhs.passed != rhs.passed {return false}
    if lhs.backoffMs != rhs.backoffMs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_Testing_LoadBalancerStatsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LoadBalancerStatsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "num_rpcs"),
    2: .standard(proto: "timeout_sec"),
    3: .standard(proto: "metadata_keys"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.numRpcs) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.timeoutSec) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.metadataKeys) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.numRpcs != 0 {
      try visitor.visitSingularInt32Field(value: self.numRpcs, fieldNumber: 1)
    }
    if self.timeoutSec != 0 {
      try visitor.visitSingularInt32Field(value: self.timeoutSec, fieldNumber: 2)
    }
    if !self.metadataKeys.isEmpty {
      try visitor.visitRepeatedStringField(value: self.metadataKeys, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_Testing_LoadBalancerStatsRequest, rhs: Grpc_Testing_LoadBalancerStatsRequest) -> Bool {
    if lhs.numRpcs != rhs.numRpcs {return false}
    if lhs.timeoutSec != rhs.timeoutSec {return false}
    if lhs.metadataKeys != rhs.metadataKeys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_Testing_LoadBalancerStatsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LoadBalancerStatsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "rpcs_by_peer"),
    2: .standard(proto: "num_failures"),
    3: .standard(proto: "rpcs_by_method"),
    4: .standard(proto: "metadatas_by_peer"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt32>.self, value: &self.rpcsByPeer) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.numFailures) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Grpc_Testing_LoadBalancerStatsResponse.RpcsByPeer>.self, value: &self.rpcsByMethod) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Grpc_Testing_LoadBalancerStatsResponse.MetadataByPeer>.self, value: &self.metadatasByPeer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rpcsByPeer.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt32>.self, value: self.rpcsByPeer, fieldNumber: 1)
    }
    if self.numFailures != 0 {
      try visitor.visitSingularInt32Field(value: self.numFailures, fieldNumber: 2)
    }
    if !self.rpcsByMethod.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Grpc_Testing_LoadBalancerStatsResponse.RpcsByPeer>.self, value: self.rpcsByMethod, fieldNumber: 3)
    }
    if !self.metadatasByPeer.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Grpc_Testing_LoadBalancerStatsResponse.MetadataByPeer>.self, value: self.metadatasByPeer, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_Testing_LoadBalancerStatsResponse, rhs: Grpc_Testing_LoadBalancerStatsResponse) -> Bool {
    if lhs.rpcsByPeer != rhs.rpcsByPeer {return false}
    if lhs.numFailures != rhs.numFailures {return false}
    if lhs.rpcsByMethod != rhs.rpcsByMethod {return false}
    if lhs.metadatasByPeer != rhs.metadatasByPeer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_Testing_LoadBalancerStatsResponse.MetadataType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "INITIAL"),
    2: .same(proto: "TRAILING"),
  ]
}

extension Grpc_Testing_LoadBalancerStatsResponse.MetadataEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Grpc_Testing_LoadBalancerStatsResponse.protoMessageName + ".MetadataEntry"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
    3: .same(proto: "type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    if self.type != .unknown {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_Testing_LoadBalancerStatsResponse.MetadataEntry, rhs: Grpc_Testing_LoadBalancerStatsResponse.MetadataEntry) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.value != rhs.value {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_Testing_LoadBalancerStatsResponse.RpcMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Grpc_Testing_LoadBalancerStatsResponse.protoMessageName + ".RpcMetadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.metadata) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.metadata.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.metadata, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_Testing_LoadBalancerStatsResponse.RpcMetadata, rhs: Grpc_Testing_LoadBalancerStatsResponse.RpcMetadata) -> Bool {
    if lhs.metadata != rhs.metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_Testing_LoadBalancerStatsResponse.MetadataByPeer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Grpc_Testing_LoadBalancerStatsResponse.protoMessageName + ".MetadataByPeer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "rpc_metadata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.rpcMetadata) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rpcMetadata.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rpcMetadata, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_Testing_LoadBalancerStatsResponse.MetadataByPeer, rhs: Grpc_Testing_LoadBalancerStatsResponse.MetadataByPeer) -> Bool {
    if lhs.rpcMetadata != rhs.rpcMetadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_Testing_LoadBalancerStatsResponse.RpcsByPeer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Grpc_Testing_LoadBalancerStatsResponse.protoMessageName + ".RpcsByPeer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "rpcs_by_peer"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt32>.self, value: &self.rpcsByPeer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rpcsByPeer.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt32>.self, value: self.rpcsByPeer, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_Testing_LoadBalancerStatsResponse.RpcsByPeer, rhs: Grpc_Testing_LoadBalancerStatsResponse.RpcsByPeer) -> Bool {
    if lhs.rpcsByPeer != rhs.rpcsByPeer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_Testing_LoadBalancerAccumulatedStatsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LoadBalancerAccumulatedStatsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_Testing_LoadBalancerAccumulatedStatsRequest, rhs: Grpc_Testing_LoadBalancerAccumulatedStatsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_Testing_LoadBalancerAccumulatedStatsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LoadBalancerAccumulatedStatsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "num_rpcs_started_by_method"),
    2: .standard(proto: "num_rpcs_succeeded_by_method"),
    3: .standard(proto: "num_rpcs_failed_by_method"),
    4: .standard(proto: "stats_per_method"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt32>.self, value: &self.numRpcsStartedByMethod) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt32>.self, value: &self.numRpcsSucceededByMethod) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt32>.self, value: &self.numRpcsFailedByMethod) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Grpc_Testing_LoadBalancerAccumulatedStatsResponse.MethodStats>.self, value: &self.statsPerMethod) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.numRpcsStartedByMethod.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt32>.self, value: self.numRpcsStartedByMethod, fieldNumber: 1)
    }
    if !self.numRpcsSucceededByMethod.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt32>.self, value: self.numRpcsSucceededByMethod, fieldNumber: 2)
    }
    if !self.numRpcsFailedByMethod.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt32>.self, value: self.numRpcsFailedByMethod, fieldNumber: 3)
    }
    if !self.statsPerMethod.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Grpc_Testing_LoadBalancerAccumulatedStatsResponse.MethodStats>.self, value: self.statsPerMethod, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_Testing_LoadBalancerAccumulatedStatsResponse, rhs: Grpc_Testing_LoadBalancerAccumulatedStatsResponse) -> Bool {
    if lhs.numRpcsStartedByMethod != rhs.numRpcsStartedByMethod {return false}
    if lhs.numRpcsSucceededByMethod != rhs.numRpcsSucceededByMethod {return false}
    if lhs.numRpcsFailedByMethod != rhs.numRpcsFailedByMethod {return false}
    if lhs.statsPerMethod != rhs.statsPerMethod {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_Testing_LoadBalancerAccumulatedStatsResponse.MethodStats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Grpc_Testing_LoadBalancerAccumulatedStatsResponse.protoMessageName + ".MethodStats"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "rpcs_started"),
    2: .same(proto: "result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.rpcsStarted) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufInt32,SwiftProtobuf.ProtobufInt32>.self, value: &self.result) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rpcsStarted != 0 {
      try visitor.visitSingularInt32Field(value: self.rpcsStarted, fieldNumber: 1)
    }
    if !self.result.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufInt32,SwiftProtobuf.ProtobufInt32>.self, value: self.result, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_Testing_LoadBalancerAccumulatedStatsResponse.MethodStats, rhs: Grpc_Testing_LoadBalancerAccumulatedStatsResponse.MethodStats) -> Bool {
    if lhs.rpcsStarted != rhs.rpcsStarted {return false}
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_Testing_ClientConfigureRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClientConfigureRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "types"),
    2: .same(proto: "metadata"),
    3: .standard(proto: "timeout_sec"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedEnumField(value: &self.types) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.metadata) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.timeoutSec) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.types.isEmpty {
      try visitor.visitPackedEnumField(value: self.types, fieldNumber: 1)
    }
    if !self.metadata.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.metadata, fieldNumber: 2)
    }
    if self.timeoutSec != 0 {
      try visitor.visitSingularInt32Field(value: self.timeoutSec, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_Testing_ClientConfigureRequest, rhs: Grpc_Testing_ClientConfigureRequest) -> Bool {
    if lhs.types != rhs.types {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.timeoutSec != rhs.timeoutSec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_Testing_ClientConfigureRequest.RpcType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "EMPTY_CALL"),
    1: .same(proto: "UNARY_CALL"),
  ]
}

extension Grpc_Testing_ClientConfigureRequest.Metadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Grpc_Testing_ClientConfigureRequest.protoMessageName + ".Metadata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "key"),
    3: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .emptyCall {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 2)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_Testing_ClientConfigureRequest.Metadata, rhs: Grpc_Testing_ClientConfigureRequest.Metadata) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.key != rhs.key {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_Testing_ClientConfigureResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClientConfigureResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_Testing_ClientConfigureResponse, rhs: Grpc_Testing_ClientConfigureResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_Testing_MemorySize: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MemorySize"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "rss"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.rss) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rss != 0 {
      try visitor.visitSingularInt64Field(value: self.rss, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_Testing_MemorySize, rhs: Grpc_Testing_MemorySize) -> Bool {
    if lhs.rss != rhs.rss {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_Testing_TestOrcaReport: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TestOrcaReport"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cpu_utilization"),
    2: .standard(proto: "memory_utilization"),
    3: .standard(proto: "request_cost"),
    4: .same(proto: "utilization"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.cpuUtilization) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.memoryUtilization) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufDouble>.self, value: &self.requestCost) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufDouble>.self, value: &self.utilization) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.cpuUtilization != 0 {
      try visitor.visitSingularDoubleField(value: self.cpuUtilization, fieldNumber: 1)
    }
    if self.memoryUtilization != 0 {
      try visitor.visitSingularDoubleField(value: self.memoryUtilization, fieldNumber: 2)
    }
    if !self.requestCost.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufDouble>.self, value: self.requestCost, fieldNumber: 3)
    }
    if !self.utilization.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufDouble>.self, value: self.utilization, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_Testing_TestOrcaReport, rhs: Grpc_Testing_TestOrcaReport) -> Bool {
    if lhs.cpuUtilization != rhs.cpuUtilization {return false}
    if lhs.memoryUtilization != rhs.memoryUtilization {return false}
    if lhs.requestCost != rhs.requestCost {return false}
    if lhs.utilization != rhs.utilization {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_Testing_SetReturnStatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetReturnStatusRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "grpc_code_to_return"),
    2: .standard(proto: "grpc_status_description"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.grpcCodeToReturn) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.grpcStatusDescription) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.grpcCodeToReturn != 0 {
      try visitor.visitSingularInt32Field(value: self.grpcCodeToReturn, fieldNumber: 1)
    }
    if !self.grpcStatusDescription.isEmpty {
      try visitor.visitSingularStringField(value: self.grpcStatusDescription, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_Testing_SetReturnStatusRequest, rhs: Grpc_Testing_SetReturnStatusRequest) -> Bool {
    if lhs.grpcCodeToReturn != rhs.grpcCodeToReturn {return false}
    if lhs.grpcStatusDescription != rhs.grpcStatusDescription {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_Testing_HookRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HookRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "command"),
    2: .standard(proto: "grpc_code_to_return"),
    3: .standard(proto: "grpc_status_description"),
    4: .standard(proto: "server_port"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.command) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.grpcCodeToReturn) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.grpcStatusDescription) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.serverPort) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.command != .unspecified {
      try visitor.visitSingularEnumField(value: self.command, fieldNumber: 1)
    }
    if self.grpcCodeToReturn != 0 {
      try visitor.visitSingularInt32Field(value: self.grpcCodeToReturn, fieldNumber: 2)
    }
    if !self.grpcStatusDescription.isEmpty {
      try visitor.visitSingularStringField(value: self.grpcStatusDescription, fieldNumber: 3)
    }
    if self.serverPort != 0 {
      try visitor.visitSingularInt32Field(value: self.serverPort, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_Testing_HookRequest, rhs: Grpc_Testing_HookRequest) -> Bool {
    if lhs.command != rhs.command {return false}
    if lhs.grpcCodeToReturn != rhs.grpcCodeToReturn {return false}
    if lhs.grpcStatusDescription != rhs.grpcStatusDescription {return false}
    if lhs.serverPort != rhs.serverPort {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_Testing_HookRequest.HookRequestCommand: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSPECIFIED"),
    1: .same(proto: "START"),
    2: .same(proto: "STOP"),
    3: .same(proto: "RETURN"),
  ]
}

extension Grpc_Testing_HookResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HookResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_Testing_HookResponse, rhs: Grpc_Testing_HookResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
