// Copyright 2015 gRPC authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/// An integration test service that covers all the method signature permutations
/// of unary/streaming requests/responses.

// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the gRPC Swift generator plugin for the protocol buffer compiler.
// Source: grpc/testing/worker_service.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/grpc/grpc-swift

import GRPCCore
import GRPCProtobuf

internal enum Grpc_Testing_WorkerService {
    internal static let descriptor = GRPCCore.ServiceDescriptor.grpc_testing_WorkerService
    internal enum Method {
        internal enum RunServer {
            internal typealias Input = Grpc_Testing_ServerArgs
            internal typealias Output = Grpc_Testing_ServerStatus
            internal static let descriptor = GRPCCore.MethodDescriptor(
                service: Grpc_Testing_WorkerService.descriptor.fullyQualifiedService,
                method: "RunServer"
            )
        }
        internal enum RunClient {
            internal typealias Input = Grpc_Testing_ClientArgs
            internal typealias Output = Grpc_Testing_ClientStatus
            internal static let descriptor = GRPCCore.MethodDescriptor(
                service: Grpc_Testing_WorkerService.descriptor.fullyQualifiedService,
                method: "RunClient"
            )
        }
        internal enum CoreCount {
            internal typealias Input = Grpc_Testing_CoreRequest
            internal typealias Output = Grpc_Testing_CoreResponse
            internal static let descriptor = GRPCCore.MethodDescriptor(
                service: Grpc_Testing_WorkerService.descriptor.fullyQualifiedService,
                method: "CoreCount"
            )
        }
        internal enum QuitWorker {
            internal typealias Input = Grpc_Testing_Void
            internal typealias Output = Grpc_Testing_Void
            internal static let descriptor = GRPCCore.MethodDescriptor(
                service: Grpc_Testing_WorkerService.descriptor.fullyQualifiedService,
                method: "QuitWorker"
            )
        }
        internal static let descriptors: [GRPCCore.MethodDescriptor] = [
            RunServer.descriptor,
            RunClient.descriptor,
            CoreCount.descriptor,
            QuitWorker.descriptor
        ]
    }
    @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
    internal typealias StreamingServiceProtocol = Grpc_Testing_WorkerServiceStreamingServiceProtocol
    @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
    internal typealias ServiceProtocol = Grpc_Testing_WorkerServiceServiceProtocol
}

extension GRPCCore.ServiceDescriptor {
    internal static let grpc_testing_WorkerService = Self(
        package: "grpc.testing",
        service: "WorkerService"
    )
}

@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
internal protocol Grpc_Testing_WorkerServiceStreamingServiceProtocol: GRPCCore.RegistrableRPCService {
    /// Start server with specified workload.
    /// First request sent specifies the ServerConfig followed by ServerStatus
    /// response. After that, a "Mark" can be sent anytime to request the latest
    /// stats. Closing the stream will initiate shutdown of the test server
    /// and once the shutdown has finished, the OK status is sent to terminate
    /// this RPC.
    func runServer(
        request: GRPCCore.ServerRequest.Stream<Grpc_Testing_ServerArgs>,
        context: GRPCCore.ServerContext
    ) async throws -> GRPCCore.ServerResponse.Stream<Grpc_Testing_ServerStatus>
    
    /// Start client with specified workload.
    /// First request sent specifies the ClientConfig followed by ClientStatus
    /// response. After that, a "Mark" can be sent anytime to request the latest
    /// stats. Closing the stream will initiate shutdown of the test client
    /// and once the shutdown has finished, the OK status is sent to terminate
    /// this RPC.
    func runClient(
        request: GRPCCore.ServerRequest.Stream<Grpc_Testing_ClientArgs>,
        context: GRPCCore.ServerContext
    ) async throws -> GRPCCore.ServerResponse.Stream<Grpc_Testing_ClientStatus>
    
    /// Just return the core count - unary call
    func coreCount(
        request: GRPCCore.ServerRequest.Stream<Grpc_Testing_CoreRequest>,
        context: GRPCCore.ServerContext
    ) async throws -> GRPCCore.ServerResponse.Stream<Grpc_Testing_CoreResponse>
    
    /// Quit this worker
    func quitWorker(
        request: GRPCCore.ServerRequest.Stream<Grpc_Testing_Void>,
        context: GRPCCore.ServerContext
    ) async throws -> GRPCCore.ServerResponse.Stream<Grpc_Testing_Void>
}

/// Conformance to `GRPCCore.RegistrableRPCService`.
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Grpc_Testing_WorkerService.StreamingServiceProtocol {
    @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
    internal func registerMethods(with router: inout GRPCCore.RPCRouter) {
        router.registerHandler(
            forMethod: Grpc_Testing_WorkerService.Method.RunServer.descriptor,
            deserializer: GRPCProtobuf.ProtobufDeserializer<Grpc_Testing_ServerArgs>(),
            serializer: GRPCProtobuf.ProtobufSerializer<Grpc_Testing_ServerStatus>(),
            handler: { request, context in
                try await self.runServer(
                    request: request,
                    context: context
                )
            }
        )
        router.registerHandler(
            forMethod: Grpc_Testing_WorkerService.Method.RunClient.descriptor,
            deserializer: GRPCProtobuf.ProtobufDeserializer<Grpc_Testing_ClientArgs>(),
            serializer: GRPCProtobuf.ProtobufSerializer<Grpc_Testing_ClientStatus>(),
            handler: { request, context in
                try await self.runClient(
                    request: request,
                    context: context
                )
            }
        )
        router.registerHandler(
            forMethod: Grpc_Testing_WorkerService.Method.CoreCount.descriptor,
            deserializer: GRPCProtobuf.ProtobufDeserializer<Grpc_Testing_CoreRequest>(),
            serializer: GRPCProtobuf.ProtobufSerializer<Grpc_Testing_CoreResponse>(),
            handler: { request, context in
                try await self.coreCount(
                    request: request,
                    context: context
                )
            }
        )
        router.registerHandler(
            forMethod: Grpc_Testing_WorkerService.Method.QuitWorker.descriptor,
            deserializer: GRPCProtobuf.ProtobufDeserializer<Grpc_Testing_Void>(),
            serializer: GRPCProtobuf.ProtobufSerializer<Grpc_Testing_Void>(),
            handler: { request, context in
                try await self.quitWorker(
                    request: request,
                    context: context
                )
            }
        )
    }
}

@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
internal protocol Grpc_Testing_WorkerServiceServiceProtocol: Grpc_Testing_WorkerService.StreamingServiceProtocol {
    /// Start server with specified workload.
    /// First request sent specifies the ServerConfig followed by ServerStatus
    /// response. After that, a "Mark" can be sent anytime to request the latest
    /// stats. Closing the stream will initiate shutdown of the test server
    /// and once the shutdown has finished, the OK status is sent to terminate
    /// this RPC.
    func runServer(
        request: GRPCCore.ServerRequest.Stream<Grpc_Testing_ServerArgs>,
        context: GRPCCore.ServerContext
    ) async throws -> GRPCCore.ServerResponse.Stream<Grpc_Testing_ServerStatus>
    
    /// Start client with specified workload.
    /// First request sent specifies the ClientConfig followed by ClientStatus
    /// response. After that, a "Mark" can be sent anytime to request the latest
    /// stats. Closing the stream will initiate shutdown of the test client
    /// and once the shutdown has finished, the OK status is sent to terminate
    /// this RPC.
    func runClient(
        request: GRPCCore.ServerRequest.Stream<Grpc_Testing_ClientArgs>,
        context: GRPCCore.ServerContext
    ) async throws -> GRPCCore.ServerResponse.Stream<Grpc_Testing_ClientStatus>
    
    /// Just return the core count - unary call
    func coreCount(
        request: GRPCCore.ServerRequest.Single<Grpc_Testing_CoreRequest>,
        context: GRPCCore.ServerContext
    ) async throws -> GRPCCore.ServerResponse.Single<Grpc_Testing_CoreResponse>
    
    /// Quit this worker
    func quitWorker(
        request: GRPCCore.ServerRequest.Single<Grpc_Testing_Void>,
        context: GRPCCore.ServerContext
    ) async throws -> GRPCCore.ServerResponse.Single<Grpc_Testing_Void>
}

/// Partial conformance to `Grpc_Testing_WorkerServiceStreamingServiceProtocol`.
@available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
extension Grpc_Testing_WorkerService.ServiceProtocol {
    internal func coreCount(
        request: GRPCCore.ServerRequest.Stream<Grpc_Testing_CoreRequest>,
        context: GRPCCore.ServerContext
    ) async throws -> GRPCCore.ServerResponse.Stream<Grpc_Testing_CoreResponse> {
        let response = try await self.coreCount(
            request: GRPCCore.ServerRequest.Single(stream: request),
            context: context
        )
        return GRPCCore.ServerResponse.Stream(single: response)
    }
    
    internal func quitWorker(
        request: GRPCCore.ServerRequest.Stream<Grpc_Testing_Void>,
        context: GRPCCore.ServerContext
    ) async throws -> GRPCCore.ServerResponse.Stream<Grpc_Testing_Void> {
        let response = try await self.quitWorker(
            request: GRPCCore.ServerRequest.Single(stream: request),
            context: context
        )
        return GRPCCore.ServerResponse.Stream(single: response)
    }
}