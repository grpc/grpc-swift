// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: grpc/testing/control.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2015 gRPC authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Grpc_Testing_ClientType: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int

  /// Many languages support a basic distinction between using
  /// sync or async client, and this allows the specification
  case syncClient // = 0
  case asyncClient // = 1

  /// used for some language-specific variants
  case otherClient // = 2
  case callbackClient // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .syncClient
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .syncClient
    case 1: self = .asyncClient
    case 2: self = .otherClient
    case 3: self = .callbackClient
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .syncClient: return 0
    case .asyncClient: return 1
    case .otherClient: return 2
    case .callbackClient: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Grpc_Testing_ClientType] = [
    .syncClient,
    .asyncClient,
    .otherClient,
    .callbackClient,
  ]

}

enum Grpc_Testing_ServerType: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case syncServer // = 0
  case asyncServer // = 1
  case asyncGenericServer // = 2

  /// used for some language-specific variants
  case otherServer // = 3
  case callbackServer // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .syncServer
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .syncServer
    case 1: self = .asyncServer
    case 2: self = .asyncGenericServer
    case 3: self = .otherServer
    case 4: self = .callbackServer
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .syncServer: return 0
    case .asyncServer: return 1
    case .asyncGenericServer: return 2
    case .otherServer: return 3
    case .callbackServer: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Grpc_Testing_ServerType] = [
    .syncServer,
    .asyncServer,
    .asyncGenericServer,
    .otherServer,
    .callbackServer,
  ]

}

enum Grpc_Testing_RpcType: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case unary // = 0
  case streaming // = 1
  case streamingFromClient // = 2
  case streamingFromServer // = 3
  case streamingBothWays // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .unary
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unary
    case 1: self = .streaming
    case 2: self = .streamingFromClient
    case 3: self = .streamingFromServer
    case 4: self = .streamingBothWays
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unary: return 0
    case .streaming: return 1
    case .streamingFromClient: return 2
    case .streamingFromServer: return 3
    case .streamingBothWays: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Grpc_Testing_RpcType] = [
    .unary,
    .streaming,
    .streamingFromClient,
    .streamingFromServer,
    .streamingBothWays,
  ]

}

/// Parameters of poisson process distribution, which is a good representation
/// of activity coming in from independent identical stationary sources.
struct Grpc_Testing_PoissonParams: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The rate of arrivals (a.k.a. lambda parameter of the exp distribution).
  var offeredLoad: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Once an RPC finishes, immediately start a new one.
/// No configuration parameters needed.
struct Grpc_Testing_ClosedLoopParams: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Grpc_Testing_LoadParams: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var load: Grpc_Testing_LoadParams.OneOf_Load? = nil

  var closedLoop: Grpc_Testing_ClosedLoopParams {
    get {
      if case .closedLoop(let v)? = load {return v}
      return Grpc_Testing_ClosedLoopParams()
    }
    set {load = .closedLoop(newValue)}
  }

  var poisson: Grpc_Testing_PoissonParams {
    get {
      if case .poisson(let v)? = load {return v}
      return Grpc_Testing_PoissonParams()
    }
    set {load = .poisson(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Load: Equatable, Sendable {
    case closedLoop(Grpc_Testing_ClosedLoopParams)
    case poisson(Grpc_Testing_PoissonParams)

  }

  init() {}
}

/// presence of SecurityParams implies use of TLS
struct Grpc_Testing_SecurityParams: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var useTestCa: Bool = false

  var serverHostOverride: String = String()

  var credType: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Grpc_Testing_ChannelArg: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String = String()

  var value: Grpc_Testing_ChannelArg.OneOf_Value? = nil

  var strValue: String {
    get {
      if case .strValue(let v)? = value {return v}
      return String()
    }
    set {value = .strValue(newValue)}
  }

  var intValue: Int32 {
    get {
      if case .intValue(let v)? = value {return v}
      return 0
    }
    set {value = .intValue(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Value: Equatable, Sendable {
    case strValue(String)
    case intValue(Int32)

  }

  init() {}
}

struct Grpc_Testing_ClientConfig: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of targets to connect to. At least one target needs to be specified.
  var serverTargets: [String] {
    get {return _storage._serverTargets}
    set {_uniqueStorage()._serverTargets = newValue}
  }

  var clientType: Grpc_Testing_ClientType {
    get {return _storage._clientType}
    set {_uniqueStorage()._clientType = newValue}
  }

  var securityParams: Grpc_Testing_SecurityParams {
    get {return _storage._securityParams ?? Grpc_Testing_SecurityParams()}
    set {_uniqueStorage()._securityParams = newValue}
  }
  /// Returns true if `securityParams` has been explicitly set.
  var hasSecurityParams: Bool {return _storage._securityParams != nil}
  /// Clears the value of `securityParams`. Subsequent reads from it will return its default value.
  mutating func clearSecurityParams() {_uniqueStorage()._securityParams = nil}

  /// How many concurrent RPCs to start for each channel.
  /// For synchronous client, use a separate thread for each outstanding RPC.
  var outstandingRpcsPerChannel: Int32 {
    get {return _storage._outstandingRpcsPerChannel}
    set {_uniqueStorage()._outstandingRpcsPerChannel = newValue}
  }

  /// Number of independent client channels to create.
  /// i-th channel will connect to server_target[i % server_targets.size()]
  var clientChannels: Int32 {
    get {return _storage._clientChannels}
    set {_uniqueStorage()._clientChannels = newValue}
  }

  /// Only for async client. Number of threads to use to start/manage RPCs.
  var asyncClientThreads: Int32 {
    get {return _storage._asyncClientThreads}
    set {_uniqueStorage()._asyncClientThreads = newValue}
  }

  var rpcType: Grpc_Testing_RpcType {
    get {return _storage._rpcType}
    set {_uniqueStorage()._rpcType = newValue}
  }

  /// The requested load for the entire client (aggregated over all the threads).
  var loadParams: Grpc_Testing_LoadParams {
    get {return _storage._loadParams ?? Grpc_Testing_LoadParams()}
    set {_uniqueStorage()._loadParams = newValue}
  }
  /// Returns true if `loadParams` has been explicitly set.
  var hasLoadParams: Bool {return _storage._loadParams != nil}
  /// Clears the value of `loadParams`. Subsequent reads from it will return its default value.
  mutating func clearLoadParams() {_uniqueStorage()._loadParams = nil}

  var payloadConfig: Grpc_Testing_PayloadConfig {
    get {return _storage._payloadConfig ?? Grpc_Testing_PayloadConfig()}
    set {_uniqueStorage()._payloadConfig = newValue}
  }
  /// Returns true if `payloadConfig` has been explicitly set.
  var hasPayloadConfig: Bool {return _storage._payloadConfig != nil}
  /// Clears the value of `payloadConfig`. Subsequent reads from it will return its default value.
  mutating func clearPayloadConfig() {_uniqueStorage()._payloadConfig = nil}

  var histogramParams: Grpc_Testing_HistogramParams {
    get {return _storage._histogramParams ?? Grpc_Testing_HistogramParams()}
    set {_uniqueStorage()._histogramParams = newValue}
  }
  /// Returns true if `histogramParams` has been explicitly set.
  var hasHistogramParams: Bool {return _storage._histogramParams != nil}
  /// Clears the value of `histogramParams`. Subsequent reads from it will return its default value.
  mutating func clearHistogramParams() {_uniqueStorage()._histogramParams = nil}

  /// Specify the cores we should run the client on, if desired
  var coreList: [Int32] {
    get {return _storage._coreList}
    set {_uniqueStorage()._coreList = newValue}
  }

  var coreLimit: Int32 {
    get {return _storage._coreLimit}
    set {_uniqueStorage()._coreLimit = newValue}
  }

  /// If we use an OTHER_CLIENT client_type, this string gives more detail
  var otherClientApi: String {
    get {return _storage._otherClientApi}
    set {_uniqueStorage()._otherClientApi = newValue}
  }

  var channelArgs: [Grpc_Testing_ChannelArg] {
    get {return _storage._channelArgs}
    set {_uniqueStorage()._channelArgs = newValue}
  }

  /// Number of threads that share each completion queue
  var threadsPerCq: Int32 {
    get {return _storage._threadsPerCq}
    set {_uniqueStorage()._threadsPerCq = newValue}
  }

  /// Number of messages on a stream before it gets finished/restarted
  var messagesPerStream: Int32 {
    get {return _storage._messagesPerStream}
    set {_uniqueStorage()._messagesPerStream = newValue}
  }

  /// Use coalescing API when possible.
  var useCoalesceApi: Bool {
    get {return _storage._useCoalesceApi}
    set {_uniqueStorage()._useCoalesceApi = newValue}
  }

  /// If 0, disabled. Else, specifies the period between gathering latency
  /// medians in milliseconds.
  var medianLatencyCollectionIntervalMillis: Int32 {
    get {return _storage._medianLatencyCollectionIntervalMillis}
    set {_uniqueStorage()._medianLatencyCollectionIntervalMillis = newValue}
  }

  /// Number of client processes. 0 indicates no restriction.
  var clientProcesses: Int32 {
    get {return _storage._clientProcesses}
    set {_uniqueStorage()._clientProcesses = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Grpc_Testing_ClientStatus: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var stats: Grpc_Testing_ClientStats {
    get {return _stats ?? Grpc_Testing_ClientStats()}
    set {_stats = newValue}
  }
  /// Returns true if `stats` has been explicitly set.
  var hasStats: Bool {return self._stats != nil}
  /// Clears the value of `stats`. Subsequent reads from it will return its default value.
  mutating func clearStats() {self._stats = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _stats: Grpc_Testing_ClientStats? = nil
}

/// Request current stats
struct Grpc_Testing_Mark: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// if true, the stats will be reset after taking their snapshot.
  var reset: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Grpc_Testing_ClientArgs: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var argtype: Grpc_Testing_ClientArgs.OneOf_Argtype? = nil

  var setup: Grpc_Testing_ClientConfig {
    get {
      if case .setup(let v)? = argtype {return v}
      return Grpc_Testing_ClientConfig()
    }
    set {argtype = .setup(newValue)}
  }

  var mark: Grpc_Testing_Mark {
    get {
      if case .mark(let v)? = argtype {return v}
      return Grpc_Testing_Mark()
    }
    set {argtype = .mark(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Argtype: Equatable, Sendable {
    case setup(Grpc_Testing_ClientConfig)
    case mark(Grpc_Testing_Mark)

  }

  init() {}
}

struct Grpc_Testing_ServerConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var serverType: Grpc_Testing_ServerType = .syncServer

  var securityParams: Grpc_Testing_SecurityParams {
    get {return _securityParams ?? Grpc_Testing_SecurityParams()}
    set {_securityParams = newValue}
  }
  /// Returns true if `securityParams` has been explicitly set.
  var hasSecurityParams: Bool {return self._securityParams != nil}
  /// Clears the value of `securityParams`. Subsequent reads from it will return its default value.
  mutating func clearSecurityParams() {self._securityParams = nil}

  /// Port on which to listen. Zero means pick unused port.
  var port: Int32 = 0

  /// Only for async server. Number of threads used to serve the requests.
  var asyncServerThreads: Int32 = 0

  /// Specify the number of cores to limit server to, if desired
  var coreLimit: Int32 = 0

  /// payload config, used in generic server.
  /// Note this must NOT be used in proto (non-generic) servers. For proto servers,
  /// 'response sizes' must be configured from the 'response_size' field of the
  /// 'SimpleRequest' objects in RPC requests.
  var payloadConfig: Grpc_Testing_PayloadConfig {
    get {return _payloadConfig ?? Grpc_Testing_PayloadConfig()}
    set {_payloadConfig = newValue}
  }
  /// Returns true if `payloadConfig` has been explicitly set.
  var hasPayloadConfig: Bool {return self._payloadConfig != nil}
  /// Clears the value of `payloadConfig`. Subsequent reads from it will return its default value.
  mutating func clearPayloadConfig() {self._payloadConfig = nil}

  /// Specify the cores we should run the server on, if desired
  var coreList: [Int32] = []

  /// If we use an OTHER_SERVER client_type, this string gives more detail
  var otherServerApi: String = String()

  /// Number of threads that share each completion queue
  var threadsPerCq: Int32 = 0

  /// Buffer pool size (no buffer pool specified if unset)
  var resourceQuotaSize: Int32 = 0

  var channelArgs: [Grpc_Testing_ChannelArg] = []

  /// Number of server processes. 0 indicates no restriction.
  var serverProcesses: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _securityParams: Grpc_Testing_SecurityParams? = nil
  fileprivate var _payloadConfig: Grpc_Testing_PayloadConfig? = nil
}

struct Grpc_Testing_ServerArgs: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var argtype: Grpc_Testing_ServerArgs.OneOf_Argtype? = nil

  var setup: Grpc_Testing_ServerConfig {
    get {
      if case .setup(let v)? = argtype {return v}
      return Grpc_Testing_ServerConfig()
    }
    set {argtype = .setup(newValue)}
  }

  var mark: Grpc_Testing_Mark {
    get {
      if case .mark(let v)? = argtype {return v}
      return Grpc_Testing_Mark()
    }
    set {argtype = .mark(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Argtype: Equatable, Sendable {
    case setup(Grpc_Testing_ServerConfig)
    case mark(Grpc_Testing_Mark)

  }

  init() {}
}

struct Grpc_Testing_ServerStatus: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var stats: Grpc_Testing_ServerStats {
    get {return _stats ?? Grpc_Testing_ServerStats()}
    set {_stats = newValue}
  }
  /// Returns true if `stats` has been explicitly set.
  var hasStats: Bool {return self._stats != nil}
  /// Clears the value of `stats`. Subsequent reads from it will return its default value.
  mutating func clearStats() {self._stats = nil}

  /// the port bound by the server
  var port: Int32 = 0

  /// Number of cores available to the server
  var cores: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _stats: Grpc_Testing_ServerStats? = nil
}

struct Grpc_Testing_CoreRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Grpc_Testing_CoreResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Number of cores available on the server
  var cores: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Grpc_Testing_Void: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A single performance scenario: input to qps_json_driver
struct Grpc_Testing_Scenario: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Human readable name for this scenario
  var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// Client configuration
  var clientConfig: Grpc_Testing_ClientConfig {
    get {return _storage._clientConfig ?? Grpc_Testing_ClientConfig()}
    set {_uniqueStorage()._clientConfig = newValue}
  }
  /// Returns true if `clientConfig` has been explicitly set.
  var hasClientConfig: Bool {return _storage._clientConfig != nil}
  /// Clears the value of `clientConfig`. Subsequent reads from it will return its default value.
  mutating func clearClientConfig() {_uniqueStorage()._clientConfig = nil}

  /// Number of clients to start for the test
  var numClients: Int32 {
    get {return _storage._numClients}
    set {_uniqueStorage()._numClients = newValue}
  }

  /// Server configuration
  var serverConfig: Grpc_Testing_ServerConfig {
    get {return _storage._serverConfig ?? Grpc_Testing_ServerConfig()}
    set {_uniqueStorage()._serverConfig = newValue}
  }
  /// Returns true if `serverConfig` has been explicitly set.
  var hasServerConfig: Bool {return _storage._serverConfig != nil}
  /// Clears the value of `serverConfig`. Subsequent reads from it will return its default value.
  mutating func clearServerConfig() {_uniqueStorage()._serverConfig = nil}

  /// Number of servers to start for the test
  var numServers: Int32 {
    get {return _storage._numServers}
    set {_uniqueStorage()._numServers = newValue}
  }

  /// Warmup period, in seconds
  var warmupSeconds: Int32 {
    get {return _storage._warmupSeconds}
    set {_uniqueStorage()._warmupSeconds = newValue}
  }

  /// Benchmark time, in seconds
  var benchmarkSeconds: Int32 {
    get {return _storage._benchmarkSeconds}
    set {_uniqueStorage()._benchmarkSeconds = newValue}
  }

  /// Number of workers to spawn locally (usually zero)
  var spawnLocalWorkerCount: Int32 {
    get {return _storage._spawnLocalWorkerCount}
    set {_uniqueStorage()._spawnLocalWorkerCount = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// A set of scenarios to be run with qps_json_driver
struct Grpc_Testing_Scenarios: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var scenarios: [Grpc_Testing_Scenario] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Basic summary that can be computed from ClientStats and ServerStats
/// once the scenario has finished.
struct Grpc_Testing_ScenarioResultSummary: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Total number of operations per second over all clients. What is counted as 1 'operation' depends on the benchmark scenarios:
  /// For unary benchmarks, an operation is processing of a single unary RPC. 
  /// For streaming benchmarks, an operation is processing of a single ping pong of request and response. 
  var qps: Double {
    get {return _storage._qps}
    set {_uniqueStorage()._qps = newValue}
  }

  /// QPS per server core.
  var qpsPerServerCore: Double {
    get {return _storage._qpsPerServerCore}
    set {_uniqueStorage()._qpsPerServerCore = newValue}
  }

  /// The total server cpu load based on system time across all server processes, expressed as percentage of a single cpu core.
  /// For example, 85 implies 85% of a cpu core, 125 implies 125% of a cpu core. Since we are accumulating the cpu load across all the server 
  /// processes, the value could > 100 when there are multiple servers or a single server using multiple threads and cores. 
  /// Same explanation for the total client cpu load below.
  var serverSystemTime: Double {
    get {return _storage._serverSystemTime}
    set {_uniqueStorage()._serverSystemTime = newValue}
  }

  /// The total server cpu load based on user time across all server processes, expressed as percentage of a single cpu core. (85 => 85%, 125 => 125%)
  var serverUserTime: Double {
    get {return _storage._serverUserTime}
    set {_uniqueStorage()._serverUserTime = newValue}
  }

  /// The total client cpu load based on system time across all client processes, expressed as percentage of a single cpu core. (85 => 85%, 125 => 125%)
  var clientSystemTime: Double {
    get {return _storage._clientSystemTime}
    set {_uniqueStorage()._clientSystemTime = newValue}
  }

  /// The total client cpu load based on user time across all client processes, expressed as percentage of a single cpu core. (85 => 85%, 125 => 125%)
  var clientUserTime: Double {
    get {return _storage._clientUserTime}
    set {_uniqueStorage()._clientUserTime = newValue}
  }

  /// X% latency percentiles (in nanoseconds)
  var latency50: Double {
    get {return _storage._latency50}
    set {_uniqueStorage()._latency50 = newValue}
  }

  var latency90: Double {
    get {return _storage._latency90}
    set {_uniqueStorage()._latency90 = newValue}
  }

  var latency95: Double {
    get {return _storage._latency95}
    set {_uniqueStorage()._latency95 = newValue}
  }

  var latency99: Double {
    get {return _storage._latency99}
    set {_uniqueStorage()._latency99 = newValue}
  }

  var latency999: Double {
    get {return _storage._latency999}
    set {_uniqueStorage()._latency999 = newValue}
  }

  /// server cpu usage percentage
  var serverCpuUsage: Double {
    get {return _storage._serverCpuUsage}
    set {_uniqueStorage()._serverCpuUsage = newValue}
  }

  /// Number of requests that succeeded/failed
  var successfulRequestsPerSecond: Double {
    get {return _storage._successfulRequestsPerSecond}
    set {_uniqueStorage()._successfulRequestsPerSecond = newValue}
  }

  var failedRequestsPerSecond: Double {
    get {return _storage._failedRequestsPerSecond}
    set {_uniqueStorage()._failedRequestsPerSecond = newValue}
  }

  /// Number of polls called inside completion queue per request
  var clientPollsPerRequest: Double {
    get {return _storage._clientPollsPerRequest}
    set {_uniqueStorage()._clientPollsPerRequest = newValue}
  }

  var serverPollsPerRequest: Double {
    get {return _storage._serverPollsPerRequest}
    set {_uniqueStorage()._serverPollsPerRequest = newValue}
  }

  /// Queries per CPU-sec over all servers or clients
  var serverQueriesPerCpuSec: Double {
    get {return _storage._serverQueriesPerCpuSec}
    set {_uniqueStorage()._serverQueriesPerCpuSec = newValue}
  }

  var clientQueriesPerCpuSec: Double {
    get {return _storage._clientQueriesPerCpuSec}
    set {_uniqueStorage()._clientQueriesPerCpuSec = newValue}
  }

  /// Start and end time for the test scenario
  var startTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._startTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  var hasStartTime: Bool {return _storage._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  mutating func clearStartTime() {_uniqueStorage()._startTime = nil}

  var endTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._endTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._endTime = newValue}
  }
  /// Returns true if `endTime` has been explicitly set.
  var hasEndTime: Bool {return _storage._endTime != nil}
  /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
  mutating func clearEndTime() {_uniqueStorage()._endTime = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Results of a single benchmark scenario.
struct Grpc_Testing_ScenarioResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Inputs used to run the scenario.
  var scenario: Grpc_Testing_Scenario {
    get {return _scenario ?? Grpc_Testing_Scenario()}
    set {_scenario = newValue}
  }
  /// Returns true if `scenario` has been explicitly set.
  var hasScenario: Bool {return self._scenario != nil}
  /// Clears the value of `scenario`. Subsequent reads from it will return its default value.
  mutating func clearScenario() {self._scenario = nil}

  /// Histograms from all clients merged into one histogram.
  var latencies: Grpc_Testing_HistogramData {
    get {return _latencies ?? Grpc_Testing_HistogramData()}
    set {_latencies = newValue}
  }
  /// Returns true if `latencies` has been explicitly set.
  var hasLatencies: Bool {return self._latencies != nil}
  /// Clears the value of `latencies`. Subsequent reads from it will return its default value.
  mutating func clearLatencies() {self._latencies = nil}

  /// Client stats for each client
  var clientStats: [Grpc_Testing_ClientStats] = []

  /// Server stats for each server
  var serverStats: [Grpc_Testing_ServerStats] = []

  /// Number of cores available to each server
  var serverCores: [Int32] = []

  /// An after-the-fact computed summary
  var summary: Grpc_Testing_ScenarioResultSummary {
    get {return _summary ?? Grpc_Testing_ScenarioResultSummary()}
    set {_summary = newValue}
  }
  /// Returns true if `summary` has been explicitly set.
  var hasSummary: Bool {return self._summary != nil}
  /// Clears the value of `summary`. Subsequent reads from it will return its default value.
  mutating func clearSummary() {self._summary = nil}

  /// Information on success or failure of each worker
  var clientSuccess: [Bool] = []

  var serverSuccess: [Bool] = []

  /// Number of failed requests (one row per status code seen)
  var requestResults: [Grpc_Testing_RequestResultCount] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _scenario: Grpc_Testing_Scenario? = nil
  fileprivate var _latencies: Grpc_Testing_HistogramData? = nil
  fileprivate var _summary: Grpc_Testing_ScenarioResultSummary? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "grpc.testing"

extension Grpc_Testing_ClientType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SYNC_CLIENT"),
    1: .same(proto: "ASYNC_CLIENT"),
    2: .same(proto: "OTHER_CLIENT"),
    3: .same(proto: "CALLBACK_CLIENT"),
  ]
}

extension Grpc_Testing_ServerType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SYNC_SERVER"),
    1: .same(proto: "ASYNC_SERVER"),
    2: .same(proto: "ASYNC_GENERIC_SERVER"),
    3: .same(proto: "OTHER_SERVER"),
    4: .same(proto: "CALLBACK_SERVER"),
  ]
}

extension Grpc_Testing_RpcType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNARY"),
    1: .same(proto: "STREAMING"),
    2: .same(proto: "STREAMING_FROM_CLIENT"),
    3: .same(proto: "STREAMING_FROM_SERVER"),
    4: .same(proto: "STREAMING_BOTH_WAYS"),
  ]
}

extension Grpc_Testing_PoissonParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PoissonParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "offered_load"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.offeredLoad) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.offeredLoad.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.offeredLoad, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_Testing_PoissonParams, rhs: Grpc_Testing_PoissonParams) -> Bool {
    if lhs.offeredLoad != rhs.offeredLoad {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_Testing_ClosedLoopParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClosedLoopParams"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_Testing_ClosedLoopParams, rhs: Grpc_Testing_ClosedLoopParams) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_Testing_LoadParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LoadParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "closed_loop"),
    2: .same(proto: "poisson"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Grpc_Testing_ClosedLoopParams?
        var hadOneofValue = false
        if let current = self.load {
          hadOneofValue = true
          if case .closedLoop(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.load = .closedLoop(v)
        }
      }()
      case 2: try {
        var v: Grpc_Testing_PoissonParams?
        var hadOneofValue = false
        if let current = self.load {
          hadOneofValue = true
          if case .poisson(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.load = .poisson(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.load {
    case .closedLoop?: try {
      guard case .closedLoop(let v)? = self.load else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .poisson?: try {
      guard case .poisson(let v)? = self.load else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_Testing_LoadParams, rhs: Grpc_Testing_LoadParams) -> Bool {
    if lhs.load != rhs.load {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_Testing_SecurityParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SecurityParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "use_test_ca"),
    2: .standard(proto: "server_host_override"),
    3: .standard(proto: "cred_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.useTestCa) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.serverHostOverride) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.credType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.useTestCa != false {
      try visitor.visitSingularBoolField(value: self.useTestCa, fieldNumber: 1)
    }
    if !self.serverHostOverride.isEmpty {
      try visitor.visitSingularStringField(value: self.serverHostOverride, fieldNumber: 2)
    }
    if !self.credType.isEmpty {
      try visitor.visitSingularStringField(value: self.credType, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_Testing_SecurityParams, rhs: Grpc_Testing_SecurityParams) -> Bool {
    if lhs.useTestCa != rhs.useTestCa {return false}
    if lhs.serverHostOverride != rhs.serverHostOverride {return false}
    if lhs.credType != rhs.credType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_Testing_ChannelArg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChannelArg"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "str_value"),
    3: .standard(proto: "int_value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .strValue(v)
        }
      }()
      case 3: try {
        var v: Int32?
        try decoder.decodeSingularInt32Field(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .intValue(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    switch self.value {
    case .strValue?: try {
      guard case .strValue(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case .intValue?: try {
      guard case .intValue(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_Testing_ChannelArg, rhs: Grpc_Testing_ChannelArg) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_Testing_ClientConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClientConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "server_targets"),
    2: .standard(proto: "client_type"),
    3: .standard(proto: "security_params"),
    4: .standard(proto: "outstanding_rpcs_per_channel"),
    5: .standard(proto: "client_channels"),
    7: .standard(proto: "async_client_threads"),
    8: .standard(proto: "rpc_type"),
    10: .standard(proto: "load_params"),
    11: .standard(proto: "payload_config"),
    12: .standard(proto: "histogram_params"),
    13: .standard(proto: "core_list"),
    14: .standard(proto: "core_limit"),
    15: .standard(proto: "other_client_api"),
    16: .standard(proto: "channel_args"),
    17: .standard(proto: "threads_per_cq"),
    18: .standard(proto: "messages_per_stream"),
    19: .standard(proto: "use_coalesce_api"),
    20: .standard(proto: "median_latency_collection_interval_millis"),
    21: .standard(proto: "client_processes"),
  ]

  fileprivate class _StorageClass {
    var _serverTargets: [String] = []
    var _clientType: Grpc_Testing_ClientType = .syncClient
    var _securityParams: Grpc_Testing_SecurityParams? = nil
    var _outstandingRpcsPerChannel: Int32 = 0
    var _clientChannels: Int32 = 0
    var _asyncClientThreads: Int32 = 0
    var _rpcType: Grpc_Testing_RpcType = .unary
    var _loadParams: Grpc_Testing_LoadParams? = nil
    var _payloadConfig: Grpc_Testing_PayloadConfig? = nil
    var _histogramParams: Grpc_Testing_HistogramParams? = nil
    var _coreList: [Int32] = []
    var _coreLimit: Int32 = 0
    var _otherClientApi: String = String()
    var _channelArgs: [Grpc_Testing_ChannelArg] = []
    var _threadsPerCq: Int32 = 0
    var _messagesPerStream: Int32 = 0
    var _useCoalesceApi: Bool = false
    var _medianLatencyCollectionIntervalMillis: Int32 = 0
    var _clientProcesses: Int32 = 0

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _serverTargets = source._serverTargets
      _clientType = source._clientType
      _securityParams = source._securityParams
      _outstandingRpcsPerChannel = source._outstandingRpcsPerChannel
      _clientChannels = source._clientChannels
      _asyncClientThreads = source._asyncClientThreads
      _rpcType = source._rpcType
      _loadParams = source._loadParams
      _payloadConfig = source._payloadConfig
      _histogramParams = source._histogramParams
      _coreList = source._coreList
      _coreLimit = source._coreLimit
      _otherClientApi = source._otherClientApi
      _channelArgs = source._channelArgs
      _threadsPerCq = source._threadsPerCq
      _messagesPerStream = source._messagesPerStream
      _useCoalesceApi = source._useCoalesceApi
      _medianLatencyCollectionIntervalMillis = source._medianLatencyCollectionIntervalMillis
      _clientProcesses = source._clientProcesses
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeRepeatedStringField(value: &_storage._serverTargets) }()
        case 2: try { try decoder.decodeSingularEnumField(value: &_storage._clientType) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._securityParams) }()
        case 4: try { try decoder.decodeSingularInt32Field(value: &_storage._outstandingRpcsPerChannel) }()
        case 5: try { try decoder.decodeSingularInt32Field(value: &_storage._clientChannels) }()
        case 7: try { try decoder.decodeSingularInt32Field(value: &_storage._asyncClientThreads) }()
        case 8: try { try decoder.decodeSingularEnumField(value: &_storage._rpcType) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._loadParams) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._payloadConfig) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._histogramParams) }()
        case 13: try { try decoder.decodeRepeatedInt32Field(value: &_storage._coreList) }()
        case 14: try { try decoder.decodeSingularInt32Field(value: &_storage._coreLimit) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._otherClientApi) }()
        case 16: try { try decoder.decodeRepeatedMessageField(value: &_storage._channelArgs) }()
        case 17: try { try decoder.decodeSingularInt32Field(value: &_storage._threadsPerCq) }()
        case 18: try { try decoder.decodeSingularInt32Field(value: &_storage._messagesPerStream) }()
        case 19: try { try decoder.decodeSingularBoolField(value: &_storage._useCoalesceApi) }()
        case 20: try { try decoder.decodeSingularInt32Field(value: &_storage._medianLatencyCollectionIntervalMillis) }()
        case 21: try { try decoder.decodeSingularInt32Field(value: &_storage._clientProcesses) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._serverTargets.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._serverTargets, fieldNumber: 1)
      }
      if _storage._clientType != .syncClient {
        try visitor.visitSingularEnumField(value: _storage._clientType, fieldNumber: 2)
      }
      try { if let v = _storage._securityParams {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if _storage._outstandingRpcsPerChannel != 0 {
        try visitor.visitSingularInt32Field(value: _storage._outstandingRpcsPerChannel, fieldNumber: 4)
      }
      if _storage._clientChannels != 0 {
        try visitor.visitSingularInt32Field(value: _storage._clientChannels, fieldNumber: 5)
      }
      if _storage._asyncClientThreads != 0 {
        try visitor.visitSingularInt32Field(value: _storage._asyncClientThreads, fieldNumber: 7)
      }
      if _storage._rpcType != .unary {
        try visitor.visitSingularEnumField(value: _storage._rpcType, fieldNumber: 8)
      }
      try { if let v = _storage._loadParams {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._payloadConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._histogramParams {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      if !_storage._coreList.isEmpty {
        try visitor.visitPackedInt32Field(value: _storage._coreList, fieldNumber: 13)
      }
      if _storage._coreLimit != 0 {
        try visitor.visitSingularInt32Field(value: _storage._coreLimit, fieldNumber: 14)
      }
      if !_storage._otherClientApi.isEmpty {
        try visitor.visitSingularStringField(value: _storage._otherClientApi, fieldNumber: 15)
      }
      if !_storage._channelArgs.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._channelArgs, fieldNumber: 16)
      }
      if _storage._threadsPerCq != 0 {
        try visitor.visitSingularInt32Field(value: _storage._threadsPerCq, fieldNumber: 17)
      }
      if _storage._messagesPerStream != 0 {
        try visitor.visitSingularInt32Field(value: _storage._messagesPerStream, fieldNumber: 18)
      }
      if _storage._useCoalesceApi != false {
        try visitor.visitSingularBoolField(value: _storage._useCoalesceApi, fieldNumber: 19)
      }
      if _storage._medianLatencyCollectionIntervalMillis != 0 {
        try visitor.visitSingularInt32Field(value: _storage._medianLatencyCollectionIntervalMillis, fieldNumber: 20)
      }
      if _storage._clientProcesses != 0 {
        try visitor.visitSingularInt32Field(value: _storage._clientProcesses, fieldNumber: 21)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_Testing_ClientConfig, rhs: Grpc_Testing_ClientConfig) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._serverTargets != rhs_storage._serverTargets {return false}
        if _storage._clientType != rhs_storage._clientType {return false}
        if _storage._securityParams != rhs_storage._securityParams {return false}
        if _storage._outstandingRpcsPerChannel != rhs_storage._outstandingRpcsPerChannel {return false}
        if _storage._clientChannels != rhs_storage._clientChannels {return false}
        if _storage._asyncClientThreads != rhs_storage._asyncClientThreads {return false}
        if _storage._rpcType != rhs_storage._rpcType {return false}
        if _storage._loadParams != rhs_storage._loadParams {return false}
        if _storage._payloadConfig != rhs_storage._payloadConfig {return false}
        if _storage._histogramParams != rhs_storage._histogramParams {return false}
        if _storage._coreList != rhs_storage._coreList {return false}
        if _storage._coreLimit != rhs_storage._coreLimit {return false}
        if _storage._otherClientApi != rhs_storage._otherClientApi {return false}
        if _storage._channelArgs != rhs_storage._channelArgs {return false}
        if _storage._threadsPerCq != rhs_storage._threadsPerCq {return false}
        if _storage._messagesPerStream != rhs_storage._messagesPerStream {return false}
        if _storage._useCoalesceApi != rhs_storage._useCoalesceApi {return false}
        if _storage._medianLatencyCollectionIntervalMillis != rhs_storage._medianLatencyCollectionIntervalMillis {return false}
        if _storage._clientProcesses != rhs_storage._clientProcesses {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_Testing_ClientStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClientStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "stats"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._stats) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._stats {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_Testing_ClientStatus, rhs: Grpc_Testing_ClientStatus) -> Bool {
    if lhs._stats != rhs._stats {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_Testing_Mark: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Mark"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reset"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.reset) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.reset != false {
      try visitor.visitSingularBoolField(value: self.reset, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_Testing_Mark, rhs: Grpc_Testing_Mark) -> Bool {
    if lhs.reset != rhs.reset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_Testing_ClientArgs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClientArgs"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "setup"),
    2: .same(proto: "mark"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Grpc_Testing_ClientConfig?
        var hadOneofValue = false
        if let current = self.argtype {
          hadOneofValue = true
          if case .setup(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.argtype = .setup(v)
        }
      }()
      case 2: try {
        var v: Grpc_Testing_Mark?
        var hadOneofValue = false
        if let current = self.argtype {
          hadOneofValue = true
          if case .mark(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.argtype = .mark(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.argtype {
    case .setup?: try {
      guard case .setup(let v)? = self.argtype else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .mark?: try {
      guard case .mark(let v)? = self.argtype else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_Testing_ClientArgs, rhs: Grpc_Testing_ClientArgs) -> Bool {
    if lhs.argtype != rhs.argtype {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_Testing_ServerConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ServerConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "server_type"),
    2: .standard(proto: "security_params"),
    4: .same(proto: "port"),
    7: .standard(proto: "async_server_threads"),
    8: .standard(proto: "core_limit"),
    9: .standard(proto: "payload_config"),
    10: .standard(proto: "core_list"),
    11: .standard(proto: "other_server_api"),
    12: .standard(proto: "threads_per_cq"),
    1001: .standard(proto: "resource_quota_size"),
    1002: .standard(proto: "channel_args"),
    21: .standard(proto: "server_processes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.serverType) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._securityParams) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.port) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.asyncServerThreads) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.coreLimit) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._payloadConfig) }()
      case 10: try { try decoder.decodeRepeatedInt32Field(value: &self.coreList) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.otherServerApi) }()
      case 12: try { try decoder.decodeSingularInt32Field(value: &self.threadsPerCq) }()
      case 21: try { try decoder.decodeSingularInt32Field(value: &self.serverProcesses) }()
      case 1001: try { try decoder.decodeSingularInt32Field(value: &self.resourceQuotaSize) }()
      case 1002: try { try decoder.decodeRepeatedMessageField(value: &self.channelArgs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.serverType != .syncServer {
      try visitor.visitSingularEnumField(value: self.serverType, fieldNumber: 1)
    }
    try { if let v = self._securityParams {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.port != 0 {
      try visitor.visitSingularInt32Field(value: self.port, fieldNumber: 4)
    }
    if self.asyncServerThreads != 0 {
      try visitor.visitSingularInt32Field(value: self.asyncServerThreads, fieldNumber: 7)
    }
    if self.coreLimit != 0 {
      try visitor.visitSingularInt32Field(value: self.coreLimit, fieldNumber: 8)
    }
    try { if let v = self._payloadConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    if !self.coreList.isEmpty {
      try visitor.visitPackedInt32Field(value: self.coreList, fieldNumber: 10)
    }
    if !self.otherServerApi.isEmpty {
      try visitor.visitSingularStringField(value: self.otherServerApi, fieldNumber: 11)
    }
    if self.threadsPerCq != 0 {
      try visitor.visitSingularInt32Field(value: self.threadsPerCq, fieldNumber: 12)
    }
    if self.serverProcesses != 0 {
      try visitor.visitSingularInt32Field(value: self.serverProcesses, fieldNumber: 21)
    }
    if self.resourceQuotaSize != 0 {
      try visitor.visitSingularInt32Field(value: self.resourceQuotaSize, fieldNumber: 1001)
    }
    if !self.channelArgs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.channelArgs, fieldNumber: 1002)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_Testing_ServerConfig, rhs: Grpc_Testing_ServerConfig) -> Bool {
    if lhs.serverType != rhs.serverType {return false}
    if lhs._securityParams != rhs._securityParams {return false}
    if lhs.port != rhs.port {return false}
    if lhs.asyncServerThreads != rhs.asyncServerThreads {return false}
    if lhs.coreLimit != rhs.coreLimit {return false}
    if lhs._payloadConfig != rhs._payloadConfig {return false}
    if lhs.coreList != rhs.coreList {return false}
    if lhs.otherServerApi != rhs.otherServerApi {return false}
    if lhs.threadsPerCq != rhs.threadsPerCq {return false}
    if lhs.resourceQuotaSize != rhs.resourceQuotaSize {return false}
    if lhs.channelArgs != rhs.channelArgs {return false}
    if lhs.serverProcesses != rhs.serverProcesses {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_Testing_ServerArgs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ServerArgs"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "setup"),
    2: .same(proto: "mark"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Grpc_Testing_ServerConfig?
        var hadOneofValue = false
        if let current = self.argtype {
          hadOneofValue = true
          if case .setup(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.argtype = .setup(v)
        }
      }()
      case 2: try {
        var v: Grpc_Testing_Mark?
        var hadOneofValue = false
        if let current = self.argtype {
          hadOneofValue = true
          if case .mark(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.argtype = .mark(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.argtype {
    case .setup?: try {
      guard case .setup(let v)? = self.argtype else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .mark?: try {
      guard case .mark(let v)? = self.argtype else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_Testing_ServerArgs, rhs: Grpc_Testing_ServerArgs) -> Bool {
    if lhs.argtype != rhs.argtype {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_Testing_ServerStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ServerStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "stats"),
    2: .same(proto: "port"),
    3: .same(proto: "cores"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._stats) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.port) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.cores) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._stats {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.port != 0 {
      try visitor.visitSingularInt32Field(value: self.port, fieldNumber: 2)
    }
    if self.cores != 0 {
      try visitor.visitSingularInt32Field(value: self.cores, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_Testing_ServerStatus, rhs: Grpc_Testing_ServerStatus) -> Bool {
    if lhs._stats != rhs._stats {return false}
    if lhs.port != rhs.port {return false}
    if lhs.cores != rhs.cores {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_Testing_CoreRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CoreRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_Testing_CoreRequest, rhs: Grpc_Testing_CoreRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_Testing_CoreResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CoreResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cores"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.cores) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.cores != 0 {
      try visitor.visitSingularInt32Field(value: self.cores, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_Testing_CoreResponse, rhs: Grpc_Testing_CoreResponse) -> Bool {
    if lhs.cores != rhs.cores {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_Testing_Void: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Void"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_Testing_Void, rhs: Grpc_Testing_Void) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_Testing_Scenario: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Scenario"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "client_config"),
    3: .standard(proto: "num_clients"),
    4: .standard(proto: "server_config"),
    5: .standard(proto: "num_servers"),
    6: .standard(proto: "warmup_seconds"),
    7: .standard(proto: "benchmark_seconds"),
    8: .standard(proto: "spawn_local_worker_count"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _clientConfig: Grpc_Testing_ClientConfig? = nil
    var _numClients: Int32 = 0
    var _serverConfig: Grpc_Testing_ServerConfig? = nil
    var _numServers: Int32 = 0
    var _warmupSeconds: Int32 = 0
    var _benchmarkSeconds: Int32 = 0
    var _spawnLocalWorkerCount: Int32 = 0

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _clientConfig = source._clientConfig
      _numClients = source._numClients
      _serverConfig = source._serverConfig
      _numServers = source._numServers
      _warmupSeconds = source._warmupSeconds
      _benchmarkSeconds = source._benchmarkSeconds
      _spawnLocalWorkerCount = source._spawnLocalWorkerCount
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._clientConfig) }()
        case 3: try { try decoder.decodeSingularInt32Field(value: &_storage._numClients) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._serverConfig) }()
        case 5: try { try decoder.decodeSingularInt32Field(value: &_storage._numServers) }()
        case 6: try { try decoder.decodeSingularInt32Field(value: &_storage._warmupSeconds) }()
        case 7: try { try decoder.decodeSingularInt32Field(value: &_storage._benchmarkSeconds) }()
        case 8: try { try decoder.decodeSingularInt32Field(value: &_storage._spawnLocalWorkerCount) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      try { if let v = _storage._clientConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if _storage._numClients != 0 {
        try visitor.visitSingularInt32Field(value: _storage._numClients, fieldNumber: 3)
      }
      try { if let v = _storage._serverConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if _storage._numServers != 0 {
        try visitor.visitSingularInt32Field(value: _storage._numServers, fieldNumber: 5)
      }
      if _storage._warmupSeconds != 0 {
        try visitor.visitSingularInt32Field(value: _storage._warmupSeconds, fieldNumber: 6)
      }
      if _storage._benchmarkSeconds != 0 {
        try visitor.visitSingularInt32Field(value: _storage._benchmarkSeconds, fieldNumber: 7)
      }
      if _storage._spawnLocalWorkerCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._spawnLocalWorkerCount, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_Testing_Scenario, rhs: Grpc_Testing_Scenario) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._clientConfig != rhs_storage._clientConfig {return false}
        if _storage._numClients != rhs_storage._numClients {return false}
        if _storage._serverConfig != rhs_storage._serverConfig {return false}
        if _storage._numServers != rhs_storage._numServers {return false}
        if _storage._warmupSeconds != rhs_storage._warmupSeconds {return false}
        if _storage._benchmarkSeconds != rhs_storage._benchmarkSeconds {return false}
        if _storage._spawnLocalWorkerCount != rhs_storage._spawnLocalWorkerCount {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_Testing_Scenarios: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Scenarios"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "scenarios"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.scenarios) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.scenarios.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.scenarios, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_Testing_Scenarios, rhs: Grpc_Testing_Scenarios) -> Bool {
    if lhs.scenarios != rhs.scenarios {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_Testing_ScenarioResultSummary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ScenarioResultSummary"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "qps"),
    2: .standard(proto: "qps_per_server_core"),
    3: .standard(proto: "server_system_time"),
    4: .standard(proto: "server_user_time"),
    5: .standard(proto: "client_system_time"),
    6: .standard(proto: "client_user_time"),
    7: .standard(proto: "latency_50"),
    8: .standard(proto: "latency_90"),
    9: .standard(proto: "latency_95"),
    10: .standard(proto: "latency_99"),
    11: .standard(proto: "latency_999"),
    12: .standard(proto: "server_cpu_usage"),
    13: .standard(proto: "successful_requests_per_second"),
    14: .standard(proto: "failed_requests_per_second"),
    15: .standard(proto: "client_polls_per_request"),
    16: .standard(proto: "server_polls_per_request"),
    17: .standard(proto: "server_queries_per_cpu_sec"),
    18: .standard(proto: "client_queries_per_cpu_sec"),
    19: .standard(proto: "start_time"),
    20: .standard(proto: "end_time"),
  ]

  fileprivate class _StorageClass {
    var _qps: Double = 0
    var _qpsPerServerCore: Double = 0
    var _serverSystemTime: Double = 0
    var _serverUserTime: Double = 0
    var _clientSystemTime: Double = 0
    var _clientUserTime: Double = 0
    var _latency50: Double = 0
    var _latency90: Double = 0
    var _latency95: Double = 0
    var _latency99: Double = 0
    var _latency999: Double = 0
    var _serverCpuUsage: Double = 0
    var _successfulRequestsPerSecond: Double = 0
    var _failedRequestsPerSecond: Double = 0
    var _clientPollsPerRequest: Double = 0
    var _serverPollsPerRequest: Double = 0
    var _serverQueriesPerCpuSec: Double = 0
    var _clientQueriesPerCpuSec: Double = 0
    var _startTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _endTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _qps = source._qps
      _qpsPerServerCore = source._qpsPerServerCore
      _serverSystemTime = source._serverSystemTime
      _serverUserTime = source._serverUserTime
      _clientSystemTime = source._clientSystemTime
      _clientUserTime = source._clientUserTime
      _latency50 = source._latency50
      _latency90 = source._latency90
      _latency95 = source._latency95
      _latency99 = source._latency99
      _latency999 = source._latency999
      _serverCpuUsage = source._serverCpuUsage
      _successfulRequestsPerSecond = source._successfulRequestsPerSecond
      _failedRequestsPerSecond = source._failedRequestsPerSecond
      _clientPollsPerRequest = source._clientPollsPerRequest
      _serverPollsPerRequest = source._serverPollsPerRequest
      _serverQueriesPerCpuSec = source._serverQueriesPerCpuSec
      _clientQueriesPerCpuSec = source._clientQueriesPerCpuSec
      _startTime = source._startTime
      _endTime = source._endTime
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularDoubleField(value: &_storage._qps) }()
        case 2: try { try decoder.decodeSingularDoubleField(value: &_storage._qpsPerServerCore) }()
        case 3: try { try decoder.decodeSingularDoubleField(value: &_storage._serverSystemTime) }()
        case 4: try { try decoder.decodeSingularDoubleField(value: &_storage._serverUserTime) }()
        case 5: try { try decoder.decodeSingularDoubleField(value: &_storage._clientSystemTime) }()
        case 6: try { try decoder.decodeSingularDoubleField(value: &_storage._clientUserTime) }()
        case 7: try { try decoder.decodeSingularDoubleField(value: &_storage._latency50) }()
        case 8: try { try decoder.decodeSingularDoubleField(value: &_storage._latency90) }()
        case 9: try { try decoder.decodeSingularDoubleField(value: &_storage._latency95) }()
        case 10: try { try decoder.decodeSingularDoubleField(value: &_storage._latency99) }()
        case 11: try { try decoder.decodeSingularDoubleField(value: &_storage._latency999) }()
        case 12: try { try decoder.decodeSingularDoubleField(value: &_storage._serverCpuUsage) }()
        case 13: try { try decoder.decodeSingularDoubleField(value: &_storage._successfulRequestsPerSecond) }()
        case 14: try { try decoder.decodeSingularDoubleField(value: &_storage._failedRequestsPerSecond) }()
        case 15: try { try decoder.decodeSingularDoubleField(value: &_storage._clientPollsPerRequest) }()
        case 16: try { try decoder.decodeSingularDoubleField(value: &_storage._serverPollsPerRequest) }()
        case 17: try { try decoder.decodeSingularDoubleField(value: &_storage._serverQueriesPerCpuSec) }()
        case 18: try { try decoder.decodeSingularDoubleField(value: &_storage._clientQueriesPerCpuSec) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._startTime) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._endTime) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._qps.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._qps, fieldNumber: 1)
      }
      if _storage._qpsPerServerCore.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._qpsPerServerCore, fieldNumber: 2)
      }
      if _storage._serverSystemTime.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._serverSystemTime, fieldNumber: 3)
      }
      if _storage._serverUserTime.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._serverUserTime, fieldNumber: 4)
      }
      if _storage._clientSystemTime.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._clientSystemTime, fieldNumber: 5)
      }
      if _storage._clientUserTime.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._clientUserTime, fieldNumber: 6)
      }
      if _storage._latency50.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._latency50, fieldNumber: 7)
      }
      if _storage._latency90.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._latency90, fieldNumber: 8)
      }
      if _storage._latency95.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._latency95, fieldNumber: 9)
      }
      if _storage._latency99.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._latency99, fieldNumber: 10)
      }
      if _storage._latency999.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._latency999, fieldNumber: 11)
      }
      if _storage._serverCpuUsage.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._serverCpuUsage, fieldNumber: 12)
      }
      if _storage._successfulRequestsPerSecond.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._successfulRequestsPerSecond, fieldNumber: 13)
      }
      if _storage._failedRequestsPerSecond.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._failedRequestsPerSecond, fieldNumber: 14)
      }
      if _storage._clientPollsPerRequest.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._clientPollsPerRequest, fieldNumber: 15)
      }
      if _storage._serverPollsPerRequest.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._serverPollsPerRequest, fieldNumber: 16)
      }
      if _storage._serverQueriesPerCpuSec.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._serverQueriesPerCpuSec, fieldNumber: 17)
      }
      if _storage._clientQueriesPerCpuSec.bitPattern != 0 {
        try visitor.visitSingularDoubleField(value: _storage._clientQueriesPerCpuSec, fieldNumber: 18)
      }
      try { if let v = _storage._startTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._endTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_Testing_ScenarioResultSummary, rhs: Grpc_Testing_ScenarioResultSummary) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._qps != rhs_storage._qps {return false}
        if _storage._qpsPerServerCore != rhs_storage._qpsPerServerCore {return false}
        if _storage._serverSystemTime != rhs_storage._serverSystemTime {return false}
        if _storage._serverUserTime != rhs_storage._serverUserTime {return false}
        if _storage._clientSystemTime != rhs_storage._clientSystemTime {return false}
        if _storage._clientUserTime != rhs_storage._clientUserTime {return false}
        if _storage._latency50 != rhs_storage._latency50 {return false}
        if _storage._latency90 != rhs_storage._latency90 {return false}
        if _storage._latency95 != rhs_storage._latency95 {return false}
        if _storage._latency99 != rhs_storage._latency99 {return false}
        if _storage._latency999 != rhs_storage._latency999 {return false}
        if _storage._serverCpuUsage != rhs_storage._serverCpuUsage {return false}
        if _storage._successfulRequestsPerSecond != rhs_storage._successfulRequestsPerSecond {return false}
        if _storage._failedRequestsPerSecond != rhs_storage._failedRequestsPerSecond {return false}
        if _storage._clientPollsPerRequest != rhs_storage._clientPollsPerRequest {return false}
        if _storage._serverPollsPerRequest != rhs_storage._serverPollsPerRequest {return false}
        if _storage._serverQueriesPerCpuSec != rhs_storage._serverQueriesPerCpuSec {return false}
        if _storage._clientQueriesPerCpuSec != rhs_storage._clientQueriesPerCpuSec {return false}
        if _storage._startTime != rhs_storage._startTime {return false}
        if _storage._endTime != rhs_storage._endTime {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grpc_Testing_ScenarioResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ScenarioResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "scenario"),
    2: .same(proto: "latencies"),
    3: .standard(proto: "client_stats"),
    4: .standard(proto: "server_stats"),
    5: .standard(proto: "server_cores"),
    6: .same(proto: "summary"),
    7: .standard(proto: "client_success"),
    8: .standard(proto: "server_success"),
    9: .standard(proto: "request_results"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._scenario) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._latencies) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.clientStats) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.serverStats) }()
      case 5: try { try decoder.decodeRepeatedInt32Field(value: &self.serverCores) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._summary) }()
      case 7: try { try decoder.decodeRepeatedBoolField(value: &self.clientSuccess) }()
      case 8: try { try decoder.decodeRepeatedBoolField(value: &self.serverSuccess) }()
      case 9: try { try decoder.decodeRepeatedMessageField(value: &self.requestResults) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._scenario {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._latencies {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.clientStats.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.clientStats, fieldNumber: 3)
    }
    if !self.serverStats.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.serverStats, fieldNumber: 4)
    }
    if !self.serverCores.isEmpty {
      try visitor.visitPackedInt32Field(value: self.serverCores, fieldNumber: 5)
    }
    try { if let v = self._summary {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if !self.clientSuccess.isEmpty {
      try visitor.visitPackedBoolField(value: self.clientSuccess, fieldNumber: 7)
    }
    if !self.serverSuccess.isEmpty {
      try visitor.visitPackedBoolField(value: self.serverSuccess, fieldNumber: 8)
    }
    if !self.requestResults.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.requestResults, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Grpc_Testing_ScenarioResult, rhs: Grpc_Testing_ScenarioResult) -> Bool {
    if lhs._scenario != rhs._scenario {return false}
    if lhs._latencies != rhs._latencies {return false}
    if lhs.clientStats != rhs.clientStats {return false}
    if lhs.serverStats != rhs.serverStats {return false}
    if lhs.serverCores != rhs.serverCores {return false}
    if lhs._summary != rhs._summary {return false}
    if lhs.clientSuccess != rhs.clientSuccess {return false}
    if lhs.serverSuccess != rhs.serverSuccess {return false}
    if lhs.requestResults != rhs.requestResults {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
