// Copyright 2015 The gRPC Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// The canonical version of this proto can be found at
// https://github.com/grpc/grpc-proto/blob/master/grpc/health/v1/health.proto

// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the gRPC Swift generator plugin for the protocol buffer compiler.
// Source: health.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/grpc/grpc-swift

import GRPCCore
import GRPCProtobuf

internal enum Grpc_Health_V1_Health {
    internal enum Method {
        internal enum Check {
            internal typealias Input = Grpc_Health_V1_HealthCheckRequest
            internal typealias Output = Grpc_Health_V1_HealthCheckResponse
            internal static let descriptor = MethodDescriptor(
                service: "grpc.health.v1.Health",
                method: "Check"
            )
        }
        internal enum Watch {
            internal typealias Input = Grpc_Health_V1_HealthCheckRequest
            internal typealias Output = Grpc_Health_V1_HealthCheckResponse
            internal static let descriptor = MethodDescriptor(
                service: "grpc.health.v1.Health",
                method: "Watch"
            )
        }
        internal static let descriptors: [MethodDescriptor] = [
            Check.descriptor,
            Watch.descriptor
        ]
    }
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    internal typealias StreamingServiceProtocol = Grpc_Health_V1_HealthStreamingServiceProtocol
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    internal typealias ServiceProtocol = Grpc_Health_V1_HealthServiceProtocol
}

/// Health is gRPC's mechanism for checking whether a server is able to handle
/// RPCs. Its semantics are documented in
/// https://github.com/grpc/grpc/blob/master/doc/health-checking.md.
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
internal protocol Grpc_Health_V1_HealthStreamingServiceProtocol: GRPCCore.RegistrableRPCService {
    /// Check gets the health of the specified service. If the requested service
    /// is unknown, the call will fail with status NOT_FOUND. If the caller does
    /// not specify a service name, the server should respond with its overall
    /// health status.
    ///
    /// Clients should set a deadline when calling Check, and can declare the
    /// server unhealthy if they do not receive a timely response.
    ///
    /// Check implementations should be idempotent and side effect free.
    func check(request: ServerRequest.Stream<Grpc_Health_V1_HealthCheckRequest>) async throws -> ServerResponse.Stream<Grpc_Health_V1_HealthCheckResponse>

    /// Performs a watch for the serving status of the requested service.
    /// The server will immediately send back a message indicating the current
    /// serving status.  It will then subsequently send a new message whenever
    /// the service's serving status changes.
    ///
    /// If the requested service is unknown when the call is received, the
    /// server will send a message setting the serving status to
    /// SERVICE_UNKNOWN but will *not* terminate the call.  If at some
    /// future point, the serving status of the service becomes known, the
    /// server will send a new message with the service's serving status.
    ///
    /// If the call terminates with status UNIMPLEMENTED, then clients
    /// should assume this method is not supported and should not retry the
    /// call.  If the call terminates with any other status (including OK),
    /// clients should retry the call with appropriate exponential backoff.
    func watch(request: ServerRequest.Stream<Grpc_Health_V1_HealthCheckRequest>) async throws -> ServerResponse.Stream<Grpc_Health_V1_HealthCheckResponse>
}

/// Conformance to `GRPCCore.RegistrableRPCService`.
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension Grpc_Health_V1_Health.StreamingServiceProtocol {
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    internal func registerMethods(with router: inout GRPCCore.RPCRouter) {
        router.registerHandler(
            forMethod: Grpc_Health_V1_Health.Method.Check.descriptor,
            deserializer: ProtobufDeserializer<Grpc_Health_V1_HealthCheckRequest>(),
            serializer: ProtobufSerializer<Grpc_Health_V1_HealthCheckResponse>(),
            handler: { request in
                try await self.check(request: request)
            }
        )
        router.registerHandler(
            forMethod: Grpc_Health_V1_Health.Method.Watch.descriptor,
            deserializer: ProtobufDeserializer<Grpc_Health_V1_HealthCheckRequest>(),
            serializer: ProtobufSerializer<Grpc_Health_V1_HealthCheckResponse>(),
            handler: { request in
                try await self.watch(request: request)
            }
        )
    }
}

/// Health is gRPC's mechanism for checking whether a server is able to handle
/// RPCs. Its semantics are documented in
/// https://github.com/grpc/grpc/blob/master/doc/health-checking.md.
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
internal protocol Grpc_Health_V1_HealthServiceProtocol: Grpc_Health_V1_Health.StreamingServiceProtocol {
    /// Check gets the health of the specified service. If the requested service
    /// is unknown, the call will fail with status NOT_FOUND. If the caller does
    /// not specify a service name, the server should respond with its overall
    /// health status.
    ///
    /// Clients should set a deadline when calling Check, and can declare the
    /// server unhealthy if they do not receive a timely response.
    ///
    /// Check implementations should be idempotent and side effect free.
    func check(request: ServerRequest.Single<Grpc_Health_V1_HealthCheckRequest>) async throws -> ServerResponse.Single<Grpc_Health_V1_HealthCheckResponse>

    /// Performs a watch for the serving status of the requested service.
    /// The server will immediately send back a message indicating the current
    /// serving status.  It will then subsequently send a new message whenever
    /// the service's serving status changes.
    ///
    /// If the requested service is unknown when the call is received, the
    /// server will send a message setting the serving status to
    /// SERVICE_UNKNOWN but will *not* terminate the call.  If at some
    /// future point, the serving status of the service becomes known, the
    /// server will send a new message with the service's serving status.
    ///
    /// If the call terminates with status UNIMPLEMENTED, then clients
    /// should assume this method is not supported and should not retry the
    /// call.  If the call terminates with any other status (including OK),
    /// clients should retry the call with appropriate exponential backoff.
    func watch(request: ServerRequest.Single<Grpc_Health_V1_HealthCheckRequest>) async throws -> ServerResponse.Stream<Grpc_Health_V1_HealthCheckResponse>
}

/// Partial conformance to `Grpc_Health_V1_HealthStreamingServiceProtocol`.
@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension Grpc_Health_V1_Health.ServiceProtocol {
    internal func check(request: ServerRequest.Stream<Grpc_Health_V1_HealthCheckRequest>) async throws -> ServerResponse.Stream<Grpc_Health_V1_HealthCheckResponse> {
        let response = try await self.check(request: ServerRequest.Single(stream: request))
        return ServerResponse.Stream(single: response)
    }

    internal func watch(request: ServerRequest.Stream<Grpc_Health_V1_HealthCheckRequest>) async throws -> ServerResponse.Stream<Grpc_Health_V1_HealthCheckResponse> {
        let response = try await self.watch(request: ServerRequest.Single(stream: request))
        return response
    }
}